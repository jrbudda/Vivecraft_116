--- a/net/minecraft/client/renderer/FirstPersonRenderer.java
+++ b/net/minecraft/client/renderer/FirstPersonRenderer.java
@@ -2,25 +2,75 @@
 
 import com.google.common.base.MoreObjects;
 import com.mojang.blaze3d.matrix.MatrixStack;
+import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.blaze3d.vertex.IVertexBuilder;
+
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Objects;
+import java.util.stream.Stream;
+
+import javax.management.relation.RelationServiceNotRegisteredException;
+
+import org.lwjgl.opengl.GL11;
+import org.vivecraft.control.ControllerType;
+import org.vivecraft.gameplay.trackers.BowTracker;
+import org.vivecraft.gameplay.trackers.SwingTracker;
+import org.vivecraft.gameplay.trackers.TelescopeTracker;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.VRArmRenderer;
+import org.vivecraft.render.VRFirstPersonArmSwing;
+import org.vivecraft.render.VRRenderType;
+import org.vivecraft.render.VivecraftItemRendering;
+
+import net.minecraft.block.BambooBlock;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockState;
+import net.minecraft.block.RedstoneTorchBlock;
+import net.minecraft.block.TorchBlock;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.player.AbstractClientPlayerEntity;
 import net.minecraft.client.entity.player.ClientPlayerEntity;
 import net.minecraft.client.renderer.entity.EntityRendererManager;
 import net.minecraft.client.renderer.entity.PlayerRenderer;
+import net.minecraft.client.renderer.model.IBakedModel;
 import net.minecraft.client.renderer.model.ItemCameraTransforms;
+import net.minecraft.client.renderer.model.ModelBakery;
+import net.minecraft.client.renderer.texture.AtlasTexture;
 import net.minecraft.client.renderer.texture.OverlayTexture;
+import net.minecraft.client.renderer.texture.TextureAtlasSprite;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.minecraft.enchantment.EnchantmentHelper;
 import net.minecraft.entity.LivingEntity;
+import net.minecraft.item.AbstractMapItem;
+import net.minecraft.item.ArrowItem;
+import net.minecraft.item.BlockItem;
+import net.minecraft.item.CompassItem;
 import net.minecraft.item.CrossbowItem;
 import net.minecraft.item.FilledMapItem;
+import net.minecraft.item.FishingRodItem;
+import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
+import net.minecraft.item.Items;
+import net.minecraft.item.OnAStickItem;
+import net.minecraft.item.ShieldItem;
 import net.minecraft.item.ShootableItem;
+import net.minecraft.item.SwordItem;
+import net.minecraft.item.TridentItem;
+import net.minecraft.item.UseAction;
+import net.minecraft.network.play.server.SJoinGamePacket;
 import net.minecraft.util.Hand;
 import net.minecraft.util.HandSide;
 import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Util;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.vector.Matrix4f;
+import net.minecraft.util.math.vector.Quaternion;
+import net.minecraft.util.math.vector.Vector3d;
 import net.minecraft.util.math.vector.Vector3f;
 import net.minecraft.world.storage.MapData;
 import net.optifine.Config;
@@ -30,8 +80,8 @@
 
 public class FirstPersonRenderer
 {
-    private static final RenderType MAP_BACKGROUND = RenderType.getText(new ResourceLocation("textures/map/map_background.png"));
-    private static final RenderType MAP_BACKGROUND_CHECKERBOARD = RenderType.getText(new ResourceLocation("textures/map/map_background_checkerboard.png"));
+    private static final RenderType MAP_BACKGROUND = VRRenderType.getTextNoCull(new ResourceLocation("textures/map/map_background.png"));
+    private static final RenderType MAP_BACKGROUND_CHECKERBOARD = VRRenderType.getTextNoCull(new ResourceLocation("textures/map/map_background_checkerboard.png"));
     private final Minecraft mc;
     private ItemStack itemStackMainHand = ItemStack.EMPTY;
     private ItemStack itemStackOffHand = ItemStack.EMPTY;
@@ -41,12 +91,22 @@
     private float prevEquippedProgressOffHand;
     private final EntityRendererManager renderManager;
     private final ItemRenderer itemRenderer;
-
+    //Vivecraft
+    private final VRArmRenderer myRenderVRPlayer;
+    private final Map<String, VRArmRenderer> renderVRPlayerSkinMap = new HashMap<>();
+    public VRFirstPersonArmSwing swingType = VRFirstPersonArmSwing.Attack;  
+    public float xdist = -0;
+    
     public FirstPersonRenderer(Minecraft p_i88_1_)
     {
         this.mc = p_i88_1_;
         this.renderManager = p_i88_1_.getRenderManager();
         this.itemRenderer = p_i88_1_.getItemRenderer();
+        //Vivecraft
+        myRenderVRPlayer = new VRArmRenderer(this.renderManager);
+        renderVRPlayerSkinMap.put("default", this.myRenderVRPlayer);
+        renderVRPlayerSkinMap.put("slim", new VRArmRenderer(this.renderManager, true));     
+        //
     }
 
     public void renderItemSide(LivingEntity livingEntityIn, ItemStack itemStackIn, ItemCameraTransforms.TransformType transformTypeIn, boolean leftHand, MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn)
@@ -68,6 +128,7 @@
         return -MathHelper.cos(f * (float)Math.PI) * 0.5F + 0.5F;
     }
 
+    //unused
     private void renderArm(MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn, HandSide side)
     {
         this.mc.getTextureManager().bindTexture(this.mc.player.getLocationSkin());
@@ -91,6 +152,7 @@
         matrixStackIn.pop();
     }
 
+    //unused
     private void renderMapFirstPersonSide(MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn, float equippedProgress, HandSide handIn, float swingProgress, ItemStack stack)
     {
         float f = handIn == HandSide.RIGHT ? 1.0F : -1.0F;
@@ -118,6 +180,7 @@
         matrixStackIn.pop();
     }
 
+    //unused
     private void renderMapFirstPerson(MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn, float pitch, float equippedProgress, float swingProgress)
     {
         float f = MathHelper.sqrt(swingProgress);
@@ -143,6 +206,7 @@
         this.renderMapFirstPerson(matrixStackIn, bufferIn, combinedLightIn, this.itemStackMainHand);
     }
 
+    //actually used.
     private void renderMapFirstPerson(MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn, ItemStack stack)
     {
         matrixStackIn.rotate(Vector3f.YP.rotationDegrees(180.0F));
@@ -168,24 +232,38 @@
     {
         boolean flag = side != HandSide.LEFT;
         float f = flag ? 1.0F : -1.0F;
-        float f1 = MathHelper.sqrt(swingProgress);
-        float f2 = -0.3F * MathHelper.sin(f1 * (float)Math.PI);
-        float f3 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
-        float f4 = -0.4F * MathHelper.sin(swingProgress * (float)Math.PI);
-        matrixStackIn.translate((double)(f * (f2 + 0.64000005F)), (double)(f3 + -0.6F + equippedProgress * -0.6F), (double)(f4 + -0.71999997F));
-        matrixStackIn.rotate(Vector3f.YP.rotationDegrees(f * 45.0F));
-        float f5 = MathHelper.sin(swingProgress * swingProgress * (float)Math.PI);
-        float f6 = MathHelper.sin(f1 * (float)Math.PI);
-        matrixStackIn.rotate(Vector3f.YP.rotationDegrees(f * f6 * 70.0F));
-        matrixStackIn.rotate(Vector3f.ZP.rotationDegrees(f * f5 * -20.0F));
+//        float f1 = MathHelper.sqrt(swingProgress);
+//        float f2 = -0.3F * MathHelper.sin(f1 * (float)Math.PI);
+//        float f3 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
+//        float f4 = -0.4F * MathHelper.sin(swingProgress * (float)Math.PI);
+//        matrixStackIn.translate((double)(f * (f2 + 0.64000005F)), (double)(f3 + -0.6F + equippedProgress * -0.6F), (double)(f4 + -0.71999997F));
+//        matrixStackIn.rotate(Vector3f.YP.rotationDegrees(f * 45.0F));
+//        float f5 = MathHelper.sin(swingProgress * swingProgress * (float)Math.PI);
+//        float f6 = MathHelper.sin(f1 * (float)Math.PI);
+//        matrixStackIn.rotate(Vector3f.YP.rotationDegrees(f * f6 * 70.0F));
+//        matrixStackIn.rotate(Vector3f.ZP.rotationDegrees(f * f5 * -20.0F));
         AbstractClientPlayerEntity abstractclientplayerentity = this.mc.player;
         this.mc.getTextureManager().bindTexture(abstractclientplayerentity.getLocationSkin());
-        matrixStackIn.translate((double)(f * -1.0F), (double)3.6F, 3.5D);
-        matrixStackIn.rotate(Vector3f.ZP.rotationDegrees(f * 120.0F));
-        matrixStackIn.rotate(Vector3f.XP.rotationDegrees(200.0F));
-        matrixStackIn.rotate(Vector3f.YP.rotationDegrees(f * -135.0F));
-        matrixStackIn.translate((double)(f * 5.6F), 0.0D, 0.0D);
-        PlayerRenderer playerrenderer = (PlayerRenderer)this.renderManager.<AbstractClientPlayerEntity>getRenderer(abstractclientplayerentity);
+//        matrixStackIn.translate((double)(f * -1.0F), (double)3.6F, 3.5D);
+//        matrixStackIn.rotate(Vector3f.ZP.rotationDegrees(f * 120.0F));
+//        matrixStackIn.rotate(Vector3f.XP.rotationDegrees(200.0F));
+//        matrixStackIn.rotate(Vector3f.YP.rotationDegrees(f * -135.0F));
+//        matrixStackIn.translate((double)(f * 5.6F), 0.0D, 0.0D);
+    	VRArmRenderer playerrenderer = renderVRPlayerSkinMap.get(abstractclientplayerentity.getSkinType());
+
+    	matrixStackIn.push();
+		
+	    	if(abstractclientplayerentity.swingingHand == Hand.MAIN_HAND && flag)
+		    	this.transformFirstPersonVR(matrixStackIn, side, swingProgress);
+	    	
+	    	if(abstractclientplayerentity.swingingHand == Hand.OFF_HAND && !flag)
+		    	this.transformFirstPersonVR(matrixStackIn, side, swingProgress);   
+    	
+			matrixStackIn.scale(0.4f, 0.4F, 0.4F);
+	    	boolean slim = abstractclientplayerentity.getSkinType().equals("slim");
+	    	matrixStackIn.translate(slim ? 0.345F * -f : 0.375F * -f, 0, slim ? 0.785F : 0.75F);
+	    	matrixStackIn.rotate(Vector3f.XP.rotationDegrees(-90));
+	    	matrixStackIn.rotate(Vector3f.YP.rotationDegrees(180));	
 
         if (flag)
         {
@@ -195,6 +273,8 @@
         {
             playerrenderer.renderLeftArm(matrixStackIn, bufferIn, combinedLightIn, abstractclientplayerentity);
         }
+	        
+        matrixStackIn.pop();
     }
 
     private void transformEatFirstPerson(MatrixStack matrixStackIn, float partialTicks, HandSide handIn, ItemStack stack)
@@ -216,6 +296,7 @@
         matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((float)i * f3 * 30.0F));
     }
 
+    //unused
     private void transformFirstPerson(MatrixStack matrixStackIn, HandSide handIn, float swingProgress)
     {
         int i = handIn == HandSide.RIGHT ? 1 : -1;
@@ -226,6 +307,44 @@
         matrixStackIn.rotate(Vector3f.XP.rotationDegrees(f1 * -80.0F));
         matrixStackIn.rotate(Vector3f.YP.rotationDegrees((float)i * -45.0F));
     }
+    
+    private void transformFirstPersonVR(MatrixStack matrixStackIn, HandSide hand, float swingProgress)
+    {
+    	if(swingProgress == 0) {
+    		return;
+    	}
+    	
+    	float f2;
+    	
+    	switch(swingType) {
+    	case Attack:
+    		f2 = MathHelper.sin((float) (swingProgress * 3 * Math.PI));
+    		if(swingProgress > 0.5) {
+    			f2= MathHelper.sin((float) (swingProgress * Math.PI + Math.PI));
+    		}   	
+    		matrixStackIn.translate(0,0,0.2f);
+            matrixStackIn.rotate(Vector3f.XP.rotationDegrees(f2 * 30.0F));
+    		matrixStackIn.translate(0,0,-0.2f);
+    		break;
+    	case Interact:
+    		f2 = MathHelper.sin((float) (swingProgress * 3 * Math.PI));
+    		if(swingProgress > 0.5) {
+    			f2= MathHelper.sin((float) (swingProgress * Math.PI + Math.PI));
+    		}   	
+            matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((float)(hand == HandSide.RIGHT ? -1 :1)  *  (f2) * 45.0F  ));
+    		break;
+    	case Use:
+    		f2 = MathHelper.sin((float) (swingProgress * 2 * Math.PI));
+    		if(swingProgress > 0.25) {
+    			f2= MathHelper.sin((float) (swingProgress / 2 * Math.PI  + Math.PI));
+    		}       		
+    		matrixStackIn.translate(0,0, -(1+f2) * 0.1f);
+    		break;
+    	default:
+    		break;
+
+    	}
+    }
 
     private void transformSideFirstPerson(MatrixStack matrixStackIn, HandSide handIn, float equippedProg)
     {
@@ -233,6 +352,7 @@
         matrixStackIn.translate((double)((float)i * 0.56F), (double)(-0.52F + equippedProg * -0.6F), (double) - 0.72F);
     }
 
+    //Vivecraft unused
     public void renderItemInFirstPerson(float partialTicks, MatrixStack matrixStackIn, IRenderTypeBuffer.Impl bufferIn, ClientPlayerEntity playerEntityIn, int combinedLightIn)
     {
         float f = playerEntityIn.getSwingProgress(partialTicks);
@@ -310,186 +430,421 @@
         bufferIn.finish();
     }
 
-    private void renderItemInFirstPerson(AbstractClientPlayerEntity player, float partialTicks, float pitch, Hand handIn, float swingProgress, ItemStack stack, float equippedProgress, MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn)
+    //swimming in empirical dickery
+    public void renderItemInFirstPerson(AbstractClientPlayerEntity player, float partialTicks, float pitch, Hand handIn, float swingProgress, ItemStack stack, float equippedProgress, MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn)
     {
-        if (!Config.isShaders() || !Shaders.isSkipRenderHand(handIn))
-        {
-            boolean flag = handIn == Hand.MAIN_HAND;
-            HandSide handside = flag ? player.getPrimaryHand() : player.getPrimaryHand().opposite();
-            matrixStackIn.push();
-
-            if (stack.isEmpty())
-            {
-                if (flag && !player.isInvisible())
-                {
-                    this.renderArmFirstPerson(matrixStackIn, bufferIn, combinedLightIn, equippedProgress, swingProgress, handside);
-                }
-            }
-            else if (stack.getItem() instanceof FilledMapItem)
-            {
-                if (flag && this.itemStackOffHand.isEmpty())
-                {
-                    this.renderMapFirstPerson(matrixStackIn, bufferIn, combinedLightIn, pitch, equippedProgress, swingProgress);
-                }
-                else
-                {
-                    this.renderMapFirstPersonSide(matrixStackIn, bufferIn, combinedLightIn, equippedProgress, handside, swingProgress, stack);
-                }
-            }
-            else if (stack.getItem() instanceof CrossbowItem)
-            {
-                boolean flag1 = CrossbowItem.isCharged(stack);
-                boolean flag2 = handside == HandSide.RIGHT;
-                int i = flag2 ? 1 : -1;
-
-                if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == handIn)
-                {
-                    this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                    matrixStackIn.translate((double)((float)i * -0.4785682F), (double) - 0.094387F, (double)0.05731531F);
-                    matrixStackIn.rotate(Vector3f.XP.rotationDegrees(-11.935F));
-                    matrixStackIn.rotate(Vector3f.YP.rotationDegrees((float)i * 65.3F));
-                    matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((float)i * -9.785F));
-                    float f9 = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
-                    float f12 = f9 / (float)CrossbowItem.getChargeTime(stack);
-
-                    if (f12 > 1.0F)
-                    {
-                        f12 = 1.0F;
-                    }
-
-                    if (f12 > 0.1F)
-                    {
-                        float f15 = MathHelper.sin((f9 - 0.1F) * 1.3F);
-                        float f3 = f12 - 0.1F;
-                        float f4 = f15 * f3;
-                        matrixStackIn.translate((double)(f4 * 0.0F), (double)(f4 * 0.004F), (double)(f4 * 0.0F));
-                    }
-
-                    matrixStackIn.translate((double)(f12 * 0.0F), (double)(f12 * 0.0F), (double)(f12 * 0.04F));
-                    matrixStackIn.scale(1.0F, 1.0F, 1.0F + f12 * 0.2F);
-                    matrixStackIn.rotate(Vector3f.YN.rotationDegrees((float)i * 45.0F));
-                }
-                else
-                {
-                    float f = -0.4F * MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
-                    float f1 = 0.2F * MathHelper.sin(MathHelper.sqrt(swingProgress) * ((float)Math.PI * 2F));
-                    float f2 = -0.2F * MathHelper.sin(swingProgress * (float)Math.PI);
-                    matrixStackIn.translate((double)((float)i * f), (double)f1, (double)f2);
-                    this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                    this.transformFirstPerson(matrixStackIn, handside, swingProgress);
-
-                    if (flag1 && swingProgress < 0.001F)
-                    {
-                        matrixStackIn.translate((double)((float)i * -0.641864F), 0.0D, 0.0D);
-                        matrixStackIn.rotate(Vector3f.YP.rotationDegrees((float)i * 10.0F));
-                    }
-                }
-
-                this.renderItemSide(player, stack, flag2 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !flag2, matrixStackIn, bufferIn, combinedLightIn);
-            }
-            else
-            {
-                boolean flag3 = handside == HandSide.RIGHT;
-
-                if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == handIn)
-                {
-                    int k = flag3 ? 1 : -1;
-
-                    switch (stack.getUseAction())
-                    {
-                        case NONE:
-                            this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                            break;
-
-                        case EAT:
-                        case DRINK:
-                            this.transformEatFirstPerson(matrixStackIn, partialTicks, handside, stack);
-                            this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                            break;
-
-                        case BLOCK:
-                            this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                            break;
-
-                        case BOW:
-                            this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                            matrixStackIn.translate((double)((float)k * -0.2785682F), (double)0.18344387F, (double)0.15731531F);
-                            matrixStackIn.rotate(Vector3f.XP.rotationDegrees(-13.935F));
-                            matrixStackIn.rotate(Vector3f.YP.rotationDegrees((float)k * 35.3F));
-                            matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((float)k * -9.785F));
-                            float f8 = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
-                            float f11 = f8 / 20.0F;
-                            f11 = (f11 * f11 + f11 * 2.0F) / 3.0F;
-
-                            if (f11 > 1.0F)
-                            {
-                                f11 = 1.0F;
-                            }
-
-                            if (f11 > 0.1F)
-                            {
-                                float f14 = MathHelper.sin((f8 - 0.1F) * 1.3F);
-                                float f17 = f11 - 0.1F;
-                                float f19 = f14 * f17;
-                                matrixStackIn.translate((double)(f19 * 0.0F), (double)(f19 * 0.004F), (double)(f19 * 0.0F));
-                            }
-
-                            matrixStackIn.translate((double)(f11 * 0.0F), (double)(f11 * 0.0F), (double)(f11 * 0.04F));
-                            matrixStackIn.scale(1.0F, 1.0F, 1.0F + f11 * 0.2F);
-                            matrixStackIn.rotate(Vector3f.YN.rotationDegrees((float)k * 45.0F));
-                            break;
-
-                        case SPEAR:
-                            this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                            matrixStackIn.translate((double)((float)k * -0.5F), (double)0.7F, (double)0.1F);
-                            matrixStackIn.rotate(Vector3f.XP.rotationDegrees(-55.0F));
-                            matrixStackIn.rotate(Vector3f.YP.rotationDegrees((float)k * 35.3F));
-                            matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((float)k * -9.785F));
-                            float f13 = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
-                            float f16 = f13 / 10.0F;
-
-                            if (f16 > 1.0F)
-                            {
-                                f16 = 1.0F;
-                            }
-
-                            if (f16 > 0.1F)
-                            {
-                                float f18 = MathHelper.sin((f13 - 0.1F) * 1.3F);
-                                float f20 = f16 - 0.1F;
-                                float f5 = f18 * f20;
-                                matrixStackIn.translate((double)(f5 * 0.0F), (double)(f5 * 0.004F), (double)(f5 * 0.0F));
-                            }
-
-                            matrixStackIn.translate(0.0D, 0.0D, (double)(f16 * 0.2F));
-                            matrixStackIn.scale(1.0F, 1.0F, 1.0F + f16 * 0.2F);
-                            matrixStackIn.rotate(Vector3f.YN.rotationDegrees((float)k * 45.0F));
-                    }
-                }
-                else if (player.isSpinAttacking())
-                {
-                    this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                    int j = flag3 ? 1 : -1;
-                    matrixStackIn.translate((double)((float)j * -0.4F), (double)0.8F, (double)0.3F);
-                    matrixStackIn.rotate(Vector3f.YP.rotationDegrees((float)j * 65.0F));
-                    matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((float)j * -85.0F));
-                }
-                else
-                {
-                    float f6 = -0.4F * MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
-                    float f7 = 0.2F * MathHelper.sin(MathHelper.sqrt(swingProgress) * ((float)Math.PI * 2F));
-                    float f10 = -0.2F * MathHelper.sin(swingProgress * (float)Math.PI);
-                    int l = flag3 ? 1 : -1;
-                    matrixStackIn.translate((double)((float)l * f6), (double)f7, (double)f10);
-                    this.transformSideFirstPerson(matrixStackIn, handside, equippedProgress);
-                    this.transformFirstPerson(matrixStackIn, handside, swingProgress);
-                }
-
-                this.renderItemSide(player, stack, flag3 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !flag3, matrixStackIn, bufferIn, combinedLightIn);
-            }
-
-            matrixStackIn.pop();
-        }
+    	if (!Config.isShaders() || !Shaders.isSkipRenderHand(handIn))
+    	{
+    		boolean flag = handIn == Hand.MAIN_HAND;
+    		HandSide handside = flag ? player.getPrimaryHand() : player.getPrimaryHand().opposite();
+    		equippedProgress = getEquipProgress(handIn, partialTicks);
+    		matrixStackIn.push();
+
+    		boolean shouldrenderhand = true;
+    		if(mc.currentPass == RenderPass.THIRD && mc.vrSettings.mixedRealityRenderHands == false)
+    			shouldrenderhand = false;
+
+    		if(BowTracker.isBow(stack) && mc.bowTracker.isActive((ClientPlayerEntity) player))
+    			shouldrenderhand = false;
+
+    		if(TelescopeTracker.isTelescope(stack) && ((handIn == Hand.OFF_HAND && mc.currentPass == RenderPass.SCOPEL) || (handIn == Hand.MAIN_HAND && mc.currentPass == RenderPass.SCOPER)))
+    			shouldrenderhand = false;
+
+    		//   	shouldrenderhand = true; //temp
+
+    		if (shouldrenderhand && !player.isInvisible())
+    		{
+    			this.renderArmFirstPerson(matrixStackIn, bufferIn, combinedLightIn, equippedProgress, swingProgress, handside);
+    		}
+
+    		if(!stack.isEmpty()) {
+    			Item item = stack.getItem();
+    			boolean isFilledMap = false;
+
+    			VivecraftItemRendering rendertype = VivecraftItemRendering.Item;
+
+    			if(stack.getUseAction() == UseAction.EAT || stack.getUseAction() == UseAction.DRINK)
+    				rendertype = VivecraftItemRendering.Noms;
+    			else if(item instanceof BlockItem) {
+    				Block b = ((BlockItem) item).getBlock(); 
+    				if(b instanceof TorchBlock) 
+    					rendertype = VivecraftItemRendering.Block_Stick;
+    				else {
+    					IBakedModel mod = itemRenderer.getItemModelWithOverrides(stack, mc.world, mc.player);
+    					if(mod.isGui3d())
+    						rendertype = VivecraftItemRendering.Block_3D;
+    					else
+    						rendertype = VivecraftItemRendering.Block_Item;
+    				}
+    			}
+    			else if(item instanceof FilledMapItem) 
+    				rendertype = VivecraftItemRendering.Map;
+    			else if (stack.getUseAction() == UseAction.BOW) {
+    				rendertype = VivecraftItemRendering.Bow_Seated;
+    				if(mc.bowTracker.isActive((ClientPlayerEntity) player)) {
+    					if(mc.bowTracker.isDrawing)
+    						rendertype = VivecraftItemRendering.Bow_Roomscale_Drawing;
+    					else
+    						rendertype = VivecraftItemRendering.Bow_Roomscale;
+    				}
+    			}
+    			else if(item instanceof SwordItem)
+    				rendertype = VivecraftItemRendering.Sword;
+    			else if(item instanceof ShieldItem)
+    				rendertype = VivecraftItemRendering.Shield;
+    			else if(item instanceof TridentItem)
+    				rendertype = VivecraftItemRendering.Spear;
+    			else if(item instanceof CrossbowItem)
+    				rendertype = VivecraftItemRendering.Crossbow;
+    			else if(item instanceof CompassItem || item == Items.CLOCK)
+    				rendertype = VivecraftItemRendering.Compass;
+    			else if(SwingTracker.isTool(item)) {
+    				rendertype = VivecraftItemRendering.Tool;       		
+    				if(item instanceof OnAStickItem || item instanceof FishingRodItem) {
+    					rendertype = VivecraftItemRendering.Tool_Rod;
+    				}
+    			}
+    			else if(TelescopeTracker.isTelescope(stack)) {
+    				rendertype = VivecraftItemRendering.Telescope;
+    			}
+
+    			int h = (flag ? 1 : -1);
+
+    			//defaults
+    			double scale = 0.7;
+    			double translateX = -.05;
+    			double translateY =  0.005;
+    			double translateZ =  0;
+    			//
+
+    			double gunAngle = MCOpenVR.getGunAngle();
+
+    			Quaternion rotation = Vector3f.YP.rotationDegrees((float) (0));
+    			Quaternion prerotation = Vector3f.YP.rotationDegrees((float) (0));
+
+    			rotation.multiply(Vector3f.XP.rotationDegrees((float) (-110 + gunAngle)));
+    			matrixStackIn.push();
+
+    			boolean mirror = false;
+
+    			if(rendertype == VivecraftItemRendering.Bow_Seated) {
+    				translateY += -0.1;
+    				translateZ += 0.1;
+    				rotation.multiply(Vector3f.XP.rotationDegrees((float) (90 -gunAngle)));
+    				scale = 0.7f;
+    			}
+    			else if(rendertype == VivecraftItemRendering.Bow_Roomscale) {
+    				rotation = Vector3f.XP.rotationDegrees((float) (0));    		
+    				matrixStackIn.rotate((Vector3f.XP.rotationDegrees((float) (-110 + gunAngle))));
+    				translateY-= 0.25f;
+    				translateZ+= 0.025f + 0.03*gunAngle/40f;         	
+    				translateX+= -0.0225;
+    				scale = 1.0f;
+    			}
+    			else if(rendertype == VivecraftItemRendering.Bow_Roomscale_Drawing) {
+    				//here there be dragons
+
+    				//
+    				rotation = Vector3f.YP.rotationDegrees(0);
+    				scale = 1f;
+    				//
+
+    				int c = 0;
+    				if (mc.vrSettings.vrReverseShootingEye) c = 1;
+
+    				Vector3d aim = mc.bowTracker.getAimVector(); 
+    				Vector3d a = new Vector3d(aim.x, aim.y, aim.z);			
+
+    				Vector3d lup = mc.vrPlayer.vrdata_world_render.getHand(1).getCustomVector(new Vector3d(0, -1, 0));
+    				Vector3d lback = mc.vrPlayer.vrdata_world_render.getHand(1).getCustomVector(new Vector3d(0, 0, -1));
+
+    				Vector3d v = a.crossProduct(lup);
+    				double d = 180 / Math.PI * Math.acos(a.dotProduct(lup));
+
+    				float aimpitch = (float)Math.toDegrees(Math.asin(a.y/a.length()));
+    				float yaw = (float)Math.toDegrees(Math.atan2(a.x, a.z));     
+
+    				Vector3d up = new Vector3d(0,1,0);
+
+    				Vector3d ahz = new Vector3d(a.x, 0, a.z); // we want the normal to a aiming plane, but vertical.
+    				Vector3d pAim2 = Vector3d.ZERO;
+
+    				double porjaim = lback.dotProduct(ahz); //angle between controller up and aim, just for ortho check			    		        		
+    				if(porjaim !=0) { //check to make sure 	we arent holding the bow perfectly straight up.					
+    					pAim2 = ahz.scale(porjaim);	 //projection of l_controller_up onto aim vector ... why is there no multiply?		        	 
+    				}
+
+    				double dot =0;
+
+    				Vector3d proj = lback.subtract(pAim2).normalize();
+
+    				dot = proj.dotProduct(up);		//angle between our projection and straight up (the default bow render pos.)
+
+    				double dot2 = ahz.dotProduct(proj.crossProduct(up)); //angle sign test, negative is left roll
+
+    				float angle;
+
+    				if (dot2 < 0) 
+    					angle = -(float) Math.acos(dot);  	
+    				else angle = (float) Math.acos(dot); 
+
+    				float roll = (float) (180 / Math.PI * angle);     //calculate bow model roll.
+
+    				if(mc.bowTracker.isCharged()){
+    					long t = Util.milliTime() - mc.bowTracker.startDrawTime;
+    					translateX += (0.003*Math.sin(t));
+    				}
+
+    				matrixStackIn.translate(0, 0, .1);
+    				//un-do controller tracking
+    				matrixStackIn.getLast().getMatrix().mul(mc.vrPlayer.vrdata_world_render.getController(1).getMatrix().transposed().toMCMatrix());
+    				//
+
+    				//rotate in world coords
+    				rotation.multiply(Vector3f.YP.rotationDegrees(yaw));
+    				rotation.multiply(Vector3f.XP.rotationDegrees(-aimpitch));
+    				rotation.multiply(Vector3f.ZP.rotationDegrees(-roll));
+    				rotation.multiply(Vector3f.ZP.rotationDegrees(180));
+    				//		    			
+
+    				matrixStackIn.getLast().getMatrix().mul(rotation);
+
+    				rotation = Vector3f.YP.rotationDegrees(0);
+
+    				rotation.multiply(Vector3f.YP.rotationDegrees(180));
+    				rotation.multiply(Vector3f.XP.rotationDegrees(160));
+
+    				translateY += .1225;
+    				translateX += 0.125;
+    				translateZ += 0.16;
+
+    			}
+    			else if(rendertype == VivecraftItemRendering.Crossbow) {
+
+    				translateX +=.01f;
+    				translateZ +=-0.02f;
+    				translateY+=-0.02f;
+    				scale = 0.5f;
+    				rotation = Vector3f.XP.rotationDegrees(0);
+    				rotation.multiply(Vector3f.YP.rotationDegrees((float) (10)));
+    			}
+    			else if(rendertype == VivecraftItemRendering.Map) {
+
+    				isFilledMap = true;
+    				rotation = Vector3f.XP.rotationDegrees(-45);
+    				translateX = 0;
+    				translateY = .16;
+    				translateZ = -.075;
+    				scale = 0.75;
+    			}
+    			else if(rendertype == VivecraftItemRendering.Noms) {
+
+    				long t = this.mc.player.getItemInUseCount();
+    				rotation = Vector3f.ZP.rotationDegrees(180);
+    				rotation.multiply(Vector3f.XP.rotationDegrees(-135));
+    				translateZ += 0.006D*Math.sin(t);
+    				translateZ +=0.02f;
+    				translateX +=.08f;
+    				scale = 0.4f;
+    			}
+    			else if(rendertype == VivecraftItemRendering.Item || rendertype == VivecraftItemRendering.Block_Item) {
+
+    				rotation = Vector3f.ZP.rotationDegrees(180);
+    				rotation.multiply(Vector3f.XP.rotationDegrees(-135));
+    				scale = 0.4f;
+    				translateX +=.08f;
+    				translateZ +=-0.08f;
+    			}			
+    			else if(rendertype == VivecraftItemRendering.Compass) {
+    				rotation=(Vector3f.YP.rotationDegrees(90));
+    				rotation.multiply(Vector3f.XP.rotationDegrees(25));
+    				scale = 0.4f;
+    			}		
+    			else if(rendertype == VivecraftItemRendering.Block_3D) {
+    				scale = 0.3f;	
+    				translateZ +=-0.1f;
+    				translateX +=.05f;
+    			}	
+    			else if(rendertype == VivecraftItemRendering.Block_Stick) {
+    				rotation = Vector3f.XP.rotationDegrees(0);
+    				translateY+=-.105+.06*gunAngle/40;
+    				translateZ +=-0.1f;
+    				rotation.multiply(Vector3f.XP.rotationDegrees(-45));
+    				rotation.multiply(Vector3f.XP.rotationDegrees((float) (gunAngle)));
+    			}
+    			else if(rendertype == VivecraftItemRendering.Shield) {
+    				mirror = !flag;
+    				scale = 0.4f;	
+    				translateY += 0.21f;
+    				if (flag)
+    					translateX += 0.11f;
+    				else
+    					translateX += -0.015;
+
+    				translateZ += -0.01f;
+
+    				rotation.multiply(Vector3f.XP.rotationDegrees((float) (105 - gunAngle)));
+
+    				if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == handIn)
+    				{
+    					rotation.multiply(Vector3f.ZP.rotationDegrees(h*-5));
+    					translateY += -0.13f;
+    					translateX +=  h*0.05f;
+    					translateZ += -0.1f;
+
+
+    					if(player.isActiveItemStackBlocking()){		
+    						rotation.multiply(Vector3f.YP.rotationDegrees((h*90.0F)));  
+    					} else{
+    						rotation.multiply(Vector3f.YP.rotationDegrees(((1-equippedProgress)*h*90.0F)));  
+    					}
+    				}
+
+    				rotation.multiply(Vector3f.YP.rotationDegrees((h*-90.0F)));  
+
+    			}
+    			else if(rendertype == VivecraftItemRendering.Spear) {
+    				rotation = Vector3f.XP.rotationDegrees((0));
+
+    				translateX +=-.135f;
+    				translateZ += .575f;
+
+    				scale = 0.6f;
+
+    				float prog = 0;
+    				boolean charging = false;
+    				int j = 0;
+
+    				if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == handIn)
+    				{
+    					charging = true;
+    					j = EnchantmentHelper.getRiptideModifier(stack);
+
+    					if(j<=0 || (j>0 &&player.isWet())){
+    						prog = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
+    						if (prog > 10) { //charged    
+    							prog = 10;
+
+    							if (j>0 && player.isWet()) {      
+    								matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((-mc.tickCounter*10*j) % 360 - partialTicks*10*j));
+    								//		rotation.multiply(Vector3f.ZP.rotationDegrees((-mc.tickCounter*10*j) % 360 - partialTicks*10*j));
+    							}
+
+    							if(mc.frameIndex % 4 == 0) {
+    								MCOpenVR.triggerHapticPulse(flag ? 0 : 1, 200);
+    							}
+
+    							long ti = Util.milliTime() - mc.bowTracker.startDrawTime;
+    							translateX+=0.003*Math.sin(ti);
+    						}
+    					}
+    				}
+
+    				if(player.isSpinAttacking()) {
+    					j = 5;
+    					translateZ += -0.15f;
+    					matrixStackIn.rotate(Vector3f.ZP.rotationDegrees((-mc.tickCounter*10*j) % 360 - partialTicks*10*j));
+    					// 		rotation.multiply(Vector3f.ZP.rotationDegrees((-mc.tickCounter*10*j) % 360 - partialTicks*10*j));
+    					charging = true;
+    				}
+
+    				if(!charging) {	
+    					translateY += 0 + 0.2*gunAngle/40;
+    					rotation.multiply(Vector3f.XP.rotationDegrees((float) (gunAngle)));
+    				}
+
+    				rotation.multiply(Vector3f.XP.rotationDegrees((float) (-65)));
+
+    				translateZ +=-0.75f + prog /10 * (0.25f);
+
+    			}
+    			else if(rendertype == VivecraftItemRendering.Sword) {
+    			}
+    			else if(rendertype == VivecraftItemRendering.Tool_Rod) {
+    				translateZ += -0.15f;
+    				translateY += -0.02 + gunAngle / 40 * .1;
+    				translateX += 0.05f;
+    				rotation.multiply(Vector3f.XP.rotationDegrees((float) (40)));
+    				scale = 0.8f;
+    			}
+    			else if(rendertype == VivecraftItemRendering.Tool) {
+    				boolean climbClaws = mc.climbTracker.isClaws(stack) && mc.climbTracker.isClimbeyClimb();
+
+    				if(climbClaws){
+    					rotation.multiply(Vector3f.XP.rotationDegrees((float) ( - gunAngle)));
+
+    					scale = 0.3f;
+
+    					translateZ += 0.075f;
+    					translateY += 0.02f;
+    					translateX += 0.03f;
+
+    					if((MCOpenVR.keyClimbeyGrab.isKeyDown(ControllerType.RIGHT) && flag) || (MCOpenVR.keyClimbeyGrab.isKeyDown(ControllerType.LEFT) && !flag)) {
+    						translateZ += -0.2f;
+    					}
+    				}
+
+    				if (item instanceof ArrowItem) {
+    					prerotation = ((Vector3f.ZP.rotationDegrees((float) (-180))));
+    					rotation.multiply(Vector3f.XP.rotationDegrees((float) (-gunAngle)));
+    				}
+
+    			}
+    			else if(rendertype == VivecraftItemRendering.Telescope) {
+    				prerotation = Vector3f.XP.rotationDegrees(0);          		
+    				rotation = Vector3f.XP.rotationDegrees(0);
+    				translateZ =0;
+    				translateY =0;
+    				translateX =-0;
+    				//scale = 0.25;
+    			}
+
+    			if(player.swingingHand == handIn)
+    				this.transformFirstPersonVR(matrixStackIn, handside, swingProgress);
+
+    			this.itemRenderer.isfphand = true;
+    			
+				ItemCameraTransforms.TransformType transform = flag ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : mirror ? ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND;
+			
+				if(stack.hasTag() && stack.getTag().getInt("CustomModelData") > 0) {
+					transform = ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND;
+	    			matrixStackIn.scale(0.7f, 0.7f, 0.7f);
+				} else {
+	    			matrixStackIn.rotate(prerotation);
+	    			matrixStackIn.translate(translateX, translateY, translateZ);
+	    			matrixStackIn.rotate(rotation);
+	    			matrixStackIn.scale((float)scale, (float)scale,(float)scale);
+				}
+
+    			if(isFilledMap)  {
+    				RenderSystem.disableCull(); //dont. get. me. started.
+    				this.renderMapFirstPerson(matrixStackIn, bufferIn, combinedLightIn, stack);            		
+    			} else if (rendertype == VivecraftItemRendering.Telescope) {
+    				if(mc.currentPass != RenderPass.SCOPEL && mc.currentPass != RenderPass.SCOPER) {
+    					matrixStackIn.push();
+    					matrixStackIn.translate(-.1325f, 0.25f, 0.08f);
+    					matrixStackIn.rotate(Vector3f.XP.rotationDegrees(180));
+    					matrixStackIn.scale(.25f, 1.5f, .25f);
+    					mc.getBlockRendererDispatcher().getBlockModelRenderer().renderModelBrightnessColor(matrixStackIn.getLast(), bufferIn.getBuffer(Atlases.getSolidBlockType()), (BlockState)null, mc.getModelManager().getModel(TelescopeTracker.scopeModel), 0.5F, 0.5F, 1.0F, combinedLightIn, OverlayTexture.NO_OVERLAY);
+    					matrixStackIn.pop();
+    				}
+    				matrixStackIn.push();
+    				matrixStackIn.translate(0, 0.2501f, -0.053f);
+    				matrixStackIn.rotate(Vector3f.XP.rotationDegrees(90));
+    				matrixStackIn.rotate(Vector3f.YP.rotationDegrees(180));
+    				matrixStackIn.rotate(Vector3f.ZP.rotationDegrees(180));
+    				mc.gameRenderer.DrawScopeFB(matrixStackIn, handIn == Hand.MAIN_HAND ? 0 :1);
+    				matrixStackIn.pop();
+    			}else {
+    				this.renderItemSide(player, stack,transform, mirror, matrixStackIn, bufferIn, combinedLightIn);
+    			}
+
+    			this.itemRenderer.isfphand = false;
+
+    			matrixStackIn.pop();
+    		} //end itemstack render.
+    		matrixStackIn.pop();
+    	}
     }
 
     public void tick()
@@ -571,4 +926,120 @@
             this.equippedProgressOffHand = 0.0F;
         }
     }
+    
+    //VIVECRAFT ADDITIONS
+    public float getEquipProgress(Hand hand, float partialTicks){
+    	if(hand == Hand.MAIN_HAND)
+    		return 1.0f- (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks);
+    	else
+    		return 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks);
+    }
+
+    public boolean isInsideOpaqueBlock(Vector3d in)
+    {
+    	if (mc.world == null) return false;
+    	BlockPos bp = new BlockPos(in); 	   	
+    	if(mc.world.getBlockState(bp).isOpaqueCube(mc.world, bp)) {
+    		return true;
+    	}
+    	return false;
+    }
+
+    public float isNearOpaqueBlock(Vector3d in, double dist)
+    {
+    	if (mc.world == null) return 0;
+
+    	
+    	AxisAlignedBB eye = new AxisAlignedBB(in.subtract(dist, dist, dist), in.add(dist, dist, dist));
+   
+    	Stream<BlockPos> list = BlockPos.func_239581_a_(eye).filter((bp)-> {
+    		return mc.world.getBlockState(bp).isOpaqueCube(mc.world, bp);
+    	});
+    	
+    	if (list.count() > 0)
+    		return 1;  	
+    	
+    	return 0;
+    	
+//    	BlockPos bp = new BlockPos(in);
+//
+//    	if(mc.world.getBlockState(bp).isOpaqueCube(mc.world, bp)) {
+//    		return 1;
+//    	}
+
+//    	Vector3d pos = in.add(0, 0, 0);
+//    	float per = 0;
+//    	float buffer = .12f;	
+//    	float out; 
+//
+//    	if((pos.x - Math.floor(pos.x)) < buffer) 
+//    	{
+//    		per = (float) (pos.x - Math.floor(pos.x));
+//    		if (mc.world.getBlockState(bp.west()).isOpaqueCube(mc.world, bp.west()))
+//    			return (buffer - per) / buffer;
+//    	}
+//
+//    	if(pos.x - Math.floor(pos.x) > 1-buffer){
+//    		per = 1f - (float) (pos.x - Math.floor(pos.x));
+//    		if (mc.world.getBlockState(bp.east()).isOpaqueCube(mc.world, bp.east()))
+//    			return (buffer - per) / buffer;
+//    	}
+//
+//    	if((pos.y - Math.floor(pos.y)) < buffer) 
+//    	{
+//    		per = (float) (pos.y - Math.floor(pos.y));
+//    		if (mc.world.getBlockState(bp.down()).isOpaqueCube(mc.world, bp.down())) 
+//    			return (buffer - per) / buffer;
+//    	} 
+//
+//    	if(pos.y - Math.floor(pos.y) > 1-buffer){
+//    		per = 1f - (float) (pos.y - Math.floor(pos.y));
+//    		if (mc.world.getBlockState(bp.up()).isOpaqueCube(mc.world,bp.up()))
+//    			return (buffer - per) / buffer;
+//    	}
+//
+//    	if((pos.z - Math.floor(pos.z)) < buffer) 
+//    	{
+//    		per = (float) (pos.z - Math.floor(pos.z));
+//    		if (mc.world.getBlockState(bp.north()).isOpaqueCube(mc.world, bp.north()))
+//    			return (buffer - per) / buffer;
+//    	} 
+//
+//    	if(pos.z - Math.floor(pos.z) > 1-buffer){
+//    		per = 1f - (float) (pos.z - Math.floor(pos.z));
+//    		System.out.println(per + " " + buffer + " " + (buffer - per) / buffer);
+//    		if (mc.world.getBlockState(bp.south()).isOpaqueCube(mc.world, bp.south()))
+//    			return (buffer - per) / buffer;
+//    	}
+//
+//    	return 0;
+
+    }
+    
+    
+//    public boolean isInsideOfMaterial(Vector3d pos, Material materialIn)
+//    {
+//    	BlockPos blockpos = new BlockPos(pos);
+//    	BlockState BlockState = mc.world.getBlockState(blockpos);
+//    	BlockState BlockStateup = mc.world.getBlockState(blockpos.up());
+//
+//    	if (BlockState.getMaterial() == materialIn)
+//    	{
+//    		float f = BlockLiquid.getLiquidHeightPercent(BlockState.getBlock().getMetaFromState(BlockState)) -0.11111111F;;
+//    		if(BlockStateup.getMaterial() != materialIn && materialIn instanceof MaterialLiquid) f+=0.09F;
+//    		
+//    		//float f1 = (float)(blockpos.getY() + 1) - f;
+//    		boolean flag = (pos.y-blockpos.getY()) < (1-f);
+//    		return flag;
+//    	}
+//    	else
+//    	{
+//    		return false;
+//    	}
+//   }
+    //
+    
+    
+
 }
+

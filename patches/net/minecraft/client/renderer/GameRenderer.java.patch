--- a/net/minecraft/client/renderer/GameRenderer.java
+++ b/net/minecraft/client/renderer/GameRenderer.java
@@ -4,27 +4,44 @@
 import com.mojang.blaze3d.matrix.MatrixStack;
 import com.mojang.blaze3d.platform.GLX;
 import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.GlStateManager.Color;
+import com.mojang.blaze3d.platform.GlStateManager.DestFactor;
+import com.mojang.blaze3d.platform.GlStateManager.SourceFactor;
 import com.mojang.blaze3d.systems.RenderSystem;
 import java.io.IOException;
+import java.nio.FloatBuffer;
+import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Locale;
 import java.util.Random;
+import java.util.function.Function;
 import javax.annotation.Nullable;
+
 import net.minecraft.block.BlockState;
 import net.minecraft.client.MainWindow;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.player.AbstractClientPlayerEntity;
+import net.minecraft.client.entity.player.ClientPlayerEntity;
 import net.minecraft.client.gui.MapItemRenderer;
 import net.minecraft.client.gui.ResourceLoadProgressGui;
 import net.minecraft.client.gui.screen.ChatScreen;
 import net.minecraft.client.gui.screen.DownloadTerrainScreen;
 import net.minecraft.client.gui.screen.MainMenuScreen;
+import net.minecraft.client.gui.screen.Screen;
+import net.minecraft.client.gui.screen.WinGameScreen;
+import net.minecraft.client.main.Main;
+import net.minecraft.client.renderer.IRenderTypeBuffer.Impl;
+import net.minecraft.client.renderer.model.BakedQuad;
 import net.minecraft.client.renderer.model.ItemCameraTransforms;
+import net.minecraft.client.renderer.model.ModelBakery;
+import net.minecraft.client.renderer.model.ModelResourceLocation;
 import net.minecraft.client.renderer.texture.NativeImage;
 import net.minecraft.client.renderer.texture.OverlayTexture;
+import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.resources.I18n;
+import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
@@ -38,13 +55,19 @@
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.entity.projectile.ProjectileHelper;
 import net.minecraft.fluid.FluidState;
+import net.minecraft.inventory.container.PlayerContainer;
 import net.minecraft.item.ItemStack;
+import net.minecraft.item.Items;
+import net.minecraft.potion.Effect;
 import net.minecraft.potion.Effects;
 import net.minecraft.resources.IResourceManager;
 import net.minecraft.resources.IResourceManagerReloadListener;
+import net.minecraft.resources.SimpleResource;
 import net.minecraft.server.integrated.IntegratedServer;
+import net.minecraft.tags.FluidTags;
 import net.minecraft.util.CachedBlockInfo;
 import net.minecraft.util.Direction;
+import net.minecraft.util.Hand;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.ScreenShotHelper;
 import net.minecraft.util.Util;
@@ -54,9 +77,11 @@
 import net.minecraft.util.math.EntityRayTraceResult;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.math.vector.Matrix4f;
 import net.minecraft.util.math.vector.Vector3d;
 import net.minecraft.util.math.vector.Vector3f;
+import net.minecraft.util.math.vector.Vector3i;
 import net.minecraft.util.text.StringTextComponent;
 import net.minecraft.util.text.Style;
 import net.minecraft.util.text.event.ClickEvent;
@@ -68,15 +93,45 @@
 import net.optifine.GlErrors;
 import net.optifine.Lagometer;
 import net.optifine.RandomEntities;
+import net.optifine.SmartAnimations;
 import net.optifine.gui.GuiChatOF;
+import net.optifine.model.QuadBounds;
 import net.optifine.reflect.Reflector;
 import net.optifine.reflect.ReflectorResolver;
+import net.optifine.render.RenderTypes;
+import net.optifine.shaders.Program;
 import net.optifine.shaders.Shaders;
 import net.optifine.shaders.ShadersRender;
 import net.optifine.util.MemoryMonitor;
 import net.optifine.util.TimedEvent;
+import org.apache.commons.lang3.tuple.Triple;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.EXTTextureFilterAnisotropic;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
+import org.lwjgl.opengl.GL14;
+import org.lwjgl.opengl.GL30;
+import org.vivecraft.api.NetworkHelper;
+import org.vivecraft.api.VRData;
+import org.vivecraft.api.VRData.VRDevicePose;
+import org.vivecraft.control.ControllerType;
+import org.vivecraft.gameplay.OpenVRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.KeyboardHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.BowTracker;
+import org.vivecraft.gameplay.trackers.CameraTracker;
+import org.vivecraft.gameplay.trackers.TelescopeTracker;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.reflection.MCReflection;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.VRActiveRenderInfo;
+import org.vivecraft.render.VRWidgetHelper;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.utils.Utils;
 
 public class GameRenderer implements IResourceManagerReloadListener, AutoCloseable
 {
@@ -115,10 +170,12 @@
     public static final int SHADER_COUNT = SHADERS_TEXTURES.length;
     private int shaderIndex = SHADER_COUNT;
     private boolean useShader;
-    private final ActiveRenderInfo activeRender = new ActiveRenderInfo();
+    //Vivecraft
+    private final ActiveRenderInfo activeRender = new VRActiveRenderInfo();
+    //
     private boolean initialized = false;
     private World updatedWorld = null;
-    private float clipDistance = 128.0F;
+    public float clipDistance = 128.0F;
     private long lastServerTime = 0L;
     private int lastServerTicks = 0;
     private int serverWaitTime = 0;
@@ -127,6 +184,43 @@
     private float avgServerTickDiff = 0.0F;
     private ShaderGroup[] fxaaShaders = new ShaderGroup[10];
     private boolean guiLoadingVisible = false;
+    /** MINECRIFT */
+    public float minClipDistance = 0.02f;
+    public Vector3d crossVec;
+    private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+    
+    public Matrix4f thirdPassProjectionMatrix = new Matrix4f();
+	
+    public boolean menuWorldFastTime;
+    public boolean inwater, wasinwater, inportal, onfire;
+    public float inBlock = 0;
+    private boolean always_true = true;
+
+    //For RenderViewEntity Overrides
+	public double rveX, rveY, rveZ, rvelastX, rvelastY, rvelastZ, rveprevX, rveprevY, rveprevZ;
+	public float rveyaw;
+	public float rvepitch;
+	private float rvelastyaw;
+	private float rvelastpitch;
+	private float rveHeight;
+	private boolean cached;
+	
+	//For Poly Rendering
+  	private int polyblendsrca, polyblenddsta;
+  	private int polyblendsrcrgb, polyblenddstrgb;
+
+  	private Program prog;
+  	private boolean polyblend, polytex, polylight, polycull;
+
+  	// models
+    public static final ModelResourceLocation thirdPersonCameraModel = new ModelResourceLocation("vivecraft:camcorder");
+    public static final ModelResourceLocation thirdPersonCameraDisplayModel = new ModelResourceLocation("vivecraft:camcorder_display");
+  	
+  	//Teleporter
+  	Vector3i tpUnlimitedColor = new Vector3i((byte)173, (byte)216, (byte)230);
+  	Vector3i tpLimitedColor = new Vector3i((byte)205, (byte)169, (byte)205);
+  	Vector3i tpInvalidColor = new Vector3i((byte)83, (byte)83, (byte)83);
+    /** END MINECRIFT */
 
     public GameRenderer(Minecraft mcIn, IResourceManager resourceManagerIn, RenderTypeBuffers renderTypeBuffersIn)
     {
@@ -137,6 +231,12 @@
         this.lightmapTexture = new LightTexture(this, mcIn);
         this.renderTypeBuffers = renderTypeBuffersIn;
         this.shaderGroup = null;
+        //Vivecraft
+        if(mc.gameRenderer!=null){
+        	System.out.println("**********NEW GAME RENDERER ***********");
+        	java.lang.Thread.dumpStack();
+        }
+        //
     }
 
     public void close()
@@ -200,7 +300,7 @@
             }
 
             try
-            {
+            {         
                 this.shaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, this.mc.getFramebuffer(), resourceLocationIn);
                 this.shaderGroup.createBindFramebuffers(this.mc.getMainWindow().getFramebufferWidth(), this.mc.getMainWindow().getFramebufferHeight());
                 this.useShader = true;
@@ -300,13 +400,18 @@
     {
         Entity entity = this.mc.getRenderViewEntity();
 
-        if (entity != null && this.mc.world != null)
+        if (entity != null && this.mc.world != null && mc.vrPlayer.vrdata_world_render != null)
         {
             this.mc.getProfiler().startSection("pick");
             this.mc.pointedEntity = null;
             double d0 = (double)this.mc.playerController.getBlockReachDistance();
-            this.mc.objectMouseOver = entity.pick(d0, partialTicks, false);
-            Vector3d vector3d = entity.getEyePosition(partialTicks);
+            //Vivecraft override raytrace
+            this.mc.objectMouseOver = mc.vrPlayer.rayTraceBlocksVR(mc.vrPlayer.vrdata_world_render, 0 ,d0, false);
+            this.crossVec = mc.vrPlayer.AimedPointAtDistance(mc.vrPlayer.vrdata_world_render, 0, d0);
+            Vector3d vector3d = mc.vrPlayer.vrdata_world_render.getController(0).getPosition(); // entity.getEyePosition(partialTicks);
+            //TODO: Test how to handle vector3d for best server-side compatibility
+            //this.mc.objectMouseOver = entity.pick(d0, partialTicks, false);
+            //Vector3d vector3d = entity.getEyePosition(partialTicks);
             boolean flag = false;
             int i = 3;
             double d1 = d0;
@@ -332,14 +437,16 @@
             {
                 d1 = this.mc.objectMouseOver.getHitVec().squareDistanceTo(vector3d);
             }
-
-            Vector3d vector3d1 = entity.getLook(1.0F);
+            //Vivecraft
+            Vector3d vector3d1 =  mc.vrPlayer.vrdata_world_render.getController(0).getDirection(); // entity.getLook(1.0F);
+            //
             Vector3d vector3d2 = vector3d.add(vector3d1.x * d0, vector3d1.y * d0, vector3d1.z * d0);
             float f = 1.0F;
             AxisAlignedBB axisalignedbb = entity.getBoundingBox().expand(vector3d1.scale(d0)).grow(1.0D, 1.0D, 1.0D);
-            EntityRayTraceResult entityraytraceresult = ProjectileHelper.rayTraceEntities(entity, vector3d, vector3d2, axisalignedbb, (p_lambda$getMouseOver$0_0_) ->
+            EntityRayTraceResult entityraytraceresult = ProjectileHelper.rayTraceEntities(entity, vector3d, vector3d2, axisalignedbb, (e) ->
             {
-                return !p_lambda$getMouseOver$0_0_.isSpectator() && p_lambda$getMouseOver$0_0_.canBeCollidedWith();
+            	//Vivecraft add riding check in case your hand is somewhere inappropriate.
+                return !e.isSpectator() && e.canBeCollidedWith() && !(e == mc.getRenderViewEntity().getRidingEntity());
             }, d1);
 
             if (entityraytraceresult != null)
@@ -393,6 +500,10 @@
 
     private double getFOVModifier(ActiveRenderInfo activeRenderInfoIn, float partialTicks, boolean useFOVSetting)
     {
+        // Vivecraft: using this on the main menu
+        if (mc.world == null)
+            return this.mc.gameSettings.fov;
+
         if (this.debugView)
         {
             return 90.0D;
@@ -497,7 +608,9 @@
             matrixStackIn.rotate(Vector3f.XP.rotationDegrees(Math.abs(MathHelper.cos(f1 * (float)Math.PI - 0.2F) * f2) * 5.0F));
         }
     }
+      
 
+    
     private void renderHand(MatrixStack matrixStackIn, ActiveRenderInfo activeRenderInfoIn, float partialTicks)
     {
         this.renderHand(matrixStackIn, activeRenderInfoIn, partialTicks, true, true, false);
@@ -592,13 +705,34 @@
             this.clipDistance = 173.0F;
         }
 
-        if (this.cameraZoom != 1.0F)
-        {
-            matrixstack.translate((double)this.cameraYaw, (double)(-this.cameraPitch), 0.0D);
-            matrixstack.scale(this.cameraZoom, this.cameraZoom, 1.0F);
-        }
-
-        matrixstack.getLast().getMatrix().mul(Matrix4f.perspective(this.getFOVModifier(activeRenderInfoIn, partialTicks, useFovSetting), (float)this.mc.getMainWindow().getFramebufferWidth() / (float)this.mc.getMainWindow().getFramebufferHeight(), 0.05F, this.clipDistance));
+    	//Vivecraf get projection based on camera pass
+    	if (mc.currentPass == RenderPass.LEFT || mc.currentPass == RenderPass.RIGHT ) {
+    		
+    		int i = mc.currentPass.ordinal();   
+    		if (i > 1) i = 0;
+    		matrixstack.getLast().getMatrix().mul(mc.stereoProvider.eyeproj[i]);  		
+    		
+    	} else if(mc.currentPass ==RenderPass.THIRD) {
+    		
+    		if (this.mc.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY)
+    			matrixstack.getLast().getMatrix().mul(Matrix4f.perspective(this.mc.vrSettings.mixedRealityFov, this.mc.vrSettings.mixedRealityAspectRatio , minClipDistance, this.clipDistance * 4));
+    		else
+    			matrixstack.getLast().getMatrix().mul(Matrix4f.perspective(this.mc.vrSettings.mixedRealityFov, (float)this.mc.getMainWindow().getWidth() / (float)this.mc.getMainWindow().getHeight(), minClipDistance, this.clipDistance * 4));
+    		
+    		this.thirdPassProjectionMatrix = new Matrix4f(matrixstack.getLast().getMatrix());
+    	} else if(mc.currentPass ==RenderPass.SCOPEL || mc.currentPass == RenderPass.SCOPER) {
+	        matrixstack.getLast().getMatrix().mul(Matrix4f.perspective(70f/8f, 1, 0.05F, this.clipDistance * 4));
+        } else if (mc.currentPass == RenderPass.CAMERA) {
+            matrixstack.getLast().getMatrix().mul(Matrix4f.perspective(mc.vrSettings.handCameraFov, (float)mc.stereoProvider.cameraFramebuffer.framebufferWidth / (float)mc.stereoProvider.cameraFramebuffer.framebufferHeight, minClipDistance, this.clipDistance * 4));
+    	}else {
+    		//Vanilla
+	        if (this.cameraZoom != 1.0F)
+	        {
+	            matrixstack.translate((double)this.cameraYaw, (double)(-this.cameraPitch), 0.0D);
+	            matrixstack.scale(this.cameraZoom, this.cameraZoom, 1.0F);
+	        }
+	        matrixstack.getLast().getMatrix().mul(Matrix4f.perspective(this.getFOVModifier(activeRenderInfoIn, partialTicks, useFovSetting), (float)this.mc.getMainWindow().getWidth() / (float)this.mc.getMainWindow().getHeight(), 0.05F, this.clipDistance * 4));
+    	}
         return matrixstack.getLast().getMatrix();
     }
 
@@ -610,10 +744,12 @@
 
     public void updateCameraAndRender(float partialTicks, long nanoTime, boolean renderWorldIn)
     {
+
+    	if(mc.currentPass == RenderPass.LEFT) { //Vivecraft once per pass
         this.frameInit();
 
-        if (!this.mc.isGameFocused() && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !this.mc.mouseHelper.isRightDown()))
-        {
+    		if (!always_true && !this.mc.isGameFocused() && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !this.mc.mouseHelper.isRightDown()))
+    		{//never pause on focus loss.
             if (Util.milliTime() - this.prevFrameTime > 500L)
             {
                 this.mc.displayInGameMenu(false);
@@ -623,16 +759,23 @@
         {
             this.prevFrameTime = Util.milliTime();
         }
+    	}
 
         if (!this.mc.skipRenderWorld)
         {
             int i = (int)(this.mc.mouseHelper.getMouseX() * (double)this.mc.getMainWindow().getScaledWidth() / (double)this.mc.getMainWindow().getWidth());
             int j = (int)(this.mc.mouseHelper.getMouseY() * (double)this.mc.getMainWindow().getScaledHeight() / (double)this.mc.getMainWindow().getHeight());
 
-            if (renderWorldIn && this.mc.world != null && !Config.isReloadingResources())
+    		RenderSystem.viewport(0, 0, this.mc.getMainWindow().getFramebufferWidth(), this.mc.getMainWindow().getFramebufferHeight());
+
+    		if (renderWorldIn && !(isInMenuRoom()) && this.mc.world != null && !Config.isReloadingResources())
             {
+    			//This is the viewmodel matrix.
+    			MatrixStack matrixstack = new MatrixStack();
                 this.mc.getProfiler().startSection("level");
-                this.renderWorld(partialTicks, nanoTime, new MatrixStack());
+    			this.renderWorld(partialTicks, nanoTime, matrixstack);
+    			if(mc.currentPass != RenderPass.THIRD && mc.currentPass != RenderPass.CAMERA)
+    				renderFaceOverlay(partialTicks);
 
                 if (this.mc.isSingleplayer() && this.timeWorldIcon < Util.milliTime() - 1000L)
                 {
@@ -644,9 +787,10 @@
                     }
                 }
 
+    			//note calling this breaks the projection matrix.
                 this.mc.worldRenderer.renderEntityOutlineFramebuffer();
 
-                if (this.shaderGroup != null && this.useShader)
+    			if (this.shaderGroup != null && this.useShader && mc.currentPass != RenderPass.THIRD )
                 {
                     RenderSystem.disableBlend();
                     RenderSystem.disableDepthTest();
@@ -662,140 +806,35 @@
 
                 this.mc.getFramebuffer().bindFramebuffer(true);
             }
-            else
-            {
-                RenderSystem.viewport(0, 0, this.mc.getMainWindow().getFramebufferWidth(), this.mc.getMainWindow().getFramebufferHeight());
-            }
-
-            MainWindow mainwindow = this.mc.getMainWindow();
-            RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
-            RenderSystem.matrixMode(5889);
-            RenderSystem.loadIdentity();
-            RenderSystem.ortho(0.0D, (double)mainwindow.getFramebufferWidth() / mainwindow.getGuiScaleFactor(), (double)mainwindow.getFramebufferHeight() / mainwindow.getGuiScaleFactor(), 0.0D, 1000.0D, 3000.0D);
-            RenderSystem.matrixMode(5888);
-            RenderSystem.loadIdentity();
-            RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
-            RenderHelper.setupGui3DDiffuseLighting();
-            MatrixStack matrixstack = new MatrixStack();
-
-            if (this.lightmapTexture.isCustom())
-            {
-                this.lightmapTexture.setAllowed(false);
-            }
-
-            if (renderWorldIn && this.mc.world != null)
-            {
-                this.mc.getProfiler().endStartSection("gui");
-
-                if (this.mc.player != null)
-                {
-                    float f = MathHelper.lerp(partialTicks, this.mc.player.prevTimeInPortal, this.mc.player.timeInPortal);
-
-                    if (f > 0.0F && this.mc.player.isPotionActive(Effects.NAUSEA) && this.mc.gameSettings.field_243226_aM < 1.0F)
-                    {
-                        this.func_243497_c(f * (1.0F - this.mc.gameSettings.field_243226_aM));
-                    }
-                }
-
-                if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
-                {
-                    RenderSystem.defaultAlphaFunc();
-                    this.renderItemActivation(this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), partialTicks);
-                    this.mc.ingameGUI.renderIngameGui(matrixstack, partialTicks);
-
-                    if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo)
-                    {
-                        Config.drawFps(matrixstack);
+    		else {
+    			this.mc.getProfiler().startSection("MainMenu");
+    			GL11.glDisable(GL11.GL_STENCIL_TEST);
+
+    			this.resetProjectionMatrix(this.getProjectionMatrix(activeRender, partialTicks, true));
+
+    			RenderSystem.pushMatrix();
+    			GL11.glLoadIdentity();
+    			applyVRModelViewLegacy(this.mc.currentPass);
+    			removeStereoLegacy(mc.currentPass);
+
+    			renderGuiLayer(partialTicks, true);
+
+    			if(KeyboardHandler.Showing) {
+    				if (mc.vrSettings.physicalKeyboard)
+    					renderPhysicalKeyboard(partialTicks);
+    				else
+    					render2D(partialTicks, KeyboardHandler.Framebuffer, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room, false);
                     }
 
-                    if (this.mc.gameSettings.showDebugInfo)
-                    {
-                        Lagometer.showLagometer(matrixstack, (int)this.mc.getMainWindow().getGuiScaleFactor());
+    			if((mc.currentPass != RenderPass.THIRD || mc.vrSettings.mixedRealityRenderHands) && mc.currentPass != RenderPass.CAMERA){
+    				renderVRHands(partialTicks, true, true, true, true);
                     }
 
-                    RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+    			RenderSystem.popMatrix();
                 }
 
                 this.mc.getProfiler().endSection();
-            }
-
-            if (this.guiLoadingVisible != (this.mc.loadingGui != null))
-            {
-                if (this.mc.loadingGui != null)
-                {
-                    ResourceLoadProgressGui.loadLogoTexture(this.mc);
 
-                    if (this.mc.loadingGui instanceof ResourceLoadProgressGui)
-                    {
-                        ResourceLoadProgressGui resourceloadprogressgui = (ResourceLoadProgressGui)this.mc.loadingGui;
-                        resourceloadprogressgui.update();
-                    }
-                }
-
-                this.guiLoadingVisible = this.mc.loadingGui != null;
-            }
-
-            if (this.mc.loadingGui != null)
-            {
-                try
-                {
-                    this.mc.loadingGui.render(matrixstack, i, j, this.mc.getTickLength());
-                }
-                catch (Throwable throwable1)
-                {
-                    CrashReport crashreport = CrashReport.makeCrashReport(throwable1, "Rendering overlay");
-                    CrashReportCategory crashreportcategory = crashreport.makeCategory("Overlay render details");
-                    crashreportcategory.addDetail("Overlay name", () ->
-                    {
-                        return this.mc.loadingGui.getClass().getCanonicalName();
-                    });
-                    throw new ReportedException(crashreport);
-                }
-            }
-            else if (this.mc.currentScreen != null)
-            {
-                try
-                {
-                    if (Reflector.ForgeHooksClient_drawScreen.exists())
-                    {
-                        Reflector.callVoid(Reflector.ForgeHooksClient_drawScreen, this.mc.currentScreen, matrixstack, i, j, this.mc.getTickLength());
-                    }
-                    else
-                    {
-                        this.mc.currentScreen.render(matrixstack, i, j, this.mc.getTickLength());
-                    }
-                }
-                catch (Throwable throwable1)
-                {
-                    CrashReport crashreport1 = CrashReport.makeCrashReport(throwable1, "Rendering screen");
-                    CrashReportCategory crashreportcategory1 = crashreport1.makeCategory("Screen render details");
-                    crashreportcategory1.addDetail("Screen name", () ->
-                    {
-                        return this.mc.currentScreen.getClass().getCanonicalName();
-                    });
-                    crashreportcategory1.addDetail("Mouse location", () ->
-                    {
-                        return String.format(Locale.ROOT, "Scaled: (%d, %d). Absolute: (%f, %f)", i, j, this.mc.mouseHelper.getMouseX(), this.mc.mouseHelper.getMouseY());
-                    });
-                    crashreportcategory1.addDetail("Screen size", () ->
-                    {
-                        return String.format(Locale.ROOT, "Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %f", this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), this.mc.getMainWindow().getFramebufferWidth(), this.mc.getMainWindow().getFramebufferHeight(), this.mc.getMainWindow().getGuiScaleFactor());
-                    });
-                    throw new ReportedException(crashreport1);
-                }
-            }
-
-            this.lightmapTexture.setAllowed(true);
-        }
-
-        this.frameFinish();
-        this.waitForServerThread();
-        MemoryMonitor.update();
-        Lagometer.updateLagometer();
-
-        if (this.mc.gameSettings.ofProfiler)
-        {
-            this.mc.gameSettings.showDebugProfilerChart = true;
         }
     }
 
@@ -839,7 +878,10 @@
 
     private boolean isDrawBlockOutline()
     {
-        if (!this.drawBlockOutline)
+    	if (!this.drawBlockOutline || 
+    			(mc.gameSettings.hideGUI && mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_HUD) ||
+    			mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_NEVER ||
+    			mc.teleportTracker.isAiming())
         {
             return false;
         }
@@ -874,17 +916,36 @@
         }
     }
 
-    public void renderWorld(float partialTicks, long finishTimeNano, MatrixStack matrixStackIn)
+    public void renderWorld(float partialTicks, long finishTimeNano, MatrixStack viewModel)
     {
-        this.lightmapTexture.updateLightmap(partialTicks);
+    	if(mc.currentPass == RenderPass.LEFT) {
+    		this.lightmapTexture.updateLightmap(partialTicks);
+    	}
 
         if (this.mc.getRenderViewEntity() == null)
         {
             this.mc.setRenderViewEntity(this.mc.player);
         }
-
-        this.getMouseOver(partialTicks);
-
+    	
+     	if(mc.currentPass == RenderPass.LEFT) {
+	    	//
+	        this.getMouseOver(partialTicks);
+	  		if (this.mc.objectMouseOver != null && mc.objectMouseOver.getType() != Type.MISS)
+	  			crossVec = this.mc.objectMouseOver.getHitVec();
+	        
+	    		if(mc.currentScreen == null ){
+	    			// VIVE START - teleport movement
+	    			mc.teleportTracker.updateTeleportDestinations(this, mc, mc.player);
+	    			// VIVE END - teleport movement
+	    		}	
+     	}
+     	
+    	//Vivecraft
+    	cacheRVEPos((LivingEntity) mc.getRenderViewEntity());	
+    	setupRVE();
+    	
+    	setupOverlayStatus(partialTicks); 
+    	
         if (Config.isShaders())
         {
             Shaders.beginRender(this.mc, this.activeRender, partialTicks, finishTimeNano);
@@ -897,108 +958,71 @@
         {
             Shaders.beginRenderPass(partialTicks, finishTimeNano);
         }
-
+        this.drawBlockOutline = shouldRenderCrosshair();
         boolean flag1 = this.isDrawBlockOutline();
         this.mc.getProfiler().endStartSection("camera");
         ActiveRenderInfo activerenderinfo = this.activeRender;
-        this.farPlaneDistance = (float)(this.mc.gameSettings.renderDistanceChunks * 16);
-
-        if (Config.isFogFancy())
-        {
-            this.farPlaneDistance *= 0.95F;
-        }
-
-        if (Config.isFogFast())
-        {
-            this.farPlaneDistance *= 0.83F;
-        }
-
-        MatrixStack matrixstack = new MatrixStack();
-        matrixstack.getLast().getMatrix().mul(this.getProjectionMatrix(activerenderinfo, partialTicks, true));
-        MatrixStack matrixstack1 = matrixstack;
-
-        if (Shaders.isEffectsModelView())
-        {
-            matrixstack = matrixStackIn;
-        }
-
-        this.hurtCameraEffect(matrixstack, partialTicks);
+        setupClipPlanes();
+     
+        //no hurt  this.hurtCameraEffect(temp, partialTicks);
 
         if (this.mc.gameSettings.viewBobbing)
         {
-            this.applyBobbing(matrixstack, partialTicks);
+         //no bob   this.applyBobbing(temp, partialTicks);
         }
 
-        float f = MathHelper.lerp(partialTicks, this.mc.player.prevTimeInPortal, this.mc.player.timeInPortal) * this.mc.gameSettings.field_243226_aM * this.mc.gameSettings.field_243226_aM;
+        float f = MathHelper.lerp(partialTicks, this.mc.player.prevTimeInPortal, this.mc.player.timeInPortal);
 
         if (f > 0.0F)
         {
             int i = this.mc.player.isPotionActive(Effects.NAUSEA) ? 7 : 20;
             float f1 = 5.0F / (f * f + 5.0F) - f * 0.04F;
             f1 = f1 * f1;
+            //Vivecraft tone that shit down
+            i = i / 5;
+            f1 = 1.1f;
+            //
             Vector3f vector3f = new Vector3f(0.0F, MathHelper.SQRT_2 / 2.0F, MathHelper.SQRT_2 / 2.0F);
-            matrixstack.rotate(vector3f.rotationDegrees(((float)this.rendererUpdateCount + partialTicks) * (float)i));
-            matrixstack.scale(1.0F / f1, 1.0F, 1.0F);
+            viewModel.rotate(vector3f.rotationDegrees(((float)this.rendererUpdateCount + partialTicks) * (float)i));
+            viewModel.scale(1.0F / f1, 1.0F, 1.0F);
             float f2 = -((float)this.rendererUpdateCount + partialTicks) * (float)i;
-            matrixstack.rotate(vector3f.rotationDegrees(f2));
+            viewModel.rotate(vector3f.rotationDegrees(f2));
         }
 
-        if (Shaders.isEffectsModelView())
-        {
-            matrixstack = matrixstack1;
-        }
+        MatrixStack projectionBuilder = new MatrixStack();
+        projectionBuilder.getLast().getMatrix().mul(this.getProjectionMatrix(activerenderinfo, partialTicks, true));
+        Matrix4f projection = projectionBuilder.getLast().getMatrix();                 
+        this.resetProjectionMatrix(projection);
+        RenderSystem.loadIdentity();
 
-        Matrix4f matrix4f = matrixstack.getLast().getMatrix();
-        this.resetProjectionMatrix(matrix4f);
         activerenderinfo.update(this.mc.world, (Entity)(this.mc.getRenderViewEntity() == null ? this.mc.player : this.mc.getRenderViewEntity()), !this.mc.gameSettings.func_243230_g().func_243192_a(), this.mc.gameSettings.func_243230_g().func_243193_b(), partialTicks);
 
-        if (Reflector.ForgeHooksClient_onCameraSetup.exists())
-        {
-            Object object = Reflector.ForgeHooksClient_onCameraSetup.call(this, activerenderinfo, partialTicks);
-            float f4 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getYaw);
-            float f5 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getPitch);
-            float f3 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getRoll);
-            activerenderinfo.setAnglesInternal(f4, f5);
-            matrixStackIn.rotate(Vector3f.ZP.rotationDegrees(f3));
-        }
+        applyVRModelView(mc.currentPass, viewModel); //this is just rotation.
+     //   applystereo(mc.currentPass, viewModel);
 
-        matrixStackIn.rotate(Vector3f.XP.rotationDegrees(activerenderinfo.getPitch()));
-        matrixStackIn.rotate(Vector3f.YP.rotationDegrees(activerenderinfo.getYaw() + 180.0F));
-        this.mc.worldRenderer.updateCameraAndRender(matrixStackIn, partialTicks, finishTimeNano, flag1, activerenderinfo, this, this.lightmapTexture, matrix4f);
+        this.mc.worldRenderer.updateCameraAndRender(viewModel, partialTicks, finishTimeNano, flag1, activerenderinfo, this, this.lightmapTexture, projection);
 
         if (Reflector.ForgeHooksClient_dispatchRenderLast.exists())
         {
             this.mc.getProfiler().endStartSection("forge_render_last");
-            Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, this.mc.worldRenderer, matrixStackIn, partialTicks, matrix4f, finishTimeNano);
+            Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, this.mc.worldRenderer, viewModel, partialTicks, projection, finishTimeNano);
         }
 
-        this.mc.getProfiler().endStartSection("hand");
+    	boolean forgeHands = false;
+    	GL11.glDisable(GL11.GL_STENCIL_TEST);
 
-        if (this.renderHand && !Shaders.isShadowPass)
+        this.mc.getProfiler().endStartSection("ShadersEnd");
+        if ( flag && !forgeHands && this.renderHand && !Shaders.isShadowPass)
         {
-            if (flag)
-            {
-                ShadersRender.renderHand1(this, matrixStackIn, activerenderinfo, partialTicks);
                 Shaders.renderCompositeFinal();
             }
 
-            RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
-
-            if (flag)
-            {
-                ShadersRender.renderFPOverlay(this, matrixStackIn, activerenderinfo, partialTicks);
-            }
-            else
-            {
-                this.renderHand(matrixStackIn, activerenderinfo, partialTicks);
-            }
-        }
-
         if (flag)
         {
             Shaders.endRender();
         }
 
+        restoreRVEPos((LivingEntity) mc.getRenderViewEntity()); //unhack the RVE position.
         this.mc.getProfiler().endSection();
     }
 
@@ -1110,8 +1134,6 @@
 
         if (!this.initialized)
         {
-            ReflectorResolver.resolve();
-
             if (Config.getBitsOs() == 64 && Config.getBitsJre() == 32)
             {
                 Config.setNotify64BitJava(true);
@@ -1280,25 +1302,30 @@
             float f6 = this.itemActivationOffY * (float)(heightScaled / 4);
             RenderSystem.enableAlphaTest();
             RenderSystem.pushMatrix();
-            RenderSystem.pushLightingAttributes();
-            RenderSystem.enableDepthTest();
-            RenderSystem.disableCull();
-            MatrixStack matrixstack = new MatrixStack();
-            matrixstack.push();
-            matrixstack.translate((double)((float)(widthsp / 2) + f5 * MathHelper.abs(MathHelper.sin(f4 * 2.0F))), (double)((float)(heightScaled / 2) + f6 * MathHelper.abs(MathHelper.sin(f4 * 2.0F))), -50.0D);
-            float f7 = 50.0F + 175.0F * MathHelper.sin(f4);
-            matrixstack.scale(f7, -f7, f7);
-            matrixstack.rotate(Vector3f.YP.rotationDegrees(900.0F * MathHelper.abs(MathHelper.sin(f4))));
-            matrixstack.rotate(Vector3f.XP.rotationDegrees(6.0F * MathHelper.cos(f * 8.0F)));
-            matrixstack.rotate(Vector3f.ZP.rotationDegrees(6.0F * MathHelper.cos(f * 8.0F)));
-            IRenderTypeBuffer.Impl irendertypebuffer$impl = this.renderTypeBuffers.getBufferSource();
-            this.mc.getItemRenderer().renderItem(this.itemActivationItem, ItemCameraTransforms.TransformType.FIXED, 15728880, OverlayTexture.NO_OVERLAY, matrixstack, irendertypebuffer$impl);
-            matrixstack.pop();
-            irendertypebuffer$impl.finish();
-            RenderSystem.popAttributes();
+	            RenderSystem.pushLightingAttributes();
+		            RenderSystem.enableDepthTest();
+		            RenderSystem.depthFunc(GL11.GL_ALWAYS);
+		            RenderSystem.disableCull();
+		            MatrixStack matrixstack = new MatrixStack();
+		            matrixstack.push();
+		            //matrixstack.translate((double)((float)(widthsp / 2) + f5 * MathHelper.abs(MathHelper.sin(f4 * 2.0F))), (double)((float)(heightScaled / 2) + f6 * MathHelper.abs(MathHelper.sin(f4 * 2.0F))), -50.0D);
+		            //edit translate
+		            matrixstack.translate(0, 0, -1);
+		            //edit scale
+		            float f7 = 0.0F + -1.2f * MathHelper.sin(f4);
+		            matrixstack.scale(f7, -f7, f7);
+		            matrixstack.rotate(Vector3f.YP.rotationDegrees(900.0F * MathHelper.abs(MathHelper.sin(f4))));
+		            matrixstack.rotate(Vector3f.XP.rotationDegrees(6.0F * MathHelper.cos(f * 8.0F)));
+		            matrixstack.rotate(Vector3f.ZP.rotationDegrees(6.0F * MathHelper.cos(f * 8.0F)));
+		            IRenderTypeBuffer.Impl irendertypebuffer$impl = this.renderTypeBuffers.getBufferSource();
+		            this.mc.getItemRenderer().renderItem(this.itemActivationItem, ItemCameraTransforms.TransformType.FIXED, 15728880, OverlayTexture.NO_OVERLAY, matrixstack, irendertypebuffer$impl);
+		            matrixstack.pop();
+		            irendertypebuffer$impl.finish();
+	            RenderSystem.popAttributes();
             RenderSystem.popMatrix();
             RenderSystem.enableCull();
             RenderSystem.disableDepthTest();
+            RenderSystem.depthFunc(GL11.GL_LEQUAL);
         }
     }
 
@@ -1359,4 +1386,2196 @@
     {
         return this.overlayTexture;
     }
+  //VIVECRAFT ADDITIONS *********************************************************
+
+  	public void drawSizedQuad(float displayWidth, float displayHeight, float size, GlStateManager.Color color)
+  	{
+  		float aspect = displayHeight / displayWidth;
+
+  		Tessellator t = Tessellator.getInstance();
+        BufferBuilder b = t.getBuffer();
+        b.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
+
+        b.pos(-(size / 2f), -(size * aspect) / 2f, 0.0f).tex(0.0f, 0.0f).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+        b.pos(size / 2f, -(size * aspect) / 2f, 0.0f).tex(1.0f, 0.0f).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+        b.pos(size / 2f, (size * aspect) / 2f, 0.0f).tex(1.0f, 1.0f).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+        b.pos(-(size / 2f), (size * aspect) / 2f, 0.0f).tex(0.0f, 1.0f).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+
+        t.draw();
+  	}
+
+    public void drawSizedQuad(float displayWidth, float displayHeight, float size)
+    {
+        drawSizedQuad(displayWidth, displayHeight, size, new GlStateManager.Color());
+    }
+
+    public void drawSizedQuadWithLightmap(float displayWidth, float displayHeight, float size, int lighti, GlStateManager.Color color)
+    {
+        float aspect = displayHeight / displayWidth;
+
+        lightmapTexture.enableLightmap();
+
+        Tessellator t = Tessellator.getInstance();
+        BufferBuilder b = t.getBuffer();
+        b.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_LMAP_COLOR_NORMAL);
+
+        b.pos(-(size / 2f), -(size * aspect) / 2f, 0.0f).tex(0.0f, 0.0f).lightmap(lighti).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+        b.pos(size / 2f, -(size * aspect) / 2f, 0.0f).tex(1.0f, 0.0f).lightmap(lighti).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+        b.pos(size / 2f, (size * aspect) / 2f, 0.0f).tex(1.0f, 1.0f).lightmap(lighti).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+        b.pos(-(size / 2f), (size * aspect) / 2f, 0.0f).tex(0.0f, 1.0f).lightmap(lighti).color(color.red, color.green, color.blue, color.alpha).normal(0, 0, 1).endVertex();
+
+        t.draw();
+
+        lightmapTexture.disableLightmap();
+    }
+
+    public void drawSizedQuadWithLightmap(float displayWidth, float displayHeight, float size, int lighti)
+    {
+        drawSizedQuadWithLightmap(displayWidth, displayHeight, size, lighti, new GlStateManager.Color());
+    }
+
+  	public void handleNotificationText()
+  	{
+  		String prefix = "";
+  		String message = "";
+  		String suffix = "";
+
+  		boolean renderTxt = false;
+
+  		// error info takes precedence
+  		if (mc.errorHelper != null) {
+  			if (System.currentTimeMillis() < mc.errorHelper.endTime)
+  			{
+  				prefix = mc.errorHelper.title;
+  				message = mc.errorHelper.message;
+  				suffix = mc.errorHelper.resolution;
+  				renderTxt = true;
+  			}
+  			else
+  			{
+  				mc.errorHelper = null;
+  			}
+  		}
+  		// otherwise display any calibration info
+  		if (renderTxt)
+  			displayNotificationText(prefix, message, suffix,
+  					this.mc.getMainWindow().getWidth(), this.mc.getMainWindow().getHeight(), true, !false);
+  	}
+
+  	// Thanks to mhagain
+  	public void renderFadeBlend (float r, float g, float b, float fadeAlpha, int left, int right, int bottom, int top)
+  	{
+  		if(fadeAlpha == 0 || Config.isShaders()) return;
+  		//TODO: fix under shadersmod
+  		
+  		GlStateManager.enableBlend();
+  		GlStateManager.disableAlphaTest();
+  		RenderSystem.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA,SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+  		GlStateManager.disableDepthTest();
+  		GlStateManager.disableTexture();
+  		GlStateManager.disableLighting();
+  		
+  		GL11.glMatrixMode(GL11.GL_PROJECTION);
+  		GlStateManager.pushMatrix();
+  		GL11.glLoadIdentity();
+
+  		// when laying out a 2D view, sometimes "top-left is the origin" makes more sense.
+  		// it is the direction i read in, after all.  live with it, weenies.
+  		GL11.glOrtho(0, this.mc.getMainWindow().getFramebufferWidth(), this.mc.getMainWindow().getFramebufferHeight(), 0, -1, 1);
+
+  		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  		GlStateManager.pushMatrix();
+  			GL11.glLoadIdentity();
+  	
+  			GlStateManager.color4f(r, g, b, fadeAlpha);
+  	
+  			GL11.glBegin(GL11.GL_QUADS);
+  	
+  			GL11.glVertex3f(left, top, 0);
+  			GL11.glVertex3f(left, bottom, 0);
+  			GL11.glVertex3f(right, bottom, 0);
+  			GL11.glVertex3f(right, top, 0);
+
+  			GL11.glEnd();
+  	
+  			GL11.glMatrixMode(GL11.GL_PROJECTION);
+  			GlStateManager.popMatrix();
+  	
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  		GlStateManager.popMatrix();
+  		
+  		GlStateManager.enableDepthTest();
+  		GlStateManager.enableTexture();
+            GlStateManager.enableAlphaTest();
+  		GlStateManager.enableLighting();
+  		
+  	}
+
+  	/** Renders the pre-generated 2-d framebuffer into the world at the appropriate location..
+  	 * @param par1
+  	 */
+  	void render2D(float par1, Framebuffer framebuffer, Vector3d pos, org.vivecraft.utils.math.Matrix4f rot, boolean depthAlways)
+  	{
+
+      	if(mc.bowTracker.isDrawing) return;	
+      	    	
+  			boolean inMenuRoom = this.isInMenuRoom();
+  			
+  			resetProjectionMatrix(this.getProjectionMatrix(activeRender, par1, true));
+
+  	        // VIVE START - custom GUI position
+            GlStateManager.pushMatrix();
+  			GL11.glLoadIdentity();
+  				applyVRModelViewLegacy(this.mc.currentPass);
+  						
+  					GlStateManager.loadIdentity();
+  					Vector3d guipos = apply2DModelView(this.mc.currentPass, pos, rot);
+  					
+  					framebuffer.bindFramebufferTexture();
+
+  					GlStateManager.disableCull();
+  					GlStateManager.enableTexture();
+  					
+  					// Prevent black border at top / bottom of GUI
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+
+  					// Set texture filtering
+  					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+  					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+
+  					GlStateManager.Color color = new GlStateManager.Color();
+  					if (!inMenuRoom)
+  					{
+                        if (mc.currentScreen == null)
+                            color.alpha = mc.vrSettings.hudOpacity;
+                        if (mc.player != null && mc.player.isSneaking())
+                            color.alpha *= 0.75f;
+  						GlStateManager.enableBlend();
+                        // Mods can just stop being dumb, m'kay?
+                        RenderSystem.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE_MINUS_DST_ALPHA, GlStateManager.DestFactor.ONE);
+  					}
+  					else{
+  						GlStateManager.disableBlend();
+  					}
+  		        
+  					if (depthAlways){
+  						GlStateManager.depthFunc(GL11.GL_ALWAYS);
+  					} else {				
+  						GlStateManager.depthFunc(GL11.GL_LEQUAL);
+  					}
+  					
+  					//the framebuffer has to be drawn with color blending transparency to support non-alpha cursors. Always has a black background.	
+                    GlStateManager.alphaFunc(GL11.GL_GREATER, 1f / 255f);
+  					GlStateManager.depthMask(true);
+  					GlStateManager.enableDepthTest();
+
+  					//Render framebuffer onto world projection
+  					if(inMenuRoom)
+  						GlStateManager.disableAlphaTest();
+  					else
+  						GlStateManager.enableAlphaTest();
+  					
+  					GlStateManager.disableLighting();
+
+                    if(mc.world != null){
+                        if (itemRenderer.isInsideOpaqueBlock(guipos))
+                            guipos = mc.vrPlayer.vrdata_world_render.hmd.getPosition();
+
+                        int minLight = Config.isShaders() ? 8 : 4;
+                        int i = Utils.getCombinedLightWithMin(mc.world, new BlockPos(guipos), minLight);
+                        
+                        drawSizedQuadWithLightmap(this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), 1.5f, i, color);
+                    } else {
+                        drawSizedQuad(this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), 1.5f, color);
+                    }
+
+  					GlStateManager.blendColor(1, 1, 1, 1);
+  					RenderSystem.defaultBlendFunc();
+  					GlStateManager.depthFunc(GL11.GL_LEQUAL);
+  					GlStateManager.enableCull();
+
+  	
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GlStateManager.popMatrix();
+  	}
+
+  	void renderPhysicalKeyboard(float partialTicks) {
+        if(mc.bowTracker.isDrawing) return;
+        
+        this.resetProjectionMatrix(this.getProjectionMatrix(activeRender, partialTicks, true));
+        RenderSystem.pushMatrix();
+	        RenderSystem.loadIdentity();
+	        RenderSystem.enableRescaleNormal();
+	        RenderHelper.enableStandardItemLighting(); // Do this exactly here or it looks wrong
+	        applyPhysicalKeyboardModelView(this.mc.currentPass, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room);
+	  	    KeyboardHandler.physicalKeyboard.render();
+	        RenderHelper.disableStandardItemLighting();
+	        RenderSystem.disableRescaleNormal();
+        RenderSystem.popMatrix();
+    }
+
+  	/** Renders the pre-generated 2-d framebuffer into the world at the appropriate location..
+  	 * @param par1
+  	 */
+  	private void renderGuiLayer(float par1, boolean depthAlways)
+  	{
+  		if(mc.bowTracker.isDrawing) return;
+
+  		if(mc.currentScreen ==null && mc.gameSettings.hideGUI) return;
+    	if(RadialHandler.isShowing()) return;
+
+  		boolean inMenuRoom = this.isInMenuRoom();
+  		  		
+  		///MAIN MENU ENVIRONMENT
+  		if(inMenuRoom){
+  			applystereoLegacy(mc.currentPass);
+  	  		Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+  	  		RenderSystem.translated((mc.vrPlayer.vrdata_world_render.origin.x - eye.x), (mc.vrPlayer.vrdata_world_render.origin.y - eye.y), (mc.vrPlayer.vrdata_world_render.origin.z - eye.z));
+
+  			if (mc.menuWorldRenderer != null && mc.menuWorldRenderer.isReady()) {
+  			    try {
+                    renderTechjarsAwesomeMainMenuRoom();
+                } catch (Exception e) {
+  			        System.out.println("Error rendering main menu world, unloading to prevent more errors");
+  			        e.printStackTrace();
+  			        mc.menuWorldRenderer.destroy();
+                }
+  			} else {
+  				renderJrbuddasAwesomeMainMenuRoom();
+  			}
+  		}	
+  		//END AWESOME MAIN MENU ENVIRONMENT
+  		
+	  		RenderSystem.pushMatrix();
+		  		RenderSystem.loadIdentity();
+		  		Vector3d guipos = GuiHandler.applyGUIModelView(this.mc.currentPass);
+		
+		  		GuiHandler.guiFramebuffer.bindFramebufferTexture();
+		
+		  		RenderSystem.disableCull();
+		  		//	RenderHelper.disableStandardItemLighting();
+		  		RenderSystem.enableTexture();
+		
+		  		// Prevent black border at top / bottom of GUI
+		  		GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+		  		GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+		
+		  		// Set texture filtering
+		  		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+		  		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+		  		GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+		
+		  		Color color = new Color();
+		  		
+		  		if (!inMenuRoom)
+		  		{
+		  		    if (mc.currentScreen == null)
+		  		        color.alpha = mc.vrSettings.hudOpacity;
+		            if (mc.player != null && mc.player.isSneaking())
+		                color.alpha *= 0.75f;
+		            RenderSystem.enableBlend();
+                    // Mods can just stop being dumb, m'kay?
+                    RenderSystem.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE_MINUS_DST_ALPHA, GlStateManager.DestFactor.ONE);
+		  		}
+		  		else{
+		  			RenderSystem.disableBlend();
+		  		}
+		
+		
+		  		if (depthAlways){
+		  			RenderSystem.depthFunc(GL11.GL_ALWAYS);
+		  		} else {
+		  			RenderSystem.depthFunc(GL11.GL_LEQUAL);
+		  		}
+			
+		  		//the framebuffer has to be drawn with color blending transparency to support non-alpha cursors. Always has a black background.
+		  		RenderSystem.alphaFunc(GL11.GL_GREATER, 1f / 255f);
+		  		RenderSystem.depthMask(true);
+	            RenderSystem.enableDepthTest();
+		  		//Render framebuffer onto world projection
+		  		if(inMenuRoom)
+		  			RenderSystem.disableAlphaTest();
+		  		else
+		  			RenderSystem.enableAlphaTest();
+		
+		  		RenderSystem.disableLighting();
+		
+		        if(mc.world != null){
+		            if (itemRenderer.isInsideOpaqueBlock(guipos))
+		                guipos = mc.vrPlayer.vrdata_world_render.hmd.getPosition();
+		
+		            int minLight = Config.isShaders() ? 8 : 4;
+		            int i = Utils.getCombinedLightWithMin(mc.world, new BlockPos(guipos), minLight);
+
+		            drawSizedQuadWithLightmap(this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), 1.5f, i, color);
+		        } else {
+		            drawSizedQuad(this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), 1.5f, color);
+		        }
+		
+		        RenderSystem.blendColor(1, 1, 1, 1);
+                RenderSystem.depthFunc(GL11.GL_LEQUAL);
+		  		RenderSystem.enableDepthTest();
+		  		RenderSystem.defaultAlphaFunc();
+		  		RenderSystem.defaultBlendFunc();
+		  		RenderSystem.enableCull();
+		  	RenderSystem.popMatrix();
+  	}
+
+  	//VIVE
+  	public void renderDebugAxes(int r, int g, int b, float radius){
+        setupPolyRendering(true);
+        // Shaders goes crazy without this
+        mc.getTextureManager().bindTexture(new ResourceLocation("vivecraft:textures/white.png"));
+  		renderCircle(new Vector3d(0, 0, 0), (float) radius, 32, r, g, b	, 255, 0);
+  		renderCircle(new Vector3d(0, .01, 0), (float) radius * .75f, 32, r, g, b	, 255, 0);
+  		renderCircle(new Vector3d(0,0.02, 0), (float) radius * .25f, 32, r, g, b	, 255, 0);
+  		renderCircle(new Vector3d(0, 0, .15), (float) radius *.5f, 32, r, g, b	, 255, 2);
+        setupPolyRendering(false);
+  	}
+
+  	
+  	public void drawScreen(float par1, Screen screen, MatrixStack matrixstack) {
+  		int mouseX = 0;
+  		int mouseY = 0;
+  		GL11.glDisable(GL11.GL_STENCIL_TEST);
+
+  		//Render all UI elements into guiFBO
+  		RenderSystem.clearColor(0, 0, 0, 0);
+  		RenderSystem.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT, mc.IS_RUNNING_ON_MAC);
+  		RenderSystem.colorMask(true, true, true, true);
+  		RenderSystem.matrixMode(GL11.GL_PROJECTION);
+  		RenderSystem.loadIdentity();
+  		RenderSystem.ortho(0.0D, this.mc.getMainWindow().getFramebufferWidth() / this.mc.getMainWindow().getGuiScaleFactor(), this.mc.getMainWindow().getFramebufferHeight() / this.mc.getMainWindow().getGuiScaleFactor(), 0.0D, 1000.0D, 3000.0D); // TODO: is this right?
+  		RenderSystem.matrixMode(GL11.GL_MODELVIEW);
+  		RenderSystem.loadIdentity();
+  		RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
+  		RenderSystem.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ONE);
+
+  		screen.render(matrixstack, 0, 0, par1);
+
+  		RenderSystem.disableLighting();
+  		RenderSystem.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ONE);
+  		//inventory messes up fog color sometimes... This fixes
+
+  		//update mipmaps for Gui layer
+  		this.mc.getFramebuffer().bindFramebufferTexture();
+  		this.mc.getFramebuffer().genMipMaps();
+  		this.mc.getFramebuffer().unbindFramebufferTexture();
+  		GL11.glEnable(GL11.GL_STENCIL_TEST);
+
+  	}
+  	
+  	public void drawFramebufferNEW(float partialTicks, boolean renderWorldIn, MatrixStack matrixstack) {
+  		if (!this.mc.skipRenderWorld)
+  		{
+  			int i = (int)(this.mc.mouseHelper.getMouseX() * (double)this.mc.getMainWindow().getScaledWidth() / (double)this.mc.getMainWindow().getWidth());
+  			int j = (int)(this.mc.mouseHelper.getMouseY() * (double)this.mc.getMainWindow().getScaledHeight() / (double)this.mc.getMainWindow().getHeight());
+
+  			MainWindow mainwindow = this.mc.getMainWindow();
+  			RenderSystem.clearColor(0, 0, 0, 0);
+  			RenderSystem.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT, Minecraft.IS_RUNNING_ON_MAC);
+  			RenderSystem.matrixMode(5889);
+  			RenderSystem.pushMatrix();
+  			RenderSystem.loadIdentity();
+  			RenderSystem.ortho(0.0D, (double)mainwindow.getWidth() / mainwindow.getGuiScaleFactor(), (double)mainwindow.getHeight() / mainwindow.getGuiScaleFactor(), 0.0D, 1000.0D, 3000.0D);
+  			RenderSystem.matrixMode(5888);
+  			RenderSystem.pushMatrix();
+  			RenderSystem.loadIdentity();
+  			RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
+  			RenderHelper.setupGui3DDiffuseLighting();
+  			RenderSystem.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ONE);
+  			RenderSystem.alphaFunc(GL11.GL_GREATER, 0.01F);
+
+  			if (this.lightmapTexture.isCustom())
+  			{
+  				this.lightmapTexture.setAllowed(false);
+  			}
+  			lightmapTexture.disableLightmap();
+  			//Vivecraft pumkinface off
+  			mc.pumpkineffect=0;
+
+  			if (renderWorldIn && this.mc.world != null)
+  			{
+  				if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
+  				{
+  					//RenderSystem.defaultAlphaFunc();
+  					//this.renderItemActivation(this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), partialTicks);
+
+  					if (Reflector.ForgeIngameGui.exists()) {
+  						RenderSystem.defaultAlphaFunc();
+  						// ensure all this forge crap is disabled
+  						Reflector.ForgeIngameGui_renderVignette.setValue(false);
+  						//Reflector.ForgeIngameGui_renderHelmet.setValue(false); do this for Xaeros default.
+  						Reflector.ForgeIngameGui_renderPortal.setValue(false);
+  						Reflector.ForgeIngameGui_renderCrosshairs.setValue(false);
+  					}
+
+  					if(!Main.viewonly)
+  						this.mc.ingameGUI.renderIngameGui(matrixstack, partialTicks);
+
+  					if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo)
+  					{
+  						Config.drawFps(matrixstack);
+  					}
+
+  					if (this.mc.gameSettings.showDebugInfo)
+  					{
+  						Lagometer.showLagometer(matrixstack, (int)this.mc.getMainWindow().getGuiScaleFactor());
+  					}
+
+  					RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+  				}
+
+  			}
+
+  			RenderSystem.clear(GL11.GL_DEPTH_BUFFER_BIT, Minecraft.IS_RUNNING_ON_MAC);
+
+  			if (this.guiLoadingVisible != (this.mc.loadingGui != null))
+  			{
+  				if (this.mc.loadingGui != null)
+  				{
+                    ResourceLoadProgressGui.loadLogoTexture(this.mc);
+
+  					if (this.mc.loadingGui instanceof ResourceLoadProgressGui)
+  					{
+  						ResourceLoadProgressGui resourceloadprogressgui = (ResourceLoadProgressGui)this.mc.loadingGui;
+  						resourceloadprogressgui.update();
+  					}
+  				}
+
+  				this.guiLoadingVisible = this.mc.loadingGui != null;
+  			}
+
+  			if (this.mc.loadingGui != null)
+  			{
+  				try
+  				{
+  					this.mc.loadingGui.render(matrixstack, i, j, this.mc.getTickLength());
+  				}
+  				catch (Throwable throwable1)
+  				{
+  					CrashReport crashreport = CrashReport.makeCrashReport(throwable1, "Rendering overlay");
+  					CrashReportCategory crashreportcategory = crashreport.makeCategory("Overlay render details");
+  					crashreportcategory.addDetail("Overlay name", () ->
+  					{
+  						return this.mc.loadingGui.getClass().getCanonicalName();
+  					});
+  					throw new ReportedException(crashreport);
+  				}
+  			}
+  			else if (this.mc.currentScreen != null)
+  			{
+  				try
+  				{
+  					if (Reflector.ForgeHooksClient_drawScreen.exists())
+  					{
+  						Reflector.callVoid(Reflector.ForgeHooksClient_drawScreen, this.mc.currentScreen, matrixstack, i, j, this.mc.getTickLength());
+  					}
+  					else
+  					{
+  						this.mc.currentScreen.render(matrixstack, i, j, this.mc.getTickLength());
+  					}
+  					mc.ingameGUI.drawMouseMenuQuad(i, j);
+  				}
+  				catch (Throwable throwable1)
+  				{
+  					CrashReport crashreport1 = CrashReport.makeCrashReport(throwable1, "Rendering screen");
+  					CrashReportCategory crashreportcategory1 = crashreport1.makeCategory("Screen render details");
+  					crashreportcategory1.addDetail("Screen name", () ->
+  					{
+  						return this.mc.currentScreen.getClass().getCanonicalName();
+  					});
+  					crashreportcategory1.addDetail("Mouse location", () ->
+  					{
+  						return String.format(Locale.ROOT, "Scaled: (%d, %d). Absolute: (%f, %f)", i, j, this.mc.mouseHelper.getMouseX(), this.mc.mouseHelper.getMouseY());
+  					});
+  					crashreportcategory1.addDetail("Screen size", () ->
+  					{
+  						return String.format(Locale.ROOT, "Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %f", this.mc.getMainWindow().getScaledWidth(), this.mc.getMainWindow().getScaledHeight(), this.mc.getMainWindow().getFramebufferWidth(), this.mc.getMainWindow().getFramebufferHeight(), this.mc.getMainWindow().getGuiScaleFactor());
+  					});
+  					throw new ReportedException(crashreport1);
+  				}
+  			}	  			
+  			//TODO - evaulate this block
+  			RenderSystem.enableColorMaterial();
+  			RenderSystem.disableBlend();
+  			RenderSystem.disableLighting();
+  			RenderSystem.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ONE);
+  			//
+
+  			mc.getProfiler().startSection("toasts");
+  			mc.getToastGui().func_238541_a_(new MatrixStack());
+  			mc.getProfiler().endSection();
+
+  			this.lightmapTexture.setAllowed(true);
+  		} //end !skipRenderWorld
+
+  		// VIVE added debug info to HUD
+  		if (mc.gameSettings.showDebugProfilerChart && !mc.gameSettings.hideGUI)
+  		{
+  			mc.drawProfiler();
+  		}
+
+  		this.frameFinish();
+  		this.waitForServerThread();
+  		MemoryMonitor.update();
+  		Lagometer.updateLagometer();
+
+  		if (this.mc.gameSettings.ofProfiler)
+  		{
+  			this.mc.gameSettings.showDebugProfilerChart = true;
+  		}
+
+  		this.mc.getFramebuffer().bindFramebufferTexture();
+  		this.mc.getFramebuffer().genMipMaps();
+  		this.mc.getFramebuffer().unbindFramebufferTexture();
+
+  		RenderSystem.matrixMode(5889);
+  		RenderSystem.popMatrix();
+  		RenderSystem.matrixMode(5888);
+  		RenderSystem.popMatrix();
+  	}
+
+  	
+  	private void renderTeleportArc(OpenVRPlayer vrPlayer) {
+
+  		if ( mc.teleportTracker.vrMovementStyle.showBeam && mc.teleportTracker.isAiming()
+  				&& mc.teleportTracker.movementTeleportArcSteps > 1)
+  		{
+  			mc.getProfiler().startSection("teleportArc");
+
+  			boolean isShader = Config.isShaders();
+  	        GlStateManager.enableCull();
+
+  	        // Shaders goes crazy without this
+            mc.getTextureManager().bindTexture(new ResourceLocation("vivecraft:textures/white.png"));
+               
+  			Tessellator tes = Tessellator.getInstance();
+  			tes.getBuffer().begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR_NORMAL);
+  			
+  				double VOffset = mc.teleportTracker.lastTeleportArcDisplayOffset;
+  				Vector3d dest = mc.teleportTracker.getDestination();
+  				
+  				boolean validLocation = (dest.x != 0
+  						|| dest.y != 0
+  						|| dest.z != 0);
+  	
+  				
+  				Vector3i color;
+  				byte alpha = (byte) 255;
+  		
+  				if (!validLocation)
+  				{
+  					// invalid location
+  					color = new Vector3i(83, 75, 83);
+  					alpha = (byte) 128;
+  				}
+  				else
+  				{
+  					if(NetworkHelper.isLimitedSurvivalTeleport() && !mc.player.abilities.allowFlying)
+  						color = tpLimitedColor;
+  					else
+  						color = tpUnlimitedColor;
+  					
+  					VOffset = this.mc.stereoProvider.getCurrentTimeSecs()*mc.teleportTracker.vrMovementStyle.textureScrollSpeed * 0.6;
+  					mc.teleportTracker.lastTeleportArcDisplayOffset = VOffset;
+  				}
+
+  				float segmentHalfWidth = mc.teleportTracker.vrMovementStyle.beamHalfWidth * 0.15f;
+  				int segments = mc.teleportTracker.movementTeleportArcSteps - 1;
+  				if (mc.teleportTracker.vrMovementStyle.beamGrow)
+  				{
+  					segments = (int) ((double) segments * mc.teleportTracker.movementTeleportProgress);
+  				}
+  				double segmentProgress = 1.0 / (double) segments;
+  	
+  				Vector3d up = new Vector3d(0,1,0);
+  	
+  				for (int i=0;i<segments;i++)
+  				{
+  					double progress = ((double)i / (double)segments) + VOffset * segmentProgress;
+  					int progressBase = (int)MathHelper.floor(progress);
+  					progress -= (float) progressBase;
+  	
+  					Vector3d start = mc.teleportTracker.getInterpolatedArcPosition((float)(progress - segmentProgress * 0.4f))
+  							.subtract(mc.getRenderViewEntity().getPositionVec());
+
+  	
+  					Vector3d end = mc.teleportTracker.getInterpolatedArcPosition((float)progress)
+  							.subtract(mc.getRenderViewEntity().getPositionVec());
+  	
+  					float shift = (float)progress * 2.0f;
+  					renderBox(tes, start, end, -segmentHalfWidth, segmentHalfWidth, (-1.0f + shift ) * segmentHalfWidth, (1.0f + shift) * segmentHalfWidth, up, color, alpha);
+  				}
+  				
+  			tes.draw();
+            GlStateManager.disableCull();
+
+  			if (validLocation && mc.teleportTracker.movementTeleportProgress >=1){ //draw landing splash
+  				Vector3d circlePos = new Vector3d(dest.x, dest.y, dest.z) 
+  						.subtract(mc.getRenderViewEntity().getPositionVec());
+
+  				int side = 1; //vrPlayer.movementTeleportDestinationSideHit;
+
+  				float o = 0.01f;
+  				
+  				double x = 0;
+  				double y = 0;
+  				double z = 0;
+
+  				if (side ==0)   y -= o;
+  				if (side ==1)   y += o;
+  				if (side ==2)   z -= o;
+  				if (side ==3)   z += o;
+  				if (side ==4)   x -= o;
+  				if (side ==5)   x += o;		
+  				renderFlatQuad(circlePos.add(x, y, z), .6f,.6f, 0,(int)(color.getX()*1.03), (int)(color.getY()*1.03), (int)(color.getZ()*1.03), 64);
+  				if (side ==0)   y -= o;
+  				if (side ==1)   y += o;
+  				if (side ==2)   z -= o;
+  				if (side ==3)   z += o;
+  				if (side ==4)   x -= o;
+  				if (side ==5)   x += o;
+  				renderFlatQuad(circlePos.add(x, y, z), .4f,.4f, 0,(int)(color.getX()*1.04), (int)(color.getY()*1.04), (int)(color.getZ()*1.04), 64);
+  				if (side ==0)   y -= o;
+  				if (side ==1)   y += o;
+  				if (side ==2)   z -= o;
+  				if (side ==3)   z += o;
+  				if (side ==4)   x -= o;
+  				if (side ==5)   x += o;
+  				renderFlatQuad(circlePos.add(x, y, z), .2f,.2f, 0,(int)(color.getX()*1.05), (int)(color.getY()*1.05), (int)(color.getZ()*1.05), 64);
+  			}
+
+  			mc.getProfiler().endSection(); // teleport arc
+  			RenderSystem.enableCull();
+  		}
+  	}
+  	public void SetupRenderingAtController(int controller, MatrixStack matrix){
+  		Vector3d aimSource = getControllerRenderPos(controller);
+  		aimSource = aimSource.subtract(mc.vrPlayer.getVRDataWorld().getEye(mc.currentPass).getPosition());  		
+  		if (aimSource!=null)
+  		{ //move from head to hand origin.
+  			matrix.translate((float) (aimSource.x ),
+  					(float) (aimSource.y ),
+  					(float) (aimSource.z ));
+  		}
+  		matrix.scale(mc.vrPlayer.vrdata_world_render.worldScale , mc.vrPlayer.vrdata_world_render.worldScale , mc.vrPlayer.vrdata_world_render.worldScale); 		
+  		//I have no idea why this has to be transposed.        	
+  		matrix.getLast().getMatrix().mul(mc.vrPlayer.vrdata_world_render.getController(controller).getMatrix().inverted().transposed().toMCMatrix());
+  	}
+
+  	
+  	//please push your matrix first. and pop after.
+  	public void SetupRenderingAtControllerLegacy(int controller){
+  		
+  		Vector3d aimSource = getControllerRenderPos(controller);
+  		aimSource = aimSource.subtract(mc.vrPlayer.getVRDataWorld().getEye(mc.currentPass).getPosition());
+  		
+  		if (aimSource!=null)
+  		{ //move from head to hand origin.
+  				GL11.glTranslatef(
+  					(float) (aimSource.x ),
+  					(float) (aimSource.y ),
+  					(float) (aimSource.z ));
+  		}
+  	
+
+  			GL11.glScalef(mc.vrPlayer.vrdata_world_render.worldScale , mc.vrPlayer.vrdata_world_render.worldScale , mc.vrPlayer.vrdata_world_render.worldScale);
+  		
+      //    	Vector3f fore = new Vector3f(0,0,1);       
+     //     	Matrix4f rotation = this.mc.vrPlayer.get.getAimRotation(controller);  
+          	
+          	FloatBuffer buf = mc.vrPlayer.vrdata_world_render.getController(controller).getMatrix().transposed().toFloatBuffer();
+          	//I have no idea why this has to be transposed.
+          	
+  	    		GL11.glMultMatrixf(buf);       	    	
+  	}
+  	
+  	public void renderFlatQuad(Vector3d pos, float width, float height,float yaw, int r, int g, int b, int a)
+  	{
+  		Tessellator tes = Tessellator.getInstance();
+
+  		tes.getBuffer().begin(GL11.GL_QUADS,DefaultVertexFormats.POSITION_COLOR_NORMAL);
+
+  		Vector3d lr = new Vector3d(-width/2,0, height/2).rotateYaw((float) Math.toRadians(-yaw));
+  		Vector3d ls = new Vector3d(-width/2,0, -height/2).rotateYaw((float) Math.toRadians(-yaw));
+  		Vector3d lt = new Vector3d(width/2,0, -height/2).rotateYaw((float) Math.toRadians(-yaw));
+  		Vector3d lu = new Vector3d(width/2,0, height/2).rotateYaw((float) Math.toRadians(-yaw));
+
+  		tes.getBuffer().pos(pos.x + lr.x, pos.y, pos.z + lr.z).color(r, g, b, a).normal(0, 1, 0).endVertex();
+  		tes.getBuffer().pos(pos.x + ls.x, pos.y, pos.z + ls.z).color(r, g, b, a).normal(0, 1, 0).endVertex();
+  		tes.getBuffer().pos(pos.x + lt.x, pos.y, pos.z + lt.z).color(r, g, b, a).normal(0, 1, 0).endVertex();
+  		tes.getBuffer().pos(pos.x + lu.x, pos.y, pos.z + lu.z).color(r, g, b, a).normal(0, 1, 0).endVertex();
+  		
+  		tes.draw();  
+  	}
+  	
+  	public void renderCircle(Vector3d pos, float radius, int edges, int r, int g, int b, int a, int side)
+  	{
+  		Tessellator tes = Tessellator.getInstance();
+  		
+  		tes.getBuffer().begin(GL11.GL_TRIANGLE_FAN,DefaultVertexFormats.POSITION_COLOR);
+
+  		tes.getBuffer().pos(pos.x, pos.y, pos.z).color(r, g, b, a).endVertex();
+
+  		for (int i=0;i<edges + 1;i++)
+  		{
+  			float startAngle;
+  			startAngle = ( (float) (i) / (float) edges ) * (float) Math.PI * 2.0f;
+
+  			if (side == 0 || side == 1) { //y
+  				float x = (float) pos.x + (float) Math.cos(startAngle) * radius;
+  				float y = (float) pos.y;
+  				float z = (float) pos.z + (float) Math.sin(startAngle) * radius;
+  				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+  			} else if (side == 2 || side == 3) { //z
+  				float x = (float) pos.x + (float) Math.cos(startAngle) * radius;
+  				float y = (float) pos.y + (float) Math.sin(startAngle) * radius;
+  				float z = (float) pos.z; 
+  				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+  			} else if (side == 4 || side == 5){ //x
+  				float x = (float) pos.x ;
+  				float y = (float) pos.y + (float) Math.cos(startAngle) * radius;
+  				float z = (float) pos.z + (float) Math.sin(startAngle) * radius;
+  				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+  			} else{}
+
+  		}
+  		
+  		tes.draw();       
+
+  	}
+
+  	private void renderBox(Tessellator tes, Vector3d start, Vector3d end, float minX, float maxX, float minY, float maxY, Vector3d up, Vector3i color, byte alpha)
+  	{
+  		Vector3d forward = start.subtract(end).normalize();
+  		Vector3d right = forward.crossProduct(up);
+  		up = right.crossProduct(forward);
+  	
+  		Vector3d left = new Vector3d(
+  				right.x * minX,
+  				right.y * minX,
+  				right.z * minX);
+  	
+  		right = right.scale(maxX);
+  		
+  	
+  		Vector3d down = new Vector3d(
+  				up.x * minY,
+  				up.y * minY,
+  				up.z * minY);
+  	
+  		up = up.scale(maxY);
+
+  		org.vivecraft.utils.lwjgl.Vector3f forwardNormal = Utils.convertToVector3f(forward);
+        org.vivecraft.utils.lwjgl.Vector3f upNormal = Utils.convertToVector3f(up.normalize());
+        org.vivecraft.utils.lwjgl.Vector3f rightNormal = Utils.convertToVector3f(right.normalize());
+
+  	
+  		Vector3d backRightBottom    = start.add(   right.x+down.x,   right.y+down.y,   right.z+down.z);
+  		Vector3d backRightTop       = start.add(   right.x+up.x,     right.y+up.y,     right.z+up.z);
+  		Vector3d backLeftBottom     = start.add(   left.x+down.x,    left.y+down.y,    left.z+down.z);
+  		Vector3d backLeftTop        = start.add(   left.x+up.x,      left.y+up.y,      left.z+up.z);
+  		Vector3d frontRightBottom   = end.add(     right.x+down.x,   right.y+down.y,   right.z+down.z);
+  		Vector3d frontRightTop      = end.add(     right.x+up.x,     right.y+up.y,     right.z+up.z);
+  		Vector3d frontLeftBottom    = end.add(     left.x+down.x,    left.y+down.y,    left.z+down.z);
+  		Vector3d frontLeftTop       = end.add(     left.x+up.x,      left.y+up.y,      left.z+up.z);
+  	
+  		BufferBuilder b = tes.getBuffer();
+  		
+  		b.pos(backRightBottom.x, backRightBottom.y, backRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(forwardNormal.x, forwardNormal.y, forwardNormal.z).endVertex();    // back
+        b.pos(backLeftBottom.x, backLeftBottom.y, backLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(forwardNormal.x, forwardNormal.y, forwardNormal.z).endVertex();
+        b.pos(backLeftTop.x, backLeftTop.y, backLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(forwardNormal.x, forwardNormal.y, forwardNormal.z).endVertex();
+  		b.pos(backRightTop.x, backRightTop.y, backRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(forwardNormal.x, forwardNormal.y, forwardNormal.z).endVertex();
+  	
+  		b.pos(frontLeftBottom.x, frontLeftBottom.y, frontLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-forwardNormal.x, -forwardNormal.y, -forwardNormal.z).endVertex();   // front
+        b.pos(frontRightBottom.x, frontRightBottom.y, frontRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-forwardNormal.x, -forwardNormal.y, -forwardNormal.z).endVertex();
+        b.pos(frontRightTop.x, frontRightTop.y, frontRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-forwardNormal.x, -forwardNormal.y, -forwardNormal.z).endVertex();
+  		b.pos(frontLeftTop.x, frontLeftTop.y, frontLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-forwardNormal.x, -forwardNormal.y, -forwardNormal.z).endVertex();
+  	
+  		b.pos(frontRightBottom.x, frontRightBottom.y, frontRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(rightNormal.x, rightNormal.y, rightNormal.z).endVertex();    // right
+        b.pos(backRightBottom.x, backRightBottom.y, backRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(rightNormal.x, rightNormal.y, rightNormal.z).endVertex();
+        b.pos(backRightTop.x, backRightTop.y, backRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(rightNormal.x, rightNormal.y, rightNormal.z).endVertex();
+  		b.pos(frontRightTop.x, frontRightTop.y, frontRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(rightNormal.x, rightNormal.y, rightNormal.z).endVertex();
+  	
+  		b.pos(backLeftBottom.x, backLeftBottom.y, backLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-rightNormal.x, -rightNormal.y, -rightNormal.z).endVertex(); // left
+        b.pos(frontLeftBottom.x, frontLeftBottom.y, frontLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-rightNormal.x, -rightNormal.y, -rightNormal.z).endVertex();
+        b.pos(frontLeftTop.x, frontLeftTop.y, frontLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-rightNormal.x, -rightNormal.y, -rightNormal.z).endVertex();
+  		b.pos(backLeftTop.x, backLeftTop.y, backLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-rightNormal.x, -rightNormal.y, -rightNormal.z).endVertex();
+  	
+  		b.pos(backLeftTop.x, backLeftTop.y, backLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(upNormal.x, upNormal.y, upNormal.z).endVertex();       // top
+        b.pos(frontLeftTop.x, frontLeftTop.y, frontLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(upNormal.x, upNormal.y, upNormal.z).endVertex();
+        b.pos(frontRightTop.x, frontRightTop.y, frontRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(upNormal.x, upNormal.y, upNormal.z).endVertex();
+  		b.pos(backRightTop.x, backRightTop.y, backRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(upNormal.x, upNormal.y, upNormal.z).endVertex();
+  	
+  		b.pos(frontLeftBottom.x, frontLeftBottom.y, frontLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-upNormal.x, -upNormal.y, -upNormal.z).endVertex();       // bottom
+        b.pos(backLeftBottom.x, backLeftBottom.y, backLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-upNormal.x, -upNormal.y, -upNormal.z).endVertex();
+        b.pos(backRightBottom.x, backRightBottom.y, backRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-upNormal.x, -upNormal.y, -upNormal.z).endVertex();
+  		b.pos(frontRightBottom.x, frontRightBottom.y, frontRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).normal(-upNormal.x, -upNormal.y, -upNormal.z).endVertex();
+  	}
+
+  	//awesome.
+  	private void renderJrbuddasAwesomeMainMenuRoom() {
+  		GlStateManager.clearColor(.1f, .1f, .1f, 0.1f);       
+  		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);        
+  		GlStateManager.disableBlend();   
+  		GlStateManager.color4f(0.5f, 0.5f, 0.5f, 1f);
+  		
+  		GlStateManager.enableDepthTest();
+  		GlStateManager.enableTexture();
+  		GlStateManager.enableLighting();
+  		GlStateManager.enableLight(0);
+  		GlStateManager.enableCull();
+  		GlStateManager.enableColorMaterial();
+  		GlStateManager.colorMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_AMBIENT_AND_DIFFUSE);
+  		
+  		Minecraft.getInstance().getTextureManager().bindTexture(Screen.BACKGROUND_LOCATION);
+  		
+  		//float yo = -camRelY;
+  		int repeat = 4; // texture wraps per meter
+  		float height = 2.5f;
+  		float oversize = 1.3f;
+  		
+  		float[] area = MCOpenVR.getPlayAreaSize();
+  		if (area != null) {
+  			float width = area[0] + oversize;
+  			float length = area[1] + oversize;
+  			GlStateManager.pushMatrix();
+  				GL11.glTranslatef(-width / 2, 0, -length / 2);
+  				GL11.glLightfv(GL11.GL_LIGHT0, GL11.GL_POSITION, setColorBuffer(width / 2, 1.8f, length / 2, 1));
+  				GL11.glLightfv(GL11.GL_LIGHT0, GL11.GL_DIFFUSE, setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+  				GL11.glLightfv(GL11.GL_LIGHT0, GL11.GL_AMBIENT, setColorBuffer(0.2F, 0.2F, 0.2F, 1.0F));
+  				GL11.glLightfv(GL11.GL_LIGHT0, GL11.GL_SPECULAR, setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+  				GL11.glLightfv(GL11.GL_LIGHT0, GL11.GL_CONSTANT_ATTENUATION, setColorBuffer(1.0F, 0, 0, 0));
+  				GL11.glLightfv(GL11.GL_LIGHT0, GL11.GL_LINEAR_ATTENUATION, setColorBuffer(0.0F, 0, 0, 0));
+  				GL11.glLightfv(GL11.GL_LIGHT0, GL11.GL_QUADRATIC_ATTENUATION, setColorBuffer(0.0F, 0, 0, 0));
+  				GL11.glLightModelfv(GL11.GL_LIGHT_MODEL_AMBIENT, setColorBuffer(0, 0, 0, 1.0F));
+  				GlStateManager.shadeModel(GL11.GL_SMOOTH);
+
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, 1, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, 0);
+  					GL11.glTexCoord2f(0, repeat * length);
+  					GL11.glVertex3f(0, 0, length);
+  					GL11.glTexCoord2f(repeat * width, repeat * length);
+  					GL11.glVertex3f(width, 0, length);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, 0, 0);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, -1, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, height, 0);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, height, 0);
+  					GL11.glTexCoord2f(repeat * width, repeat * length);
+  					GL11.glVertex3f(width, height, length);
+  					GL11.glTexCoord2f(0, repeat * length);
+  					GL11.glVertex3f(0, height, length);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(1, 0, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, 0);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(0, height, 0);
+  					GL11.glTexCoord2f(repeat * length, repeat * height);
+  					GL11.glVertex3f(0, height, length);
+  					GL11.glTexCoord2f(repeat * length, 0);
+  					GL11.glVertex3f(0, 0, length);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(-1, 0, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(width, 0, 0);
+  					GL11.glTexCoord2f(repeat * length, 0);
+  					GL11.glVertex3f(width, 0, length);
+  					GL11.glTexCoord2f(repeat * length, repeat * height);
+  					GL11.glVertex3f(width, height, length);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(width, height, 0);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, 0, 1);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, 0);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, 0, 0);
+  					GL11.glTexCoord2f(repeat * width, repeat * height);
+  					GL11.glVertex3f(width, height, 0);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(0, height, 0);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, 0, -1);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, length);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(0, height, length);
+  					GL11.glTexCoord2f(repeat * width, repeat * height);
+  					GL11.glVertex3f(width, height, length);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, 0, length);
+  				GL11.glEnd();
+  			GlStateManager.popMatrix();
+  		}
+  	
+            RenderHelper.disableStandardItemLighting();
+  	}
+
+  	private void renderTechjarsAwesomeMainMenuRoom() {
+  		GlStateManager.color4f(1f, 1f, 1f, 1f);
+
+  		GlStateManager.enableDepthTest();
+  		GlStateManager.enableTexture();
+  		GlStateManager.enableBlend();
+  		GlStateManager.enableAlphaTest();
+  		GlStateManager.enableCull();
+        GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
+
+  		RenderSystem.pushMatrix();
+
+  		int tzOffset = Calendar.getInstance().get(Calendar.ZONE_OFFSET);
+  		mc.menuWorldRenderer.time = menuWorldFastTime ? (long)((this.mc.tickCounter * 10) + 10 * mc.getRenderPartialTicks()) : (long)((System.currentTimeMillis() + tzOffset - 21600000) / 86400000D * 24000D);
+  		Vector3d eyePos = mc.menuWorldRenderer.getEyePos();
+  		float posX = (float) eyePos.x;
+  		float posY = (float) eyePos.y;
+  		float posZ = (float) eyePos.z;
+
+        mc.menuWorldRenderer.fogRenderer.updateFogColor();
+        mc.menuWorldRenderer.fogRenderer.setupFog(-1);
+        GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+        mc.menuWorldRenderer.renderSky(posX, posY, posZ, 2);
+
+        mc.menuWorldRenderer.fogRenderer.setupFog(0);
+
+  		if (posY < 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F)) {
+          	mc.menuWorldRenderer.renderClouds(2, posX, posY, posZ);
+  		}
+
+  		RenderSystem.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+  		GlStateManager.enableBlend();
+
+  		mc.menuWorldRenderer.updateLightmap();
+        mc.menuWorldRenderer.fogRenderer.setupFog(0);
+  		mc.menuWorldRenderer.render();
+
+  		if (posY >= 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F)) {
+          	mc.menuWorldRenderer.renderClouds(2, posX, posY, posZ);
+      		RenderSystem.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+      		GlStateManager.enableBlend();
+        }
+
+  		float[] area = MCOpenVR.getPlayAreaSize();
+  		if (area != null) {
+  			float width = (float)Math.ceil(area[0]);
+  			float length = (float)Math.ceil(area[1]);
+
+  			Minecraft.getInstance().getTextureManager().bindTexture(Screen.BACKGROUND_LOCATION);
+  			float sun = mc.menuWorldRenderer.getSunBrightness();
+  			GlStateManager.color4f(sun, sun, sun, 0.3f);
+  			GL11.glTranslatef(-width / 2, 0, -length / 2);
+  			GL11.glBegin(GL11.GL_QUADS);
+  				GL11.glNormal3f(0, 1, 0);
+  				GL11.glTexCoord2f(0, 0);
+  				GL11.glVertex3f(0, 0.005f, 0);
+  				GL11.glTexCoord2f(0, length);
+  				GL11.glVertex3f(0, 0.005f, length);
+  				GL11.glTexCoord2f(width, length);
+  				GL11.glVertex3f(width, 0.005f, length);
+  				GL11.glTexCoord2f(width, 0);
+  				GL11.glVertex3f(width, 0.005f, 0);
+  			GL11.glEnd();
+  		}
+
+  		GlStateManager.popMatrix();
+  		GlStateManager.disableFog();
+  		RenderSystem.defaultBlendFunc();
+  	}
+  	
+  	public boolean shouldRenderCrosshair() {
+  		if(Main.viewonly) return false;
+  		
+  		if(mc.world == null)
+  			return false;
+  		
+  		if(this.mc.currentScreen != null)
+  			return false;
+  		
+  		boolean crosshairSettings = this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_ALWAYS ||
+  				(this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_HUD && !this.mc.gameSettings.hideGUI);
+
+  		if(!crosshairSettings)
+  			return false;
+  		
+  		if (mc.currentPass == RenderPass.THIRD) //it doesn't look very good.
+  			return false;
+  		if (mc.currentPass == RenderPass.SCOPEL || mc.currentPass == RenderPass.SCOPER) //it doesn't look very good.
+  			return false;
+  		if (mc.currentPass == RenderPass.CAMERA) //it doesn't look very good.
+  		    return false;
+  		if(KeyboardHandler.Showing)
+  			return false;
+  		
+  		if(RadialHandler.isUsingController(ControllerType.RIGHT))
+  			return false;
+
+  		if (mc.bowTracker.isNotched())
+  			return false; 	
+  		
+  		if(MCOpenVR.getInputAction(MCOpenVR.keyVRInteract).isEnabledRaw(ControllerType.RIGHT) ||
+          		MCOpenVR.keyVRInteract.isKeyDown(ControllerType.RIGHT))
+  			return false;
+  		
+  		if(MCOpenVR.getInputAction(MCOpenVR.keyClimbeyGrab).isEnabledRaw(ControllerType.RIGHT) ||
+          		MCOpenVR.keyClimbeyGrab.isKeyDown(ControllerType.RIGHT))
+  			return false;
+        
+  		if (mc.teleportTracker.isAiming())
+  			return false;
+
+  		if (mc.climbTracker.isGrabbingLadder(0))
+  			return false;	
+  		
+  		if (mc.vrPlayer.worldScale > 15)
+  			return false;	
+  		
+  		return true;
+  	}
+  	
+  	private void renderCrosshairAtDepth(boolean depthAlways)
+  	{
+  		if(!shouldRenderCrosshair())
+  			return;
+  		 
+  		this.mc.getProfiler().endStartSection("crosshair");
+
+  		RenderSystem.color4f(1.0f, 1.0f, 1.0f, 1.0f); //white crosshair, with blending
+
+  		Vector3d crosshairRenderPos = crossVec;
+  		  		
+  		Vector3d aim = crosshairRenderPos.subtract(mc.vrPlayer.vrdata_world_render.getController(0).getPosition());
+  		
+  		float crossDepth =(float)aim.length();
+  		  		
+  		float scale = (float) (0.125f* this.mc.vrSettings.crosshairScale * Math.sqrt(mc.vrPlayer.vrdata_world_render.worldScale));
+  		
+  		crosshairRenderPos = crosshairRenderPos.add((aim.normalize().scale(-0.01))); //scooch closer a bit for light calc.		
+  		
+        RenderSystem.pushMatrix();
+  			RenderSystem.loadIdentity();
+  			applyVRModelViewLegacy(mc.currentPass);
+  			
+  			Vector3d translate = crosshairRenderPos.subtract(mc.getRenderViewEntity().getPositionVec());
+	  		GL11.glTranslated(translate.x , translate.y , translate.z );
+	
+	  		if(mc.objectMouseOver == null || mc.objectMouseOver.getType() != RayTraceResult.Type.BLOCK ) {
+	  			GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+	  			GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getPitch(), 1.0F, 0.0F, 0.0F);
+	  		} else {
+	  			BlockRayTraceResult hit = (BlockRayTraceResult) mc.objectMouseOver;
+	  			if(hit.getFace() == Direction.DOWN) {
+	  				GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+	  				GL11.glRotatef(-90, 1.0F, 0.0F, 0.0F);
+	  			}
+	  			else if(hit.getFace() == Direction.EAST){
+	  				GL11.glRotatef(90, 0.0F, 1.0F, 0.0F);
+	  			}
+	  			else if(hit.getFace() == Direction.NORTH){
+	  			}
+	  			else if(hit.getFace() == Direction.SOUTH){
+	  			}
+	  			else if(hit.getFace() == Direction.UP){
+	  				GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+	  				GL11.glRotatef(-90, 1.0F, 0.0F, 0.0F);
+	  			}
+	  			else if(hit.getFace() == Direction.WEST){
+	  				GL11.glRotatef(90, 0.0F, 1.0F, 0.0F);
+	  			}
+	  		}
+		
+	  		if (this.mc.vrSettings.crosshairScalesWithDistance)
+	  		{
+	  			float depthscale = .3f + 0.2f * crossDepth;
+	  			scale *=(depthscale);
+	  		}
+
+	  		lightmapTexture.enableLightmap();
+	  		RenderSystem.scalef(scale, scale, scale);
+	  		RenderSystem.depthMask(true);
+	  		RenderSystem.enableDepthTest();
+	  		RenderSystem.disableLighting();
+	  		RenderSystem.disableCull();
+  			RenderSystem.enableAlphaTest(); 
+	  		
+	  		if (depthAlways)	
+	  			RenderSystem.depthFunc(GL11.GL_ALWAYS);
+	  		else {
+	  			RenderSystem.depthFunc(GL11.GL_LEQUAL);
+	  		}
+	  						
+	  		boolean shadersMod = Config.isShaders();
+
+	  		RenderSystem.enableBlend(); // Fuck it, we want a proper crosshair
+            RenderSystem.blendFuncSeparate(GlStateManager.SourceFactor.ONE_MINUS_DST_COLOR, GlStateManager.DestFactor.ZERO, GlStateManager.SourceFactor.ONE, DestFactor.ONE_MINUS_SRC_ALPHA);
+	  		
+            int light = WorldRenderer.getCombinedLight(mc.world, new BlockPos(crosshairRenderPos));
+
+            float brightness = 1.0F;
+	  		if (mc.objectMouseOver == null || mc.objectMouseOver.getType() == RayTraceResult.Type.MISS) {
+                brightness = 0.5F;
+	  		}
+
+	  		this.mc.getTextureManager().bindTexture(Screen.GUI_ICONS_LOCATION);
+	
+	  		GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+	  		GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+	  		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+	  		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+	
+	  		float var7 = 0.00390625F;
+	  		float var8 = 0.00390625F;
+	
+	  		BufferBuilder b = Tessellator.getInstance().getBuffer();
+            b.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_LMAP_COLOR_NORMAL);
+	
+	  		b.pos(- 1, + 1, 0).tex( 0     , 15* var8).lightmap(light).color(brightness, brightness, brightness, 1.0F).normal(0, 0, 1).endVertex();
+	  		b.pos(+ 1, + 1, 0).tex( 15*var7, 15* var8).lightmap(light).color(brightness, brightness, brightness, 1.0F).normal(0, 0, 1).endVertex();
+	  		b.pos(+ 1, - 1, 0).tex( 15*var7, 0       ).lightmap(light).color(brightness, brightness, brightness, 1.0F).normal(0, 0, 1).endVertex();
+	  		b.pos(- 1, - 1, 0).tex( 0      , 0       ).lightmap(light).color(brightness, brightness, brightness, 1.0F).normal(0, 0, 1).endVertex();
+	
+	  		Tessellator.getInstance().draw();
+	
+	  		RenderSystem.defaultBlendFunc();
+	  		RenderSystem.disableBlend();
+	  		RenderSystem.enableCull();
+            RenderSystem.depthFunc(GL11.GL_LEQUAL);
+	  	RenderSystem.popMatrix();
+  	}
+  	
+  	public void renderFadeBlend(float r, float g, float b,  float fadeAlpha)
+  	{
+  		renderFadeBlend(r, g, b, fadeAlpha, 0, this.mc.getMainWindow().getFramebufferWidth(), this.mc.getMainWindow().getFramebufferHeight(), 0);
+  	}
+
+  	public Vector3d getControllerRenderPos(int c){
+  		Vector3d out ;
+  		if(mc.vrSettings.seated){	
+  			if(mc.getRenderViewEntity() != null && mc.world != null){
+  				Vector3d dir = mc.vrPlayer.vrdata_world_render.hmd.getDirection();
+  				dir = dir.rotateYaw((float) Math.toRadians(c==0?-35:35));
+  				dir = new Vector3d(dir.x, 0, dir.z);
+  				dir = dir.normalize();
+  				RenderPass p = RenderPass.CENTER;
+  				out = mc.vrPlayer.vrdata_world_render.getEye(p).getPosition().add(dir.x*0.3 * mc.vrPlayer.vrdata_world_render.worldScale, -0.4* mc.vrPlayer.vrdata_world_render.worldScale ,dir.z*0.3* mc.vrPlayer.vrdata_world_render.worldScale);
+  			} else { //main menu
+  				Vector3d dir = mc.vrPlayer.vrdata_world_render.hmd.getDirection();
+  				dir = dir.rotateYaw((float) Math.toRadians(c==0?-35:35));
+  				dir = new Vector3d(dir.x, 0, dir.z);
+  				dir = dir.normalize();
+  				out = mc.vrPlayer.vrdata_world_render.hmd.getPosition().add(dir.x*0.3 , -0.4 ,dir.z*0.3);
+  			}
+  			return out;
+  		} else {
+  			return mc.vrPlayer.vrdata_world_render.getController(c).getPosition();
+  		}
+  	}
+        	
+
+	private Vector3d apply2DModelView(RenderPass currentPass, Vector3d guipos, org.vivecraft.utils.math.Matrix4f guirot) {
+		mc.getProfiler().startSection("applyKeyboardModelView");
+
+		Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition();
+
+		Vector3d guiLocal = new Vector3d(0, 0, 0);
+
+		float scale = GuiHandler.guiScale;
+
+		//convert previously calculated coords to world coords
+		guipos = mc.vrPlayer.room_to_world_pos(guipos, mc.vrPlayer.vrdata_world_render);
+		org.vivecraft.utils.math.Matrix4f rot = org.vivecraft.utils.math.Matrix4f.rotationY(mc.vrPlayer.vrdata_world_render.rotation_radians);
+		guirot = org.vivecraft.utils.math.Matrix4f.multiply(rot, guirot);
+
+		GL11.glMultMatrixf(mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix().toFloatBuffer());
+
+		GL11.glTranslatef((float) (guipos.x - eye.x), (float) (guipos.y - eye.y), (float) (guipos.z - eye.z));
+//
+//    			// offset from eye to gui pos
+		GL11.glMultMatrixf(guirot.transposed().toFloatBuffer());
+		GL11.glTranslatef((float) guiLocal.x, (float) guiLocal.y, (float) guiLocal.z);
+
+		float thescale = scale * mc.vrPlayer.vrdata_world_render.worldScale; // * this.mc.vroptions.hudscale
+		GlStateManager.scalef(thescale, thescale, thescale);
+
+		mc.getProfiler().endSection();
+
+		return guipos;
+	}
+
+	private Vector3d applyPhysicalKeyboardModelView(RenderPass currentPass, Vector3d guipos, org.vivecraft.utils.math.Matrix4f guirot) {
+		mc.getProfiler().startSection("applyPhysicalKeyboardModelView");
+
+		Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition();
+
+		//convert previously calculated coords to world coords
+		guipos = mc.vrPlayer.room_to_world_pos(guipos, mc.vrPlayer.vrdata_world_render);
+		org.vivecraft.utils.math.Matrix4f rot = org.vivecraft.utils.math.Matrix4f.rotationY(mc.vrPlayer.vrdata_world_render.rotation_radians);
+		guirot = org.vivecraft.utils.math.Matrix4f.multiply(rot, guirot);
+
+		// counter head rotation
+		GL11.glMultMatrixf(mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix().toFloatBuffer());
+
+
+		// offset from eye to gui pos
+		GlStateManager.translatef((float) (guipos.x - eye.x), (float) (guipos.y - eye.y), (float) (guipos.z - eye.z));
+		GlStateManager.multMatrix(guirot.transposed().toFloatBuffer());
+
+		float scale = mc.vrPlayer.vrdata_world_render.worldScale;
+		GlStateManager.scalef(scale, scale, scale);
+
+		mc.getProfiler().endSection();
+
+		return guipos;
+	}
+      	
+	//new hotness
+  	private void applyVRModelView(RenderPass currentPass, MatrixStack matrix)
+  	{
+ 		matrix.getLast().getMatrix().mul(mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix().transposed().toMCMatrix());
+  	}  	 	
+  	
+  	public void applystereo(RenderPass currentPass, MatrixStack matrix)
+  	{
+  		if(currentPass != RenderPass.LEFT && currentPass != RenderPass.RIGHT) return;
+  		Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition().subtract(mc.vrPlayer.vrdata_world_render.getEye(RenderPass.CENTER).getPosition());
+  		matrix.translate((float)-eye.x, (float)-eye.y, (float)-eye.z);
+  	}	
+ 	public void removeStereo(RenderPass currentPass, MatrixStack matrix)
+  	{
+  		if(currentPass != RenderPass.LEFT && currentPass != RenderPass.RIGHT) return;
+  		Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition().subtract(mc.vrPlayer.vrdata_world_render.getEye(RenderPass.CENTER).getPosition());
+  		matrix.translate((float)eye.x, (float)eye.y, (float)eye.z);
+  	}
+ 	 	
+  	//
+  	
+  	//old and busted
+  	public void applyVRModelViewLegacy(RenderPass currentPass)
+  	{ 		
+//  		if(mc == null) System.out.println("mc is null");
+//  		if(mc.vrPlayer == null) System.out.println("mc.vrPlayer is null");
+//  		if(mc.vrPlayer.vrdata_world_render == null) System.out.println("mc.vrPlayer.vrdata_world_render is null");
+//  		if(mc.vrPlayer.vrdata_world_render.getEye(currentPass) == null) System.out.println("mc.vrPlayer.vrdata_world_render.getEye(currentPass) is null");
+//  		if(mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix() == null) System.out.println("mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix() is null");
+  		FloatBuffer fb = mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix().toFloatBuffer();
+//  		if(mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix().toFloatBuffer() == null) System.out.println("mc.vrPlayer.vrdata_world_render.getEye(currentPass).getMatrix().toFloatBuffer() is null");		
+  		GL11.glMultMatrixf(fb);	
+  	}  	
+  	
+  	private void applystereoLegacy(RenderPass currentPass)
+  	{
+  		if(currentPass != RenderPass.LEFT && currentPass != RenderPass.RIGHT) return;
+  		Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition().subtract(mc.vrPlayer.vrdata_world_render.getEye(RenderPass.CENTER).getPosition());
+  		GL11.glTranslatef((float)eye.x, (float)eye.y, (float)eye.z);
+  	}
+  	
+  	private void removeStereoLegacy(RenderPass currentPass)
+  	{
+  		if(currentPass != RenderPass.LEFT && currentPass != RenderPass.RIGHT) return;
+  		Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition().subtract(mc.vrPlayer.vrdata_world_render.getEye(RenderPass.CENTER).getPosition());
+  		GL11.glTranslatef((float)-eye.x, (float)-eye.y, (float)-eye.z);
+  	}
+    //      
+  	
+  	private void setupPolyRendering(boolean enable){
+  		boolean shadersMod = Config.isShaders();
+  		//boolean shadersModShadowPass = false;
+  		if(enable){
+  			polyblendsrca = GlStateManager.BLEND.srcFactorAlpha;
+  			polyblenddsta = GlStateManager.BLEND.dstFactorAlpha;
+  			polyblendsrcrgb = GlStateManager.BLEND.srcFactorRgb;
+  			polyblenddstrgb = GlStateManager.BLEND.dstFactorRgb;
+
+  			polyblend = GL11.glIsEnabled(GL11.GL_BLEND);
+  			polytex =  GL11.glIsEnabled(GL11.GL_TEXTURE_2D);
+  			polylight =  GL11.glIsEnabled(GL11.GL_LIGHTING);
+  			polycull =  GL11.glIsEnabled(GL11.GL_CULL_FACE);
+
+  			GlStateManager.enableBlend();
+  			RenderSystem.defaultBlendFunc();
+  			GlStateManager.disableTexture();
+  			GlStateManager.disableLighting();
+  			GlStateManager.disableCull();
+  			if(shadersMod){
+  				prog  = Shaders.activeProgram;
+  				Shaders.useProgram(Shaders.ProgramTexturedLit);
+  			}
+  		} else {
+  			RenderSystem.blendFuncSeparate(polyblendsrcrgb, polyblenddstrgb, polyblendsrca, polyblenddsta);
+  			if (!polyblend) GlStateManager.disableBlend(); 
+  			if (polytex) GlStateManager.enableTexture();
+  			if (polylight) GlStateManager.enableLighting();
+  			if (polycull) GlStateManager.enableCull();
+  			if(shadersMod && polytex)
+  				Shaders.useProgram(prog);
+  		}
+    }
+
+  	public void setupRVE() {
+  		if (!cached) 
+  			return;
+  		
+  		VRDevicePose data;
+  		
+  		Vector3d f;
+//  		if(mc.currentPass == RenderPass.THIRD){
+//  			data = mc.vrPlayer.vrdata_world_render.c2;
+//  		}
+//  		else{
+//  			data = mc.vrPlayer.vrdata_world_render.hmd;
+//  		}
+  		
+  		data = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass);
+  		
+		f = data.getPosition();
+
+  		LivingEntity rve = (LivingEntity) this.mc.getRenderViewEntity();
+  		rve.setRawPosition(f.x, f.y, f.z);
+  		rve.lastTickPosX = f.x;
+  		rve.lastTickPosY = f.y;
+  		rve.lastTickPosZ = f.z;
+  		rve.prevPosX = f.x;
+  		rve.prevPosY = f.y;
+  		rve.prevPosZ = f.z;
+  		rve.rotationPitch =rve.prevRotationPitch = -data.getPitch();
+  		rve.prevRotationYawHead	= rve.prevRotationYaw  = rve.rotationYaw = rve.rotationYawHead = data.getYaw();
+  		MCReflection.Entity_eyeHeight.set(rve, 0);
+  	}	
+  	
+  	public void cacheRVEPos(LivingEntity e){
+  		if (mc.getRenderViewEntity() == null) return;
+  		if (cached) 
+  			return;
+  		rveX = e.getPosX();
+  		rveY = e.getPosY();
+  		rveZ = e.getPosZ();		
+  		rvelastX = e.lastTickPosX;
+  		rvelastY = e.lastTickPosY;
+  		rvelastZ = e.lastTickPosZ;
+  		rveprevX = e.prevPosX;
+  		rveprevY = e.prevPosY;
+  		rveprevZ = e.prevPosZ;	
+  		rveyaw = e.rotationYawHead;
+  		rvepitch = e.rotationPitch;
+  		rvelastyaw = e.prevRotationYawHead;
+  		rvelastpitch = e.prevRotationPitch;
+  		rveHeight = e.getEyeHeight();
+  		cached = true;
+  	}
+  	
+  	public void restoreRVEPos(LivingEntity e){
+  		if (e == null) return;
+  		e.setRawPosition(rveX, rveY, rveZ);
+  		e.lastTickPosX = rvelastX;
+  		e.lastTickPosY = rvelastY;
+  		e.lastTickPosZ = rvelastZ;
+  		e.prevPosX = rveprevX;
+  		e.prevPosY = rveprevY;
+  		e.prevPosZ = rveprevZ;
+  		e.rotationYaw = rveyaw;
+  		e.rotationPitch = rvepitch;
+  		e.prevRotationYaw = rvelastyaw;
+  		e.prevRotationPitch = rvelastpitch;
+  		e.rotationYawHead = rveyaw;
+  		e.prevRotationYawHead = rvelastyaw;
+  		MCReflection.Entity_eyeHeight.set(e, rveHeight);
+  		cached = false;
+  	}
+  		
+  	private void setupOverlayStatus(float partialTicks) {
+  		inBlock = 0;
+  		inwater = false;
+  		onfire = false;
+  		if (!this.mc.player.isSpectator() && !isInMenuRoom() && mc.player.isAlive())
+  		{
+  			Vector3d pos = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+  			Triple<Float, BlockState, BlockPos> triple = itemRenderer.getNearOpaqueBlock(pos, minClipDistance);
+            if (triple != null && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderBlockOverlay, this.mc.player, new MatrixStack(), Reflector.getFieldValue(Reflector.RenderBlockOverlayEvent_OverlayType_BLOCK), triple.getMiddle(), triple.getRight()))
+                inBlock = triple.getLeft();
+            else
+                inBlock = 0;
+  			inwater =  this.mc.player.areEyesInFluid(FluidTags.WATER) && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderWaterOverlay, this.mc.player, new MatrixStack());
+  			onfire = mc.currentPass != RenderPass.THIRD && mc.currentPass != RenderPass.CAMERA && this.mc.player.isBurning() && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderFireOverlay, this.mc.player, new MatrixStack());
+  		}
+  	}
+  	
+  	private void renderVRSelfEffects(float par1) {
+  		if (onfire && mc.currentPass != RenderPass.THIRD && mc.currentPass != RenderPass.CAMERA)
+  		{
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glLoadIdentity();
+  	    	if(onfire)renderFireInFirstPerson();
+  	  		renderItemActivation(0, 0, par1); //totem of undying
+  		}
+  	}
+  	
+  	private void renderVrShadow(float par1, boolean depthAlways){
+  		if(mc.currentPass == RenderPass.THIRD || mc.currentPass == RenderPass.CAMERA)
+  			return;
+  		if(!mc.player.isAlive())
+  			return;
+  		if(mc.player.getRoomYOffsetFromPose() < 0) //covers flying and swim-sprint.
+  			return;
+  		if(mc.player.getRidingEntity()!=null) 
+  			return;
+  		AxisAlignedBB bb = mc.player.getBoundingBox();
+  		if(this.mc.vrSettings.vrShowBlueCircleBuddy && bb != null){ //RIP blue circle buddy
+  			RenderSystem.matrixMode(GL11.GL_MODELVIEW);
+  			RenderSystem.pushMatrix();
+  			RenderSystem.loadIdentity();
+  			GlStateManager.disableCull();
+
+  			applyVRModelViewLegacy(mc.currentPass);
+
+  			Vector3d o = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+
+  			ClientPlayerEntity player = mc.player;
+
+  			Vector3d interpolatedPlayerPos = new Vector3d(
+  					rvelastX + (rveX - rvelastX) * (double)par1,
+  					rvelastY + (rveY - rvelastY) * (double)par1,
+  					rvelastZ + (rveZ - rvelastZ) * (double)par1
+  					);
+
+  			Vector3d pos = interpolatedPlayerPos.subtract(o).add(0, 0.005, 0);
+  			setupPolyRendering(true);
+  			RenderSystem.enableDepthTest();
+
+  			if(depthAlways)
+  				RenderSystem.depthFunc(GL11.GL_ALWAYS);
+  			else
+  				GlStateManager.depthFunc(GL11.GL_LEQUAL);
+
+  			// Shaders goes crazy without this
+  			mc.getTextureManager().bindTexture(new ResourceLocation("vivecraft:textures/white.png"));
+  			renderFlatQuad(pos,
+  					(float)(bb.maxX - bb.minX),
+  					(float) (bb.maxZ - bb.minZ),
+  					0, 0, 0, 0, 64);
+  			RenderSystem.depthFunc(GL11.GL_LEQUAL);
+  			setupPolyRendering(false);
+
+  			RenderSystem.matrixMode(GL11.GL_MODELVIEW);
+  			RenderSystem.popMatrix();
+  			GlStateManager.enableCull();
+  		}         
+  	}
+  	
+  	void DrawScopeFB(MatrixStack matrixStackIn, int i) {
+  		if (mc.currentPass == RenderPass.SCOPEL || mc.currentPass == RenderPass.SCOPER)
+  			return;
+		lightmapTexture.disableLightmap();
+		RenderSystem.pushMatrix();
+			RenderSystem.multMatrix(matrixStackIn.getLast().getMatrix());
+			RenderSystem.enableDepthTest();
+			RenderSystem.enableAlphaTest();
+			RenderSystem.disableTexture();
+			RenderSystem.enableBlend();
+            RenderSystem.alphaFunc(GL11.GL_GREATER, 0);
+			if(i==0)
+				mc.stereoProvider.telescopeFramebufferR.bindFramebufferTexture();
+			else
+				mc.stereoProvider.telescopeFramebufferL.bindFramebufferTexture();
+
+			// background
+			drawSizedQuad(720, 720, 0.075f * mc.vrPlayer.vrdata_world_render.worldScale, new Color(0, 0, 0,1));
+
+            RenderSystem.enableTexture();
+			RenderSystem.disableBlend();
+			// fb
+			drawSizedQuadWithLightmap(720, 720, 0.075f * mc.vrPlayer.vrdata_world_render.worldScale, LightTexture.packLight(15, 15));
+
+			RenderSystem.enableBlend();
+			RenderSystem.disableTexture();
+            float alpha = TelescopeTracker.viewPercent(i);
+			// fade overlay
+			drawSizedQuad(720, 720, 0.075f * mc.vrPlayer.vrdata_world_render.worldScale, new Color(0,0,0, 1 - alpha));
+
+			RenderSystem.colorMask(true,  true,  true,  true);
+            RenderSystem.defaultAlphaFunc();
+			lightmapTexture.enableLightmap();
+		RenderSystem.popMatrix();
+  	}
+  	
+  	void drawEyeStencil(boolean shaders) {
+  		if(mc.currentPass == RenderPass.SCOPEL || mc.currentPass ==RenderPass.SCOPER) {
+  			if (!Config.isShaders()) // stencil looks stupid with shaders so screw it
+  			    mc.stereoProvider.doCircleStencil(mc.framebuffer);
+  			return;
+  		}
+  		
+  		if((mc.currentPass == RenderPass.LEFT || mc.currentPass == RenderPass.RIGHT) && mc.vrSettings.vrUseStencil && MCOpenVR.isHMDTracking()){
+  			Program lastProgram = Shaders.activeProgram;
+  			if(shaders){
+  				GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, Shaders.dfb);
+  				Shaders.useProgram(Shaders.ProgramNone);
+
+  				for (int i = 0; i < Shaders.usedDepthBuffers; ++i)
+  				{
+  					GlStateManager.bindTexture(Shaders.dfbDepthTextures.get(i));
+  					mc.stereoProvider.doStencilForEye(mc.currentPass == RenderPass.LEFT ? 0 : 1);
+  				}
+
+  				Shaders.useProgram(lastProgram);
+
+  			} else {
+  				mc.stereoProvider.doStencilForEye(mc.currentPass == RenderPass.LEFT ? 0 : 1);
+  			}
+  		}
+  		else{
+  			GL11.glDisable(GL11.GL_STENCIL_TEST);
+  		}
+  	}
+
+  	public boolean shouldOccludeGui() {
+  		Vector3d pos = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+  		if(mc.currentPass == RenderPass.THIRD || mc.currentPass == RenderPass.CAMERA) return true;
+  		if (isInMenuRoom() || 
+  				mc.currentScreen != null ||
+  				KeyboardHandler.Showing ||
+  				RadialHandler.isShowing() ||
+  				!this.mc.vrSettings.hudOcclusion || 
+  				itemRenderer.isInsideOpaqueBlock(pos))
+  		{
+  			return false;
+  		}
+  		return true;
+  	}
+    
+    public boolean shouldRenderHands() {	
+        if(Main.viewonly) return false;
+        if(mc.currentPass == RenderPass.THIRD) return 
+        		(mc.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY);
+        if (mc.currentPass == RenderPass.CAMERA)
+            return false;
+        return true;
+    }
+
+
+    public boolean isInMenuRoom() {
+  	    return this.mc.world == null || mc.currentScreen instanceof WinGameScreen || mc.integratedServerLaunchInProgress || mc.loadingGui != null;
+    }
+  	
+    public void displayNotificationText(String prefix, String message, String suffix,
+                                        int displayWidth, int displayHeight, 
+                                        boolean isStereo, boolean isGuiOrtho)
+    {
+    	final float INITIAL_TEXT_SCALE = isGuiOrtho ? 0.0055f : 0.00375f;
+    	final int TEXT_WORDWRAP_LEN = 55;
+    	final int COLUMN_GAP = 12;
+
+    	float fade = isGuiOrtho ? 0.85f : 0.80f;
+    	Vector3d rgb = new Vector3d(0f, 0f, 0f);
+
+    	if (isStereo)
+    	{
+    		resetProjectionMatrix(getProjectionMatrix(activeRender, 0, true));
+    	}
+    	else
+    	{
+        	GL11.glMatrixMode(GL11.GL_PROJECTION);
+        	GlStateManager.pushMatrix();
+        	GL11.glLoadIdentity();
+    		GlStateManager.multMatrix(Matrix4f.perspective(90f, (float) displayWidth / (float) displayHeight, minClipDistance, clipDistance * 4));
+        	GL11.glMatrixMode(GL11.GL_MODELVIEW);
+    	}
+    	
+    	GlStateManager.pushMatrix();
+    	GL11.glLoadIdentity();
+
+    	int column = 8;
+    	ArrayList<String> wrapped = new ArrayList<String>();
+    	if (message != null)
+    		org.vivecraft.utils.Utils.wordWrap(message, TEXT_WORDWRAP_LEN, wrapped);
+    	float rows = wrapped.size();
+    	float shift = rows / 2f;
+
+    	float x = isGuiOrtho ? 0f : 0; // : -this.mc.vrSettings.getHalfIPD(EyeType.ovrEye_Center);
+    	float y = shift * COLUMN_GAP * 0.003f; // Move up
+    	float z = -0.6f;
+    	boolean d = GL11.glIsEnabled(GL11.GL_DEPTH_TEST);
+    	GlStateManager.disableDepthTest();
+    	GL11.glTranslatef(x, y, z);
+    	GL11.glRotatef(180f, 0.0F, 1.0F, 0.0F);
+    	float textScale = (float) Math.sqrt((x * x + y * y + z * z));
+    	GL11.glScalef(-INITIAL_TEXT_SCALE * textScale, -INITIAL_TEXT_SCALE * textScale, -INITIAL_TEXT_SCALE * textScale);
+    	MatrixStack matrixstack = new MatrixStack();
+    	if (prefix != null)
+    		mc.fontRenderer.drawStringWithShadow(matrixstack, prefix, -mc.fontRenderer.getStringWidth(prefix) / 2, -8, /*white*/16777215);
+
+    	for (String line : wrapped)
+    	{
+    		mc.fontRenderer.drawStringWithShadow(matrixstack, line, -mc.fontRenderer.getStringWidth(line) / 2, column, /*white*/16777215);
+    		column += COLUMN_GAP;
+    	}
+    	column += COLUMN_GAP;
+    	if (suffix != null)
+    		mc.fontRenderer.drawStringWithShadow(matrixstack, suffix, -mc.fontRenderer.getStringWidth(suffix) / 2, column, /*white*/16777215);
+
+    	if(d)	GlStateManager.enableDepthTest();
+    	GL11.glMatrixMode(GL11.GL_PROJECTION);
+    	GlStateManager.popMatrix();
+    	GL11.glMatrixMode(GL11.GL_MODELVIEW);
+    	GlStateManager.popMatrix();
+    }
+
+    private FloatBuffer colorBuffer = BufferUtils.createFloatBuffer(4);
+
+    private FloatBuffer setColorBuffer(float red, float green, float blue, float alpha) {
+        this.colorBuffer.clear();
+        this.colorBuffer.put(red).put(green).put(blue).put(alpha);
+        this.colorBuffer.flip();
+        return this.colorBuffer;
+    }
+    
+    private void renderSwingDebug(int c) {	
+    	if(true) return;
+    	if(mc.swingTracker.miningPoint[c] == null) return;
+    	//Swing debug
+    	GlStateManager.pushMatrix();
+    		GlStateManager.loadIdentity();
+	    	applyVRModelViewLegacy(mc.currentPass);
+	    	Vector3d eye = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+	    	GlStateManager.pushMatrix();
+		    	GlStateManager.translated(mc.swingTracker.attackingPoint[c].x - eye.x, mc.swingTracker.attackingPoint[c].y - eye.y, mc.swingTracker.attackingPoint[c].z-eye.z);
+		    	if(mc.swingTracker.canact[c])
+		    		renderDebugAxes(0, 255, 0, 0.03f);
+		    	else
+		    		renderDebugAxes(255, 0, 0, 0.03f);
+	    	GlStateManager.popMatrix();
+	    	GlStateManager.pushMatrix();
+	    		GlStateManager.translated(mc.swingTracker.miningPoint[c].x - eye.x, mc.swingTracker.miningPoint[c].y - eye.y, mc.swingTracker.miningPoint[c].z-eye.z);
+		    	if(mc.swingTracker.canact[c])
+		    		renderDebugAxes(0, 255, 0, 0.02f);
+		    	else
+		    		renderDebugAxes(255, 255, 0, 0.02f);
+		    GlStateManager.popMatrix();
+    	GlStateManager.popMatrix();
+    }
+    
+    void renderVRHands(float partialTicks, boolean renderright, boolean renderleft, boolean menuhandright, boolean menuhandleft) {
+    	this.mc.getProfiler().startSection("hands");
+
+    	//Render Physical Inventories
+    	//mc.physicalGuiManager.doRender(partialTicks);
+    	//
+    	
+    	
+    	if(renderright) {
+	    	mc.getItemRenderer().ismainhand = true;
+	    	if(menuhandright) {
+	    		renderMainMenuHand(0, partialTicks, false);
+	    	} else {
+	    		this.resetProjectionMatrix(this.getProjectionMatrix(activeRender, partialTicks, true));
+	    		RenderSystem.loadIdentity();
+	    		MatrixStack mat = new MatrixStack();
+	    		mat.getLast().getMatrix().setIdentity();
+	    		applyVRModelView(mc.currentPass, mat); 	
+	    		this.renderVRHand_Main(mat, partialTicks);
+	        	//Testing
+	    		renderSwingDebug(0);
+	    	}
+	    	mc.getItemRenderer().ismainhand = false;
+    	}
+    	
+    	if(renderleft) {
+	    	if(menuhandleft) {
+	    		renderMainMenuHand(1, partialTicks, false);
+	    	} else {
+	    		this.resetProjectionMatrix(this.getProjectionMatrix(activeRender, partialTicks, true));
+	    		RenderSystem.loadIdentity();
+	    		MatrixStack mat = new MatrixStack();
+	    		mat.getLast().getMatrix().setIdentity();
+	    		applyVRModelView(mc.currentPass, mat); 	
+	        	this.renderVRHand_Offhand(partialTicks, true, mat);
+	        	//Testing
+	    		renderSwingDebug(1);
+	    	}
+    	}
+    	this.mc.getProfiler().endSection();
+    }
+    
+    private void renderVRHand_Main(MatrixStack matrix, float partialTicks)
+    {
+    	matrix.push();
+	    	//from HMD to controller
+	    	SetupRenderingAtController(0, matrix);
+		    	
+	    	ItemStack item = mc.player.getHeldItemMainhand();
+	    	ItemStack override=mc.physicalGuiManager.getHeldItemOverride();
+	    	if(override!=null)
+	    		item=override;
+	
+	    	if(mc.climbTracker.isClimbeyClimb() && (item.getItem() != Items.SHEARS)){
+	    		item = override==null? mc.player.getHeldItemOffhand() : override;
+	    	}
+	    	
+	    	if(BowTracker.isHoldingBow(mc.player, Hand.MAIN_HAND)){
+	    		//do ammo override
+	    		int c = 0;
+	    		if (mc.vrSettings.vrReverseShootingEye) c = 1;				
+	    		ItemStack ammo = mc.player.findAmmo(mc.player.getHeldItemMainhand());
+	    		if (ammo != ItemStack.EMPTY  && !mc.bowTracker.isNotched()) { //render the arrow in right, left hand will check for and render bow.
+	    			item = ammo;
+	    		} else {
+	    			item = ItemStack.EMPTY;
+	    		}
+	    	}    	
+	    	else if(BowTracker.isHoldingBow(mc.player, Hand.OFF_HAND) && mc.bowTracker.isNotched()){
+	    		int c = 0;
+	    		if (mc.vrSettings.vrReverseShootingEye) c = 1;				
+	    		item = ItemStack.EMPTY;
+	    	}
+	    	boolean translucent = false;
+	    	
+	    	if(Config.isShaders())
+	    		Shaders.beginHand(matrix, translucent);
+	    	else	
+	    		matrix.push();
+
+		    	this.lightmapTexture.enableLightmap();
+		    	Impl buffer = this.renderTypeBuffers.getBufferSource();
+		    	this.itemRenderer.renderItemInFirstPerson(mc.player, partialTicks, 0, Hand.MAIN_HAND, mc.player.getSwingProgress(partialTicks), item, 0, matrix, buffer,  this.mc.getRenderManager().getPackedLight(this.mc.player, partialTicks));
+		    	buffer.finish();
+		    	this.lightmapTexture.disableLightmap();
+	    	
+	    	if(Config.isShaders())
+	    		Shaders.endHand(matrix);
+	    	else
+	    		matrix.pop();
+
+    	matrix.pop();
+    }
+    
+ 	private void renderVRHand_Offhand(float partialTicks, boolean renderTeleport, MatrixStack matrix)
+ 	{
+ 		boolean shadersMod = Config.isShaders();
+ 		boolean shadersModShadowPass = false;
+
+ 		if(shadersMod){
+ 			shadersModShadowPass = Shaders.isShadowPass;
+ 		}
+
+
+ 		matrix.push();
+
+ 		SetupRenderingAtController(1, matrix);
+
+ 		ItemStack item = mc.player.getHeldItemOffhand();
+
+ 		ItemStack override=mc.physicalGuiManager.getOffhandOverride();
+ 		if(override!=null)
+ 			item=override;
+
+ 		if(mc.climbTracker.isClimbeyClimb() && (item==null || item.getItem() != Items.SHEARS)){
+ 			item = mc.player.getHeldItemMainhand();
+ 		}
+
+ 		if(BowTracker.isHoldingBow(mc.player, Hand.MAIN_HAND)){ //render bow
+ 			int c = 1;
+ 			if (mc.vrSettings.vrReverseShootingEye) c = 0;
+ 			item = mc.player.getHeldItemMainhand();
+ 		}
+
+ 		boolean translucent = false;
+ 		if(Config.isShaders())
+ 			Shaders.beginHand(matrix, translucent);
+ 		else	
+ 			matrix.push();
+
+ 		this.lightmapTexture.enableLightmap();
+ 		Impl buffer = this.renderTypeBuffers.getBufferSource();
+ 		this.itemRenderer.renderItemInFirstPerson(mc.player, partialTicks, 0, Hand.OFF_HAND, mc.player.getSwingProgress(partialTicks), item, 0, matrix, buffer,  this.mc.getRenderManager().getPackedLight(this.mc.player, partialTicks));
+ 		buffer.finish();
+ 		this.lightmapTexture.disableLightmap();
+
+ 		if(Config.isShaders())
+ 			Shaders.endHand(matrix);
+ 		else
+ 			matrix.pop();
+
+ 		matrix.pop(); //back to hmd rendering
+
+ 		if (renderTeleport) {
+ 			//setupPolyRendering(true);
+
+ 			RenderSystem.pushMatrix();
+	 			RenderSystem.loadIdentity();
+	 			applyVRModelViewLegacy(mc.currentPass);
+	 			applystereoLegacy(mc.currentPass);
+	
+	 			Program prog = Shaders.activeProgram;
+	 			if (Config.isShaders())
+	 				Shaders.useProgram(Shaders.ProgramTexturedLit);
+	
+	 			RenderSystem.enableAlphaTest();
+	 			RenderSystem.enableBlend();
+	 			RenderSystem.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+	 			RenderSystem.disableTexture();
+	
+	 			//	TP energy
+	 			if (NetworkHelper.isLimitedSurvivalTeleport() && !mc.vrPlayer.getFreeMove() && mc.playerController.isNotCreative() && mc.teleportTracker.vrMovementStyle.arcAiming && !mc.bowTracker.isActive(mc.player)){
+	 				RenderSystem.pushMatrix();
+	 				removeStereoLegacy(mc.currentPass);
+	 				SetupRenderingAtControllerLegacy(1);	//does not push
+	 				Vector3d start = new Vector3d(0,0.005,.03);
+	
+	 				float r;
+	 				float max = .03f;
+	 				if (mc.teleportTracker.isAiming()) {
+	 					r = 2*(float) ( mc.teleportTracker.getTeleportEnergy() - 4 * mc.teleportTracker.movementTeleportDistance  ) / 100 * max;
+	 				} else {
+	 					r = 2*mc.teleportTracker.getTeleportEnergy() / 100 * max;
+	 				}
+	
+	 				if(r<0){r=0;}
+	
+	 				// Shaders goes crazy without this
+	 				mc.getTextureManager().bindTexture(new ResourceLocation("vivecraft:textures/white.png"));
+	
+	 				renderFlatQuad(start.add(0, .05001, 0), r,r,0, tpLimitedColor.getX(), tpLimitedColor.getY(), tpLimitedColor.getZ(), 128);
+	 				renderFlatQuad(start.add(0, .05, 0), max,max,0, tpLimitedColor.getX(), tpLimitedColor.getY(), tpLimitedColor.getZ(), 50);
+	
+	 				RenderSystem.popMatrix();
+	 			}
+	
+	 			if(mc.teleportTracker.isAiming()){ //actually rendered from the head, not hand.
+	 				RenderSystem.pushMatrix();
+	 				removeStereoLegacy(mc.currentPass);
+	 				RenderSystem.enableDepthTest();
+	 				if(mc.teleportTracker.vrMovementStyle.arcAiming) {
+	 					renderTeleportArc(mc.vrPlayer);
+	 				} else {
+	 					//renderTeleportLine(mc.vrPlayer);
+	 				}
+	 				RenderSystem.popMatrix();
+	 			}
+	
+	 			//setupPolyRendering(false);
+	 			RenderSystem.enableTexture();
+	 			RenderSystem.defaultBlendFunc();
+	 			
+	 			if (Config.isShaders())
+	 				Shaders.useProgram(prog);
+	
+	 			RenderSystem.matrixMode(GL11.GL_MODELVIEW);
+ 			RenderSystem.popMatrix();
+ 		}
+ 	}
+
+  	void renderMainMenuHand(int c, float partialTicks, boolean depthAlways)
+  	{		
+  		this.resetProjectionMatrix(this.getProjectionMatrix(activeRender, partialTicks, true));
+
+  		RenderSystem.matrixMode(GL11.GL_MODELVIEW);
+  		RenderSystem.pushMatrix();
+	  		RenderSystem.loadIdentity();
+	
+	  		RenderSystem.disableTexture();
+	  		RenderSystem.disableAlphaTest();	
+	  		RenderSystem.enableDepthTest();
+	
+	  		applyVRModelViewLegacy(mc.currentPass);
+	
+	  		//Shaders goes crazy without this
+	  		if (mc.loadingGui == null)
+	  			mc.getTextureManager().bindTexture(new ResourceLocation("vivecraft:textures/white.png"));
+	
+	  		Tessellator tes = Tessellator.getInstance();
+	
+	
+	  		if(depthAlways && c == 0) //this ensures the pointer hand is visble while not interfering with the other hand.
+	  			RenderSystem.depthFunc(GL11.GL_ALWAYS);		
+	  		else
+	  			RenderSystem.depthFunc(GL11.GL_LEQUAL);		
+	
+	  		Vector3i color = new Vector3i((200 - 127 * c), (200 - 127 * c), (200 - 127 * c));
+	  		byte alpha = (byte) 255;
+	
+	  		RenderSystem.pushMatrix();
+	
+	  		SetupRenderingAtControllerLegacy(c);
+	
+	  		Vector3d start = new Vector3d(0,0,0);
+	
+	  		Vector3d dir = mc.vrPlayer.vrdata_world_render.getController(c).getDirection();
+	  		Vector3d up = mc.vrPlayer.vrdata_world_render.getController(c).getCustomVector(new Vector3d(0, 1, 0));
+	
+	  		up = new Vector3d(0,1,0);
+	  		dir = new Vector3d(0,0,-1);
+	
+	  		Vector3d end = new Vector3d(
+	  				start.x - dir.x*.18,
+	  				start.y - dir.y*.18,
+	  				start.z - dir.z*.18);
+	
+	  		if(mc.world!= null) {
+	  			float light = mc.world.getLight(new BlockPos(mc.vrPlayer.vrdata_world_render.hmd.getPosition()));
+	  			int minLight = Config.isShaders() ? 8 : 4;
+	  			if (light < minLight) light = minLight;
+	  			float lightpercent = light / mc.world.getMaxLightLevel();
+	  			color = new Vector3i(color.getX() * lightpercent, color.getY() * lightpercent, color.getZ() * lightpercent);
+	  		}
+	
+	  		tes.getBuffer().begin(7, DefaultVertexFormats.POSITION_COLOR_NORMAL);
+	  		renderBox(tes, start, end, -0.02f, 0.02f, -0.0125f, 0.0125f, up, color, alpha);
+	  		tes.getBuffer().finishDrawing();
+	  		WorldVertexBufferUploader.draw(tes.getBuffer());
+	  		RenderSystem.popMatrix();     
+	
+	  		RenderSystem.enableTexture();
+  		RenderSystem.popMatrix();
+  		RenderSystem.depthFunc(GL11.GL_LEQUAL);
+  	}
+
+    
+    public void setupClipPlanes() {
+        this.farPlaneDistance = (float)(this.mc.gameSettings.renderDistanceChunks * 16);
+
+        if (Config.isFogFancy())
+        {
+            this.farPlaneDistance *= 0.95F;
+        }
+
+        if (Config.isFogFast())
+        {
+            this.farPlaneDistance *= 0.83F;
+        }
+        
+        this.clipDistance = this.farPlaneDistance * 2.0F;
+
+        if (this.clipDistance < 173.0F)
+        {
+            this.clipDistance = 173.0F;
+        }
+        
+    }
+    
+    private void renderFaceOverlay(float par1){ //replaced with shader - and unreplaced!
+    	boolean shadersMod = Config.isShaders();
+    	if (shadersMod) {
+    		//just disables caps
+    		Shaders.beginFPOverlay();
+    	}
+
+    	if(inBlock > 0) {
+    		renderFaceInBlock();
+      		renderGuiLayer(par1, true);  
+      		if(KeyboardHandler.Showing) {
+      			if (mc.vrSettings.physicalKeyboard)
+      				renderPhysicalKeyboard(par1);
+      			else
+      				render2D(par1, KeyboardHandler.Framebuffer, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room, true);
+      		}
+      		if(RadialHandler.isShowing())
+      			render2D(par1, RadialHandler.Framebuffer, RadialHandler.Pos_room, RadialHandler.Rotation_room, true);
+        	if(inBlock >= 1) 
+        		renderVRHands(par1, true, true, true, true);
+    	}
+    	
+    	if (shadersMod) {
+    		//does nothing at all.
+    		Shaders.endFPOverlay();
+    	}
+    }
+    
+    private void renderFaceInBlock() {
+        Tessellator tessellator = Tessellator.getInstance();
+        BufferBuilder bufferbuilder = tessellator.getBuffer();
+        
+        GlStateManager.color4f(0f, 0F, 0F, mc.gameRenderer.inBlock);
+        
+        GlStateManager.matrixMode(GL11.GL_PROJECTION);
+        GlStateManager.pushMatrix();
+        	GlStateManager.loadIdentity();
+	        GlStateManager.ortho(0.0D, 1, 0, 1, 0, 100);
+	        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+	        GlStateManager.pushMatrix();
+		        GlStateManager.loadIdentity();
+		        
+		        GlStateManager.disableDepthTest();
+		        GlStateManager.disableTexture();
+		        GlStateManager.enableBlend();	               
+		        GlStateManager.disableCull();
+
+		        bufferbuilder.begin(7, DefaultVertexFormats.POSITION);
+		        bufferbuilder.pos(-1 ,-1, 0).endVertex();
+		        bufferbuilder.pos(2, -1, 0).endVertex();
+		        bufferbuilder.pos(2, 2, 0).endVertex();
+		        bufferbuilder.pos(-1, 2, 0).endVertex();
+		        tessellator.draw();
+		        
+
+	        GlStateManager.matrixMode(GL11.GL_PROJECTION);
+	        GlStateManager.popMatrix();
+        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+        GlStateManager.popMatrix();
+        
+        //GlStateManager.enableDepth();
+        GlStateManager.enableTexture();
+        GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+    }
+    
+    private void renderFireInFirstPerson()
+    { 
+    	MatrixStack matrixStackIn = new MatrixStack();
+    	applyVRModelView(mc.currentPass, matrixStackIn);
+    	applystereo(mc.currentPass, matrixStackIn);
+    	BufferBuilder bufferbuilder = Tessellator.getInstance().getBuffer();
+    	RenderSystem.depthFunc(GL11.GL_ALWAYS);
+  		if(mc.currentPass == RenderPass.THIRD || mc.currentPass == RenderPass.CAMERA)
+  			GlStateManager.depthFunc(GL11.GL_LEQUAL);
+    	RenderSystem.enableBlend();
+    	RenderSystem.defaultBlendFunc();
+    	TextureAtlasSprite textureatlassprite = ModelBakery.LOCATION_FIRE_1.getSprite();
+    	RenderSystem.enableDepthTest();
+    	if (SmartAnimations.isActive())
+    	{
+    		SmartAnimations.spriteRendered(textureatlassprite);
+    	}
+
+    	mc.getTextureManager().bindTexture(textureatlassprite.getAtlasTexture().getTextureLocation());
+    	float f = textureatlassprite.getMinU();
+    	float f1 = textureatlassprite.getMaxU();
+    	float f2 = (f + f1) / 2.0F;
+    	float f3 = textureatlassprite.getMinV();
+    	float f4 = textureatlassprite.getMaxV();
+    	float f5 = (f3 + f4) / 2.0F;
+    	float f6 = textureatlassprite.getUvShrinkRatio();
+    	float f7 = MathHelper.lerp(f6, f, f2);
+    	float f8 = MathHelper.lerp(f6, f1, f2);
+    	float f9 = MathHelper.lerp(f6, f3, f5);
+    	float f10 = MathHelper.lerp(f6, f4, f5);
+    	float f11 = 1.0F;
+
+
+        float a = 0.3f;  
+        float b = (float) (mc.vrPlayer.vrdata_world_render.getHeadPivot().y - mc.gameRenderer.rveY);
+    	
+    	for (int i = 0; i < 4; ++i)
+    	{
+    		matrixStackIn.push();
+    		
+	    		matrixStackIn.rotate(Vector3f.YP.rotationDegrees(i * 90.0F - mc.vrPlayer.vrdata_world_render.getBodyYaw()));
+	            matrixStackIn.translate(0, -b, 0.0F);
+	            
+	    		Matrix4f matrix4f = matrixStackIn.getLast().getMatrix();
+	    		bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR_TEX);
+	    		bufferbuilder.pos(matrix4f, -a, 0, -a).color(1.0F, 1.0F, 1.0F, 0.9F).tex(f8, f10).endVertex();
+	    		bufferbuilder.pos(matrix4f, a, 0, -a).color(1.0F, 1.0F, 1.0F, 0.9F).tex(f7, f10).endVertex();
+	    		bufferbuilder.pos(matrix4f, a, b, -a).color(1.0F, 1.0F, 1.0F, 0.9F).tex(f7, f9).endVertex();
+	    		bufferbuilder.pos(matrix4f, -a, b, -a).color(1.0F, 1.0F, 1.0F, 0.9F).tex(f8, f9).endVertex();
+	    		bufferbuilder.finishDrawing();
+	    		WorldVertexBufferUploader.draw(bufferbuilder);
+    		matrixStackIn.pop();
+    	}
+    	
+    	RenderSystem.depthFunc(GL11.GL_LEQUAL);
+    	RenderSystem.disableBlend();
+    }
+    
+    public void renderVRFabulous(float partialTicks, WorldRenderer worldrendererin, boolean menuhandright, boolean menuhandleft) {
+        this.mc.getProfiler().endStartSection("VR");
+
+        renderCrosshairAtDepth(!this.mc.vrSettings.useCrosshairOcclusion);
+        
+        mc.getFramebuffer().unbindFramebuffer();
+        worldrendererin.alphaSortVROccludedFramebuffer.framebufferClear(Minecraft.IS_RUNNING_ON_MAC);
+        worldrendererin.alphaSortVROccludedFramebuffer.func_237506_a_(this.mc.getFramebuffer());
+        worldrendererin.alphaSortVROccludedFramebuffer.bindFramebuffer(true);
+
+        if(shouldOccludeGui()) {
+        	renderGuiLayer(partialTicks, false);
+      		renderVrShadow(partialTicks, false);
+      		if(KeyboardHandler.Showing) {
+      			if (mc.vrSettings.physicalKeyboard)
+      				renderPhysicalKeyboard(partialTicks);
+      			else
+      				render2D(partialTicks, KeyboardHandler.Framebuffer, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room, false);
+      		}
+      		if(RadialHandler.isShowing())
+      			render2D(partialTicks, RadialHandler.Framebuffer, RadialHandler.Pos_room, RadialHandler.Rotation_room, false);
+        }
+
+        worldrendererin.alphaSortVRUnoccludedFramebuffer.framebufferClear(Minecraft.IS_RUNNING_ON_MAC);
+        //no dont do it. this.alphaSortVRUnoccludedFramebuffer.func_237506_a_(this.mc.getFramebuffer());
+        worldrendererin.alphaSortVRUnoccludedFramebuffer.bindFramebuffer(true);
+
+        if(!shouldOccludeGui()) {
+        	renderGuiLayer(partialTicks, false);
+      		renderVrShadow(partialTicks, false);
+      		if(KeyboardHandler.Showing) {
+      			if (mc.vrSettings.physicalKeyboard)
+      				renderPhysicalKeyboard(partialTicks);
+      			else
+      				render2D(partialTicks, KeyboardHandler.Framebuffer, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room, false);
+      		}
+      		if(RadialHandler.isShowing())
+      			render2D(partialTicks, RadialHandler.Framebuffer, RadialHandler.Pos_room, RadialHandler.Rotation_room, false);
+        }
+
+    
+  		renderVRSelfEffects(partialTicks);
+  		VRWidgetHelper.renderVRThirdPersonCamWidget();
+        VRWidgetHelper.renderVRHandheldCameraWidget();
+  		
+  		boolean should = shouldRenderHands();
+  		
+    	renderVRHands(partialTicks, should && menuhandright, should && menuhandleft, true, true);
+	
+    	worldrendererin.alphaSortVRHandsFramebuffer.framebufferClear(Minecraft.IS_RUNNING_ON_MAC);
+    	worldrendererin.alphaSortVRHandsFramebuffer.func_237506_a_(this.mc.getFramebuffer());
+    	worldrendererin.alphaSortVRHandsFramebuffer.bindFramebuffer(true);
+        
+    	renderVRHands(partialTicks, should && !menuhandright, should && !menuhandleft, false, false);
+
+        RenderSystem.enableTexture();
+        RenderSystem.defaultBlendFunc();
+        RenderSystem.defaultAlphaFunc();
+        RenderSystem.color4f(1, 1, 1, 1);
+        RenderHelper.enableStandardItemLighting();
+        RenderHelper.disableStandardItemLighting();
+        mc.getFramebuffer().bindFramebuffer(true);
+    }
+    
+    public void renderVrFast(float partialTicks, boolean secondpass, boolean menuright, boolean menuleft) {
+        this.mc.getProfiler().endStartSection("VR");
+        lightmapTexture.disableLightmap();
+        
+    	if(secondpass) renderVrShadow(partialTicks, !shouldOccludeGui());
+        if(!secondpass) renderCrosshairAtDepth(!mc.vrSettings.useCrosshairOcclusion);
+        if(!secondpass) VRWidgetHelper.renderVRThirdPersonCamWidget();
+        if(!secondpass) VRWidgetHelper.renderVRHandheldCameraWidget();
+    	
+        if(secondpass)renderGuiLayer(partialTicks, !shouldOccludeGui());  
+  		if(secondpass && KeyboardHandler.Showing) {
+  			if (mc.vrSettings.physicalKeyboard)
+  				renderPhysicalKeyboard(partialTicks);
+  			else
+  				render2D(partialTicks, KeyboardHandler.Framebuffer, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room, !shouldOccludeGui());
+  		}
+  		if(secondpass && RadialHandler.isShowing())
+  			render2D(partialTicks, RadialHandler.Framebuffer, RadialHandler.Pos_room, RadialHandler.Rotation_room, !shouldOccludeGui());
+
+   	
+	    renderVRHands(partialTicks, shouldRenderHands(), shouldRenderHands(), menuright, menuleft);
+    	
+    	renderVRSelfEffects(partialTicks);
+    }
+    
+  	// VIVE END - render functions
 }

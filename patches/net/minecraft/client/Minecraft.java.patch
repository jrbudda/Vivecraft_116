--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -7,20 +7,34 @@
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.properties.PropertyMap;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import com.mojang.blaze3d.platform.GLX;
+import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.GlStateManager.FogMode;
 import com.mojang.blaze3d.platform.PlatformDescriptors;
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.datafixers.DataFixer;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Queue;
@@ -32,10 +46,52 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import net.minecraft.state.EnumProperty;
+import net.minecraft.state.StateContainer;
+import net.minecraft.util.*;
+import net.minecraft.util.Timer;
+import net.optifine.Config;
+import net.optifine.CustomItems;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.TextureUtils;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
+import org.lwjgl.opengl.GL30;
+import org.vivecraft.api.ErrorHelper;
+import org.vivecraft.api.NetworkHelper;
+import org.vivecraft.control.VRInputAction;
+import org.vivecraft.gameplay.OpenVRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.KeyboardHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.*;
+import org.vivecraft.gui.physical.PhysicalGuiManager;
+import org.vivecraft.menuworlds.MenuWorldRenderer;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.provider.OpenVRStereoRenderer;
+import org.vivecraft.render.PlayerModelController;
+import org.vivecraft.render.RenderConfigException;
+import org.vivecraft.render.VRShaders;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.VRFirstPersonArmSwing;
+import org.vivecraft.settings.AutoCalibration;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.settings.VRSettings.VrOptions;
+import org.vivecraft.utils.*;
+import org.vivecraft.utils.lwjgl.Matrix4f;
+import org.vivecraft.utils.math.Vector3;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockRenderType;
 import net.minecraft.block.BlockState;
 import net.minecraft.client.audio.MusicTicker;
+import net.minecraft.client.audio.SoundEngine;
 import net.minecraft.client.audio.SoundHandler;
 import net.minecraft.client.entity.player.ClientPlayerEntity;
 import net.minecraft.client.gui.FontRenderer;
@@ -74,12 +130,15 @@
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.FirstPersonRenderer;
 import net.minecraft.client.renderer.FogRenderer;
+import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GameRenderer;
 import net.minecraft.client.renderer.IWindowEventListener;
 import net.minecraft.client.renderer.ItemRenderer;
+import net.minecraft.client.renderer.RenderHelper;
 import net.minecraft.client.renderer.RenderTypeBuffers;
 import net.minecraft.client.renderer.ScreenSize;
 import net.minecraft.client.renderer.Tessellator;
+import net.minecraft.client.renderer.Vector3f;
 import net.minecraft.client.renderer.VirtualScreen;
 import net.minecraft.client.renderer.WorldRenderer;
 import net.minecraft.client.renderer.color.BlockColors;
@@ -109,6 +168,7 @@
 import net.minecraft.client.settings.CreativeSettings;
 import net.minecraft.client.settings.KeyBinding;
 import net.minecraft.client.shader.Framebuffer;
+import net.minecraft.client.shader.FramebufferConstants;
 import net.minecraft.client.tutorial.Tutorial;
 import net.minecraft.client.util.IMutableSearchTree;
 import net.minecraft.client.util.ITooltipFlag;
@@ -185,6 +245,7 @@
 import net.minecraft.util.math.EntityRayTraceResult;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.util.registry.Bootstrap;
 import net.minecraft.util.registry.Registry;
 import net.minecraft.util.text.ITextComponent;
@@ -202,12 +263,83 @@
 import net.minecraft.world.storage.SaveFormat;
 import net.minecraft.world.storage.SaveHandler;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorConstructor;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class Minecraft extends RecursiveEventLoop<Runnable> implements ISnooperInfo, IWindowEventListener
 {
     private static Minecraft instance;
+	// VIVE START - teleport movement
+	public OpenVRPlayer vrPlayer;
+	public BackpackTracker backpackTracker = new BackpackTracker(this);
+	public BowTracker bowTracker = new BowTracker(this);
+	public SwimTracker swimTracker = new SwimTracker(this);
+	public EatingTracker autoFood = new EatingTracker(this);
+	public JumpTracker jumpTracker = new JumpTracker(this);
+	public SneakTracker sneakTracker = new SneakTracker(this);
+	public ClimbTracker climbTracker = new ClimbTracker(this);
+	public RunTracker runTracker = new RunTracker(this);
+	public RowTracker rowTracker = new RowTracker(this);
+	public TeleportTracker teleportTracker = new TeleportTracker(this);
+	public SwingTracker swingTracker = new SwingTracker(this);
+	public HorseTracker horseTracker = new HorseTracker(this);
+	public VehicleTracker vehicleTracker = new VehicleTracker(this);
+	public PhysicalGuiManager physicalGuiManager = new PhysicalGuiManager(this);
+	public InteractTracker interactTracker = new InteractTracker(this);
+
+	public ThreadGroup backgroundThreadGroup = new ThreadGroup("background");
+	// VIVE END - teleport movement
+
+	/** MINECRIFT */
+
+	public boolean minecriftDebug = false;
+	public final float PIOVER180 = (float) (Math.PI / 180);
+
+	public int lastShaderIndex = -1;
+	public Field fieldHwnd = null;
+	public Field fieldDisplay = null;
+	public Field fieldWindow = null;
+	public Field fieldResized = null;
+	public Method fieldResizedMethod = null;
+	public OpenVRStereoRenderer stereoProvider;
+	public VRSettings vrSettings;
+	public long lastIntegratedServerLaunchCheck = 0;
+	public boolean integratedServerLaunchInProgress = false;
+
+	public boolean grabScreenShot = false;
+	public boolean lastShowMouseNative = true;
+	public boolean enableWorldExport = false;
+	public SoundEngine sndManager = null;
+	public MenuWorldRenderer menuWorldRenderer;
+
+	private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+	private FloatBuffer matrixBuffer2 = GLAllocation.createDirectFloatBuffer(16);
+
+	private boolean firstInit = true;
+	public boolean showSplashScreen = true;
+	public long splashTimer1 = 0;
+	public long splashTimer2 = 0;
+	private Framebuffer splash;
+	private float splashFadeAlpha = 0;
+	public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+	public long medianRunTickTimeNanos = 0;
+	public long frameIndex = 0;
+	public ErrorHelper errorHelper;
+	public RenderPass currentPass;
+	private boolean lastClick;
+	public boolean resourcePacksChanged;
+
+	public int tickCounter;
+	/*
+	 * The minecriftVerString will be automatically updated by the build scripts, do
+	 * not modify here. Modify minecriftversion.py in root minecrift dir.
+	 */
+    public final String minecriftVerString = "Vivecraft 1.15.2 jrbudda-3-a1";
+	/* end version */
+	/** END MINECRIFT */
     private static final Logger LOGGER = LogManager.getLogger();
     public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.OS.OSX;
     public static final ResourceLocation DEFAULT_FONT_RENDERER_NAME = new ResourceLocation("default");
@@ -234,7 +366,7 @@
     public final DebugRenderer debugRenderer;
     private final AtomicReference<TrackingChunkStatusListener> refChunkStatusListener = new AtomicReference<>();
     public final IngameGui ingameGUI;
-    public final GameSettings gameSettings;
+    public GameSettings gameSettings;
     private final CreativeSettings creativeSettings;
     public final MouseHelper mouseHelper;
     public final KeyboardListener keyboardListener;
@@ -256,7 +388,7 @@
     private final LanguageManager languageManager;
     private final BlockColors blockColors;
     private final ItemColors itemColors;
-    private final Framebuffer framebuffer;
+    public Framebuffer framebuffer;
     private final SoundHandler soundHandler;
     private final MusicTicker musicTicker;
     private final FontResourceManager fontResourceMananger;
@@ -267,7 +399,7 @@
     private final BlockRendererDispatcher blockRenderDispatcher;
     private final PaintingSpriteUploader paintingSprites;
     private final PotionSpriteUploader potionSprites;
-    private final ToastGui toastGui;
+    public final ToastGui toastGui;
     private final MinecraftGame game = new MinecraftGame(this);
     private final Tutorial tutorial;
     public static byte[] memoryReserve = new byte[10485760];
@@ -320,194 +452,271 @@
 
     public Minecraft(GameConfiguration p_i801_1_)
     {
-        super("Client");
-        instance = this;
-        this.gameDir = p_i801_1_.folderInfo.gameDir;
-        File file1 = p_i801_1_.folderInfo.assetsDir;
-        this.fileResourcepacks = p_i801_1_.folderInfo.resourcePacksDir;
-        this.launchedVersion = p_i801_1_.gameInfo.version;
-        this.versionType = p_i801_1_.gameInfo.versionType;
-        this.profileProperties = p_i801_1_.userInfo.profileProperties;
-        this.packFinder = new DownloadingPackFinder(new File(this.gameDir, "server-resource-packs"), p_i801_1_.folderInfo.getAssetsIndex());
-        this.resourcePackRepository = new ResourcePackList<>(Minecraft::makePackInfo);
-        this.resourcePackRepository.addPackFinder(this.packFinder);
-        this.resourcePackRepository.addPackFinder(new FolderPackFinder(this.fileResourcepacks));
-        this.proxy = p_i801_1_.userInfo.proxy;
-        this.sessionService = (new YggdrasilAuthenticationService(this.proxy, UUID.randomUUID().toString())).createMinecraftSessionService();
-        this.session = p_i801_1_.userInfo.session;
-        LOGGER.info("Setting user: {}", (Object)this.session.getUsername());
-        LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
-        this.isDemo = p_i801_1_.gameInfo.isDemo;
-        this.jvm64bit = isJvm64bit();
-        this.integratedServer = null;
-        String s;
-        int i;
-
-        if (p_i801_1_.serverInfo.serverName != null)
-        {
-            s = p_i801_1_.serverInfo.serverName;
-            i = p_i801_1_.serverInfo.serverPort;
-        }
-        else
-        {
-            s = null;
-            i = 0;
-        }
-
-        Bootstrap.register();
-        Bootstrap.checkTranslations();
-        KeybindTextComponent.displaySupplierFunction = KeyBinding::getDisplayString;
-        this.dataFixer = DataFixesManager.getDataFixer();
-        this.toastGui = new ToastGui(this);
-        this.tutorial = new Tutorial(this);
-        this.thread = Thread.currentThread();
-        this.gameSettings = new GameSettings(this, this.gameDir);
-        this.creativeSettings = new CreativeSettings(this.gameDir, this.dataFixer);
-        this.startTimerHackThread();
-        LOGGER.info("Backend library: {}", (Object)RenderSystem.getBackendDescription());
-        ScreenSize screensize;
-
-        if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0)
-        {
-            screensize = new ScreenSize(this.gameSettings.overrideWidth, this.gameSettings.overrideHeight, p_i801_1_.displayInfo.fullscreenWidth, p_i801_1_.displayInfo.fullscreenHeight, p_i801_1_.displayInfo.fullscreen);
-        }
-        else
-        {
-            screensize = p_i801_1_.displayInfo;
-        }
-
-        Util.nanoTimeSupplier = RenderSystem.initBackendSystem();
-        this.virtualScreen = new VirtualScreen(this);
-        this.mainWindow = this.virtualScreen.create(screensize, this.gameSettings.fullscreenResolution, this.func_230149_ax_());
-        this.setGameFocused(true);
-
-        try
-        {
-            InputStream inputstream = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_16x16.png"));
-            InputStream inputstream1 = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_32x32.png"));
-            this.mainWindow.setWindowIcon(inputstream, inputstream1);
-        }
-        catch (IOException ioexception)
-        {
-            LOGGER.error("Couldn't set icon", (Throwable)ioexception);
-        }
-
-        this.mainWindow.setFramerateLimit(this.gameSettings.framerateLimit);
-        this.mouseHelper = new MouseHelper(this);
-        this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
-        this.keyboardListener = new KeyboardListener(this);
-        this.keyboardListener.setupCallbacks(this.mainWindow.getHandle());
-        RenderSystem.initRenderer(this.gameSettings.glDebugVerbosity, false);
-        this.framebuffer = new Framebuffer(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), true, IS_RUNNING_ON_MAC);
-        this.framebuffer.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
-        this.resourceManager = new SimpleReloadableResourceManager(ResourcePackType.CLIENT_RESOURCES, this.thread);
-        this.gameSettings.fillResourcePackList(this.resourcePackRepository);
-        this.resourcePackRepository.reloadPacksFromFinders();
-        this.languageManager = new LanguageManager(this.gameSettings.language);
-        this.resourceManager.addReloadListener(this.languageManager);
-        this.textureManager = new TextureManager(this.resourceManager);
-        this.resourceManager.addReloadListener(this.textureManager);
-        this.skinManager = new SkinManager(this.textureManager, new File(file1, "skins"), this.sessionService);
-        this.saveFormat = new SaveFormat(this.gameDir.toPath().resolve("saves"), this.gameDir.toPath().resolve("backups"), this.dataFixer);
-        this.soundHandler = new SoundHandler(this.resourceManager, this.gameSettings);
-        this.resourceManager.addReloadListener(this.soundHandler);
-        this.splashes = new Splashes(this.session);
-        this.resourceManager.addReloadListener(this.splashes);
-        this.musicTicker = new MusicTicker(this);
-        this.fontResourceMananger = new FontResourceManager(this.textureManager, this.getForceUnicodeFont());
-        this.resourceManager.addReloadListener(this.fontResourceMananger.getReloadListener());
-        FontRenderer fontrenderer = this.fontResourceMananger.getFontRenderer(DEFAULT_FONT_RENDERER_NAME);
-
-        if (fontrenderer == null)
-        {
-            throw new IllegalStateException("Default font is null");
-        }
-        else
-        {
-            this.fontRenderer = fontrenderer;
-            this.fontRenderer.setBidiFlag(this.languageManager.isCurrentLanguageBidirectional());
-            this.resourceManager.addReloadListener(new GrassColorReloadListener());
-            this.resourceManager.addReloadListener(new FoliageColorReloadListener());
-            this.mainWindow.setRenderPhase("Startup");
-            RenderSystem.setupDefaultState(0, 0, this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
-            this.mainWindow.setRenderPhase("Post startup");
-            this.blockColors = BlockColors.init();
-            this.itemColors = ItemColors.init(this.blockColors);
-            this.modelManager = new ModelManager(this.textureManager, this.blockColors, this.gameSettings.mipmapLevels);
-            this.resourceManager.addReloadListener(this.modelManager);
-            this.itemRenderer = new ItemRenderer(this.textureManager, this.modelManager, this.itemColors);
-            this.renderManager = new EntityRendererManager(this.textureManager, this.itemRenderer, this.resourceManager, this.fontRenderer, this.gameSettings);
-            this.firstPersonRenderer = new FirstPersonRenderer(this);
-            this.resourceManager.addReloadListener(this.itemRenderer);
-            this.renderTypeBuffers = new RenderTypeBuffers();
-            this.gameRenderer = new GameRenderer(this, this.resourceManager, this.renderTypeBuffers);
-            this.resourceManager.addReloadListener(this.gameRenderer);
-            this.blockRenderDispatcher = new BlockRendererDispatcher(this.modelManager.getBlockModelShapes(), this.blockColors);
-            this.resourceManager.addReloadListener(this.blockRenderDispatcher);
-            this.worldRenderer = new WorldRenderer(this, this.renderTypeBuffers);
-            this.resourceManager.addReloadListener(this.worldRenderer);
-            this.populateSearchTreeManager();
-            this.resourceManager.addReloadListener(this.searchTreeManager);
-            this.particles = new ParticleManager(this.world, this.textureManager);
-            this.resourceManager.addReloadListener(this.particles);
-            this.paintingSprites = new PaintingSpriteUploader(this.textureManager);
-            this.resourceManager.addReloadListener(this.paintingSprites);
-            this.potionSprites = new PotionSpriteUploader(this.textureManager);
-            this.resourceManager.addReloadListener(this.potionSprites);
-            this.ingameGUI = new IngameGui(this);
-            this.debugRenderer = new DebugRenderer(this);
-            RenderSystem.setErrorCallback(this::disableVSyncAfterGlError);
-
-            if (this.gameSettings.fullscreen && !this.mainWindow.isFullscreen())
-            {
-                this.mainWindow.toggleFullscreen();
-                this.gameSettings.fullscreen = this.mainWindow.isFullscreen();
-            }
-
-            this.mainWindow.setVsync(this.gameSettings.vsync);
-            this.mainWindow.setRawMouseInput(this.gameSettings.rawMouseInput);
-            this.mainWindow.setLogOnGlError();
-            this.updateWindowSize();
-
-            if (s != null)
-            {
-                this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, s, i));
-            }
-            else
-            {
-                this.displayGuiScreen(new MainMenuScreen(true));
-            }
-
-            ResourceLoadProgressGui.loadLogoTexture(this);
-            List<IResourcePack> list = this.resourcePackRepository.getEnabledPacks().stream().map(ResourcePackInfo::getResourcePack).collect(Collectors.toList());
-            this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (p_229990_2_) ->
-            {
-                Util.acceptOrElse(p_229990_2_, this::restoreResourcePacks, () -> {
-                    this.languageManager.parseLanguageMetadata(list);
-
-                    if (SharedConstants.developmentMode)
-                    {
-                        this.checkMissingData();
-                    }
-                });
-            }, false));
-        }
+    	super("Client");
+    	instance = this;
+    	//Forge
+    	Reflector.call(Reflector.ForgeHooksClient_invalidateLog4jThreadCache);
+    	//
+    	this.gameDir = p_i801_1_.folderInfo.gameDir;
+    	File file1 = p_i801_1_.folderInfo.assetsDir;
+    	this.fileResourcepacks = p_i801_1_.folderInfo.resourcePacksDir;
+    	this.launchedVersion = p_i801_1_.gameInfo.version;
+    	this.versionType = p_i801_1_.gameInfo.versionType;
+    	this.profileProperties = p_i801_1_.userInfo.profileProperties;
+    	this.packFinder = new DownloadingPackFinder(new File(this.gameDir, "server-resource-packs"), p_i801_1_.folderInfo.getAssetsIndex());
+    	this.resourcePackRepository = new ResourcePackList<>(Minecraft::makePackInfo);
+    	this.resourcePackRepository.addPackFinder(this.packFinder);
+    	this.resourcePackRepository.addPackFinder(new FolderPackFinder(this.fileResourcepacks));
+    	this.proxy = p_i801_1_.userInfo.proxy;
+    	this.sessionService = (new YggdrasilAuthenticationService(this.proxy, UUID.randomUUID().toString())).createMinecraftSessionService();
+    	this.session = p_i801_1_.userInfo.session;
+    	LOGGER.info("Setting user: {}", (Object)this.session.getUsername());
+    	//Forge
+    	//LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
+    	//
+    	this.isDemo = p_i801_1_.gameInfo.isDemo;
+    	this.jvm64bit = isJvm64bit();
+    	this.integratedServer = null;
+    	String s;
+    	int i;
+
+    	if (p_i801_1_.serverInfo.serverName != null)
+    	{
+    		s = p_i801_1_.serverInfo.serverName;
+    		i = p_i801_1_.serverInfo.serverPort;
+    	}
+    	else
+    	{
+    		s = null;
+    		i = 0;
+    	}
+
+    	Bootstrap.register();
+    	Bootstrap.checkTranslations();
+    	KeybindTextComponent.displaySupplierFunction = KeyBinding::getDisplayString;
+    	this.dataFixer = DataFixesManager.getDataFixer();
+    	this.toastGui = new ToastGui(this);
+    	this.tutorial = new Tutorial(this);
+
+    	/** MINECRIFT **/
+    	VRSettings.initSettings(this, gameDir);
+    	if (!vrSettings.badStereoProviderPluginID.isEmpty()) {
+    		vrSettings.stereoProviderPluginID = vrSettings.badStereoProviderPluginID;
+    		vrSettings.badStereoProviderPluginID = "";
+    		vrSettings.saveOptions();
+    	}
+    	/** END MINECRIFT **/
+
+    	this.thread = Thread.currentThread();
+    	this.gameSettings = new GameSettings(this, this.gameDir);
+    	this.creativeSettings = new CreativeSettings(this.gameDir, this.dataFixer);
+    	this.startTimerHackThread();
+    	LOGGER.info("Backend library: {}", (Object)RenderSystem.getBackendDescription());
+    	ScreenSize screensize;
+
+    	if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0)
+    	{
+    		screensize = new ScreenSize(this.gameSettings.overrideWidth, this.gameSettings.overrideHeight, p_i801_1_.displayInfo.fullscreenWidth, p_i801_1_.displayInfo.fullscreenHeight, p_i801_1_.displayInfo.fullscreen);
+    	}
+    	else
+    	{
+    		screensize = p_i801_1_.displayInfo;
+    	}
+
+    	//Forge - uh what?
+    	Reflector.call(Reflector.getFieldValue(Reflector.EarlyProgressVisualization_INSTANCE), Reflector.EarlyProgressVisualization_join);
+    	//
+
+    	Util.nanoTimeSupplier = RenderSystem.initBackendSystem();
+    	this.virtualScreen = new VirtualScreen(this);
+    	this.mainWindow = this.virtualScreen.create(screensize, this.gameSettings.fullscreenResolution, this.func_230149_ax_());
+    	this.setGameFocused(true);
+
+    	try
+    	{
+    		InputStream inputstream = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_16x16.png"));
+    		InputStream inputstream1 = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_32x32.png"));
+    		this.mainWindow.setWindowIcon(inputstream, inputstream1);
+    	}
+    	catch (IOException ioexception)
+    	{
+    		LOGGER.error("Couldn't set icon", (Throwable)ioexception);
+    	}
+
+    	this.mainWindow.setFramerateLimit(this.gameSettings.framerateLimit);
+    	this.mouseHelper = new MouseHelper(this);
+    	this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
+    	//this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
+    	//
+    	this.keyboardListener = new KeyboardListener(this);
+    	this.keyboardListener.setupCallbacks(this.mainWindow.getHandle());
+    	RenderSystem.initRenderer(this.gameSettings.glDebugVerbosity, false);
+    	//I would prefer to comment this out to ensure it isnt used, but Forge needs it or whatever.
+    	this.framebuffer = new Framebuffer(this.mainWindow.getWidth(), this.mainWindow.getHeight(), true, IS_RUNNING_ON_MAC);
+    	this.framebuffer.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
+    	
+    	this.resourceManager = new SimpleReloadableResourceManager(ResourcePackType.CLIENT_RESOURCES, this.thread);
+    	//Forge
+    	Reflector.call(Reflector.ClientModLoader_begin, this, this.resourcePackRepository, this.resourceManager, this.packFinder);
+    	//
+    	this.gameSettings.fillResourcePackList(this.resourcePackRepository);
+    	this.resourcePackRepository.reloadPacksFromFinders();
+    	this.languageManager = new LanguageManager(this.gameSettings.language);
+    	this.resourceManager.addReloadListener(this.languageManager);
+    	this.textureManager = new TextureManager(this.resourceManager);
+    	this.resourceManager.addReloadListener(this.textureManager);
+    	this.skinManager = new SkinManager(this.textureManager, new File(file1, "skins"), this.sessionService);
+    	this.saveFormat = new SaveFormat(this.gameDir.toPath().resolve("saves"), this.gameDir.toPath().resolve("backups"), this.dataFixer);
+    	this.soundHandler = new SoundHandler(this.resourceManager, this.gameSettings);
+    	this.resourceManager.addReloadListener(this.soundHandler);
+    	this.splashes = new Splashes(this.session);
+    	this.resourceManager.addReloadListener(this.splashes);
+    	this.musicTicker = new MusicTicker(this);
+    	this.fontResourceMananger = new FontResourceManager(this.textureManager, this.getForceUnicodeFont());
+    	this.resourceManager.addReloadListener(this.fontResourceMananger.getReloadListener());
+    	FontRenderer fontrenderer = this.fontResourceMananger.getFontRenderer(DEFAULT_FONT_RENDERER_NAME);
+
+    	if (fontrenderer == null)
+    	{
+    		throw new IllegalStateException("Default font is null");
+    	}
+    	else
+    	{
+    		this.fontRenderer = fontrenderer;
+    		this.fontRenderer.setBidiFlag(this.languageManager.isCurrentLanguageBidirectional());
+
+    		/** MINECRIFT */
+    		try {
+    			initMinecrift();
+    		} catch (Exception e) {
+    			e.printStackTrace();
+    		}
+    		/** END MINECRIFT */
+
+    		this.resourceManager.addReloadListener(new GrassColorReloadListener());
+    		this.resourceManager.addReloadListener(new FoliageColorReloadListener());
+    		this.mainWindow.setRenderPhase("Startup");
+    		RenderSystem.setupDefaultState(0, 0, this.mainWindow.getWidth(), this.mainWindow.getHeight());
+    		this.mainWindow.setRenderPhase("Post startup");
+    		this.blockColors = BlockColors.init();
+    		this.itemColors = ItemColors.init(this.blockColors);
+    		this.modelManager = new ModelManager(this.textureManager, this.blockColors, this.gameSettings.mipmapLevels);
+    		this.resourceManager.addReloadListener(this.modelManager);
+    		this.itemRenderer = new ItemRenderer(this.textureManager, this.modelManager, this.itemColors);
+    		this.renderManager = new EntityRendererManager(this.textureManager, this.itemRenderer, this.resourceManager, this.fontRenderer, this.gameSettings);
+    		this.firstPersonRenderer = new FirstPersonRenderer(this);
+    		this.resourceManager.addReloadListener(this.itemRenderer);
+    		this.renderTypeBuffers = new RenderTypeBuffers();
+    		this.gameRenderer = new GameRenderer(this, this.resourceManager, this.renderTypeBuffers);
+    		this.resourceManager.addReloadListener(this.gameRenderer);
+    		this.blockRenderDispatcher = new BlockRendererDispatcher(this.modelManager.getBlockModelShapes(), this.blockColors);
+    		this.resourceManager.addReloadListener(this.blockRenderDispatcher);
+    		this.worldRenderer = new WorldRenderer(this, this.renderTypeBuffers);
+    		this.resourceManager.addReloadListener(this.worldRenderer);
+    		this.populateSearchTreeManager();
+    		this.resourceManager.addReloadListener(this.searchTreeManager);
+    		this.particles = new ParticleManager(this.world, this.textureManager);
+    		//Forge
+    		Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.ParticleFactoryRegisterEvent_Constructor));
+    		//
+    		this.resourceManager.addReloadListener(this.particles);
+    		this.paintingSprites = new PaintingSpriteUploader(this.textureManager);
+    		this.resourceManager.addReloadListener(this.paintingSprites);
+    		this.potionSprites = new PotionSpriteUploader(this.textureManager);
+    		this.resourceManager.addReloadListener(this.potionSprites);
+
+    		//Forge
+    		if(Reflector.ForgeIngameGui_Constructor.exists())
+    			this.ingameGUI = (IngameGui) Reflector.newInstance(Reflector.ForgeIngameGui_Constructor, this);
+    		else
+    			this.ingameGUI = new IngameGui(this);
+    		//Forge
+
+    		//Forge
+    		this.mouseHelper.registerCallbacks(this.mainWindow.getHandle()); //Forge: Moved below ingameGUI setting to prevent NPEs in handeler.
+    		//
+
+    		this.debugRenderer = new DebugRenderer(this);
+    		RenderSystem.setErrorCallback(this::disableVSyncAfterGlError);
+
+    		if (this.gameSettings.fullscreen && !this.mainWindow.isFullscreen())
+    		{
+    			this.mainWindow.toggleFullscreen();
+    			this.gameSettings.fullscreen = this.mainWindow.isFullscreen();
+    		}
+
+    		this.mainWindow.setVsync(this.gameSettings.vsync);
+    		this.mainWindow.setRawMouseInput(this.gameSettings.rawMouseInput);
+    		this.mainWindow.setLogOnGlError();
+    		this.updateWindowSize();
+
+    		//forge - fix vanilla bug
+    		//            if (s != null)
+    		//            {
+    		//                this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, s, i));
+    		//            }
+    		//            else
+    		//            {
+    		//                this.displayGuiScreen(new MainMenuScreen(true));
+    	}
+    	final String autoServerName = s;
+    	final int autoServerPort = i;
+    	//
+    	// VIVE
+    	LangHelper.registerResourceListener();
+    	menuWorldRenderer = new MenuWorldRenderer();
+    	vrSettings.firstRun = false;
+    	vrSettings.saveOptions();
+    	// END VIVE
+
+    	ResourceLoadProgressGui.loadLogoTexture(this);
+    	List<IResourcePack> list = this.resourcePackRepository.getEnabledPacks().stream().map(ResourcePackInfo::getResourcePack).collect(Collectors.toList());
+    	this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (p_229990_2_) ->
+    	{
+    		// Vivecraft - post load
+    		if (stereoProvider.isInitialized())
+    			menuWorldRenderer.init();
+    		MCOpenVR.initInputAndApplication();
+    		//
+    		Util.acceptOrElse(p_229990_2_, this::restoreResourcePacks, () -> {
+    			this.languageManager.parseLanguageMetadata(list);
+
+    			if (SharedConstants.developmentMode)
+    			{
+    				this.checkMissingData();
+    			}
+    			//Forge
+
+    			if (Reflector.callBoolean(Reflector.ClientModLoader_completeModLoading)) return; // Do not overwrite the error screen
+    			// FORGE: Move opening initial screen to after startup and events are enabled.
+    			// Also Fixes MC-145102
+    			if (autoServerName != null) {
+    				this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, autoServerName, autoServerPort));
+    			} else {
+    				this.displayGuiScreen(new MainMenuScreen(true));
+    			}
+    			//
+    		});
+    	}, false));
     }
 
+    //updatewindowtitle
     public void func_230150_b_()
     {
         this.mainWindow.func_230148_b_(this.func_230149_ax_());
     }
 
+    //getwindowtitle
     private String func_230149_ax_()
     {
-        StringBuilder stringbuilder = new StringBuilder("Minecraft");
-
-        if (this.func_230151_c_())
-        {
-            stringbuilder.append("*");
-        }
-
+//Vivecraft
+        StringBuilder stringbuilder = new StringBuilder(minecriftVerString);
+//
+//        if (this.func_230151_c_())
+//        {
+//            stringbuilder.append("*");
+//        }
+//
         stringbuilder.append(" ");
         stringbuilder.append(SharedConstants.getVersion().getName());
         ClientPlayNetHandler clientplaynethandler = this.getConnection();
@@ -537,6 +746,7 @@
         return stringbuilder.toString();
     }
 
+    //is modded
     public boolean func_230151_c_()
     {
         return !"vanilla".equals(ClientBrandRetriever.getClientModName()) || Minecraft.class.getSigners() == null;
@@ -640,7 +850,12 @@
         });
         SearchTreeReloadable<ItemStack> searchtreereloadable = new SearchTreeReloadable<>((p_213235_0_) ->
         {
+        	//Forge
+        	if(Reflector.ForgeItem_getTags.exists())
+        		return ((java.util.Set) Reflector.call(p_213235_0_.getItem(),Reflector.ForgeItem_getTags)).stream();
+        	else
             return ItemTags.getCollection().getOwningTags(p_213235_0_.getItem()).stream();
+        	//
         });
         NonNullList<ItemStack> nonnulllist = NonNullList.create();
 
@@ -750,16 +965,25 @@
         if (report.getFile() != null)
         {
             Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + report.getFile());
+        	if(Reflector.ServerLifecycleHooks_handleExit.exists())
+        		Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+        	else
             System.exit(-1);
         }
         else if (report.saveToFile(file2))
         {
             Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
+        	if(Reflector.ServerLifecycleHooks_handleExit.exists())
+        		Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+        	else
             System.exit(-1);
         }
         else
         {
             Bootstrap.printToSYSOUT("#@?@# Game crashed! Crash report could not be saved. #@?@#");
+        	if(Reflector.ServerLifecycleHooks_handleExit.exists())
+        		Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -2);
+        	else
             System.exit(-2);
         }
     }
@@ -790,6 +1014,13 @@
                 List<IResourcePack> list = this.resourcePackRepository.getEnabledPacks().stream().map(ResourcePackInfo::getResourcePack).collect(Collectors.toList());
                 this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (p_229992_3_) ->
                 {
+                	//VIVECRAFT
+        			if (menuWorldRenderer.isReady() && resourcePacksChanged) {
+						menuWorldRenderer.destroy();
+						menuWorldRenderer.prepare();
+					}
+					resourcePacksChanged = false;
+					//
                     Util.acceptOrElse(p_229992_3_, this::restoreResourcePacks, () -> {
                         this.languageManager.parseLanguageMetadata(list);
                         this.worldRenderer.loadRenderers();
@@ -874,10 +1105,12 @@
 
     public void displayGuiScreen(@Nullable Screen guiScreenIn)
     {
-        if (this.currentScreen != null)
-        {
-            this.currentScreen.removed();
-        }
+    	//Forge
+//        if (this.currentScreen != null)
+//        {
+//            this.currentScreen.removed();
+//        }
+        //
 
         if (guiScreenIn == null && this.world == null)
         {
@@ -894,13 +1127,26 @@
                 this.player.respawnPlayer();
             }
         }
-
+        //Forge
+        Screen old = this.currentScreen;
+        Object event = Reflector.newInstance(Reflector.GuiOpenEvent_Constructor, guiScreenIn);
+        if(event != null) {
+        	if (Reflector.postForgeBusEvent(event)) return;
+        	guiScreenIn = (Screen) Reflector.call(event,Reflector.GuiOpenEvent_getGui);
+        }
+        if (old != null && guiScreenIn != old)
+           old.removed();
+        //
         if (guiScreenIn instanceof MainMenuScreen || guiScreenIn instanceof MultiplayerScreen)
         {
             this.gameSettings.showDebugInfo = false;
             this.ingameGUI.getChatGUI().clearChatMessages(true);
         }
 
+		// VIVECRAFT
+		GuiHandler.onScreenChanged(this.currentScreen, guiScreenIn, true);
+		// VIVECRAFT
+
         this.currentScreen = guiScreenIn;
 
         if (guiScreenIn != null)
@@ -964,6 +1210,12 @@
         finally
         {
             Util.nanoTimeSupplier = System::nanoTime;
+			// Vivecraft
+			try {
+				MCOpenVR.destroy();
+			} catch (Exception e) {
+			}
+			//
 
             if (this.crashReporter == null)
             {
@@ -1001,141 +1253,314 @@
     }
 
     private void runGameLoop(boolean renderWorldIn)
-    {
-        this.mainWindow.setRenderPhase("Pre render");
-        long i = Util.nanoTime();
-        this.profiler.startTick();
-
-        if (this.mainWindow.shouldClose())
-        {
-            this.shutdown();
-        }
-
-        if (this.futureRefreshResources != null && !(this.loadingGui instanceof ResourceLoadProgressGui))
-        {
-            CompletableFuture<Void> completablefuture = this.futureRefreshResources;
-            this.futureRefreshResources = null;
-            this.reloadResources().thenRun(() ->
-            {
-                completablefuture.complete((Void)null);
-            });
-        }
-
-        Runnable runnable;
-
-        while ((runnable = this.queueChunkTracking.poll()) != null)
-        {
-            runnable.run();
-        }
-
-        if (renderWorldIn)
-        {
-            this.timer.updateTimer(Util.milliTime());
-            this.profiler.startSection("scheduledExecutables");
-            this.drainTasks();
-            this.profiler.endSection();
-        }
-
-        this.profiler.startSection("tick");
-
-        if (renderWorldIn)
-        {
-            for (int j = 0; j < Math.min(10, this.timer.elapsedTicks); ++j)
-            {
-                this.runTick();
-            }
-        }
-
-        this.mouseHelper.updatePlayerLook();
-        this.mainWindow.setRenderPhase("Render");
-        this.profiler.endStartSection("sound");
-        this.soundHandler.updateListener(this.gameRenderer.getActiveRenderInfo());
-        this.profiler.endSection();
-        this.profiler.startSection("render");
-        RenderSystem.pushMatrix();
-        RenderSystem.clear(16640, IS_RUNNING_ON_MAC);
-        this.framebuffer.bindFramebuffer(true);
-        FogRenderer.resetFog();
-        this.profiler.startSection("display");
-        RenderSystem.enableTexture();
-        this.profiler.endSection();
-
-        if (!this.skipRenderWorld)
-        {
-            this.profiler.endStartSection("gameRenderer");
-            this.gameRenderer.updateCameraAndRender(this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks, i, renderWorldIn);
-            this.profiler.endStartSection("toasts");
-            this.toastGui.render();
-            this.profiler.endSection();
-        }
-
-        this.profiler.endTick();
-
-        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI)
-        {
-            this.profiler.getFixedProfiler().enable();
-            this.drawProfiler();
-        }
-        else
-        {
-            this.profiler.getFixedProfiler().disable();
-        }
-
-        this.framebuffer.unbindFramebuffer();
-        RenderSystem.popMatrix();
-        RenderSystem.pushMatrix();
-        this.framebuffer.framebufferRender(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
-        RenderSystem.popMatrix();
-        this.profiler.startTick();
-        this.profiler.startSection("updateDisplay");
-        this.mainWindow.flipFrame();
-        int l = this.getFramerateLimit();
-
-        if ((double)l < AbstractOption.FRAMERATE_LIMIT.getMaxValue())
-        {
-            RenderSystem.limitDisplayFPS(l);
-        }
-
-        this.profiler.endStartSection("yield");
-        Thread.yield();
-        this.profiler.endSection();
-        this.mainWindow.setRenderPhase("Post render");
-        ++this.fpsCounter;
-        boolean flag = this.isSingleplayer() && (this.currentScreen != null && this.currentScreen.isPauseScreen() || this.loadingGui != null && this.loadingGui.isPauseScreen()) && !this.integratedServer.getPublic();
-
-        if (this.isGamePaused != flag)
-        {
-            if (this.isGamePaused)
-            {
-                this.renderPartialTicksPaused = this.timer.renderPartialTicks;
-            }
-            else
-            {
-                this.timer.renderPartialTicks = this.renderPartialTicksPaused;
-            }
-
-            this.isGamePaused = flag;
-        }
-
-        long k = Util.nanoTime();
-        this.frameTimer.addFrame(k - this.startNanoTime);
-        this.startNanoTime = k;
-
-        while (Util.milliTime() >= this.debugUpdateTime + 1000L)
-        {
-            debugFPS = this.fpsCounter;
-            this.debug = String.format("%d fps T: %s%s%s%s B: %d", debugFPS, (double)this.gameSettings.framerateLimit == AbstractOption.FRAMERATE_LIMIT.getMaxValue() ? "inf" : this.gameSettings.framerateLimit, this.gameSettings.vsync ? " vsync" : "", this.gameSettings.fancyGraphics ? "" : " fast", this.gameSettings.cloudOption == CloudOption.OFF ? "" : (this.gameSettings.cloudOption == CloudOption.FAST ? " fast-clouds" : " fancy-clouds"), this.gameSettings.biomeBlendRadius);
-            this.debugUpdateTime += 1000L;
-            this.fpsCounter = 0;
-            this.snooper.addMemoryStatsToSnooper();
-
-            if (!this.snooper.isSnooperRunning())
-            {
-                this.snooper.start();
-            }
-        }
-
-        this.profiler.endTick();
+    { 	
+    	this.mainWindow.setRenderPhase("Pre render");
+    	long i = Util.nanoTime();
+    	this.profiler.startTick();
+
+    	if (this.mainWindow.shouldClose())
+    	{
+    		this.shutdown();
+    	}
+
+    	if (this.futureRefreshResources != null && !(this.loadingGui instanceof ResourceLoadProgressGui))
+    	{
+    		CompletableFuture<Void> completablefuture = this.futureRefreshResources;
+    		this.futureRefreshResources = null;
+    		this.reloadResources().thenRun(() ->
+    		{
+    			completablefuture.complete((Void)null);
+    		});
+    	}
+
+    	Runnable runnable;
+
+    	while ((runnable = this.queueChunkTracking.poll()) != null)
+    	{
+    		runnable.run();
+    	}
+
+    	if (renderWorldIn)
+    	{
+    		this.timer.updateTimer(Util.milliTime());
+    		this.profiler.startSection("scheduledExecutables");
+    		this.drainTasks();
+    		this.profiler.endSection();
+    	}
+
+    	{// Vivecraft
+    		this.frameDelta = (i - this.prevFrameTime) / 1000000000F;
+    		this.prevFrameTime = i;
+    		// avoid having to change GLX
+    		gameSettings.ofFastRender = false;
+    	}
+    	
+    	/** MINECRIFT */ // setup the display, render buffers, shaders etc.
+    	this.frameIndex++;
+
+    	try {
+    		stereoProvider.setupRenderConfiguration();
+    	} catch (RenderConfigException e) {
+    		this.currentScreen = null;		
+    		GlStateManager.viewport(0, 0, mainWindow.getWidth(), mainWindow.getHeight());
+    		if (loadingGui != null) {
+        		RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+        		RenderSystem.matrixMode(5889);
+        		RenderSystem.loadIdentity();
+        		RenderSystem.ortho(0.0D, (double)mainWindow.getWidth() / mainWindow.getGuiScaleFactor(), (double)mainWindow.getHeight() / mainWindow.getGuiScaleFactor(), 0.0D, 1000.0D, 3000.0D);
+        		RenderSystem.matrixMode(5888);
+        		RenderSystem.loadIdentity();
+        		RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
+        		RenderHelper.setupGui3DDiffuseLighting();
+    			loadingGui.render(0, 0, 0);
+    		} else {
+    			notifyMirror("Render Setup Failed " + e.error, true, 10000);
+    			drawNotifyMirror();
+    			if (this.frameIndex % 300 == 0)
+    				System.out.println(e.title + " " + e.error);
+    			try {
+    				Thread.sleep(10);
+    			} catch (InterruptedException e1) {
+    			}
+    		}		
+    		mainWindow.flipFrame();
+    		return;
+    	} catch (Exception e) {
+    		e.printStackTrace();
+    	}
+    	/** END MINECRIFT */
+
+    	// VIVECRAFT
+    	this.profiler.startSection("VR Poll/VSync");
+    	// Poll sensors
+    	MCOpenVR.poll(frameIndex);
+    	this.profiler.endSection();
+
+    	vrPlayer.postPoll();
+    	this.profiler.startSection("tick");
+
+    	if (renderWorldIn)
+    	{
+    		for (int j = 0; j < Math.min(10, this.timer.elapsedTicks); ++j)
+    		{
+    			// VIVECRAFT
+    			vrPlayer.preTick();
+    			//
+    			this.runTick();
+    			// VIVECRAFT
+    			vrPlayer.postTick();
+    			//
+    		}
+    	}
+
+    	this.profiler.endStartSection("setupRenderConfiguration");
+	    	this.mouseHelper.updatePlayerLook();
+	    	this.mainWindow.setRenderPhase("Render");
+	   
+	    	// VIVECRAFT - Check again in case something changed during Tick.
+	    	try {
+	    		checkGLError("pre render setup ");
+	    		stereoProvider.setupRenderConfiguration();
+	    		checkGLError("post render setup ");
+	    	} catch (Exception e) {
+	    		e.printStackTrace();
+	    	}
+	    	//
+	    	
+	    	// Vivecraft
+	    	float par1 = this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks;
+
+    	this.profiler.endStartSection("preRender"); 	
+	    	vrPlayer.preRender(par1);
+	       	/* Vivecraft
+	        RenderSystem.pushMatrix();
+	        RenderSystem.clear(16640, IS_RUNNING_ON_MAC);
+	        this.framebuffer.bindFramebuffer(true);
+	        this.profiler.startSection("display");
+	        this.profiler.endSection();
+	    	 */   	
+	        FogRenderer.resetFog();
+	        RenderSystem.enableTexture();     
+    	this.profiler.endSection();
+
+    	this.profiler.startSection("Gui");
+    		this.currentPass = RenderPass.GUI;
+	    	GlStateManager.depthMask(true);
+	    	GlStateManager.colorMask(true, true, true, true);
+	
+	    	// Render GUI to FBO if necessary
+	    	this.framebuffer = GuiHandler.guiFramebuffer; // draw to 2d gui.
+	    	this.framebuffer.bindFramebuffer(true);
+	
+	    	this.gameRenderer.drawFramebufferNEW(par1, renderWorldIn); // VIVE - added param for debug info
+	
+	    	if (KeyboardHandler.Showing && !this.vrSettings.physicalKeyboard) {
+	    		this.framebuffer = KeyboardHandler.Framebuffer;
+	    		this.framebuffer.bindFramebuffer(true);
+	    		this.gameRenderer.drawScreen(par1, KeyboardHandler.UI);
+	    	}
+	
+	    	if (RadialHandler.isShowing()) {
+	    		this.framebuffer = RadialHandler.Framebuffer;
+	    		this.framebuffer.bindFramebuffer(true);
+	    		this.gameRenderer.drawScreen(par1, RadialHandler.UI);
+	    	}
+	
+	    	checkGLError("post 2d ");
+	    	VRHotkeys.updateMovingThirdPersonCam();
+
+	    	//
+    	this.profiler.endStartSection("sound");
+    		this.currentPass = RenderPass.CENTER;
+        	this.gameRenderer.getActiveRenderInfo().update(this.world, this.getRenderViewEntity(), false, false, par1);
+    		this.soundHandler.updateListener(gameRenderer.getActiveRenderInfo());
+    	this.profiler.endSection();
+    	
+       	this.profiler.startSection("render");
+          
+    	if (!this.skipRenderWorld)
+    	{
+    		// VIVECRAFT RENDERING MAIN
+    		if (minecriftDebug)
+    			print("FrameIndex: " + frameIndex);
+
+    		List<RenderPass> passes = this.stereoProvider.getRenderPasses();
+  		   		
+    		/** Minecrift - main stereo render loop **/
+    		for (RenderPass pass : passes) {
+    			this.currentPass = pass;
+    			switch (pass) {
+    			case LEFT:
+    			case RIGHT:
+    				this.framebuffer = stereoProvider.framebufferVrRender;
+    				break;
+    			case CENTER:
+    				this.framebuffer = stereoProvider.framebufferUndistorted;
+    				break;
+    			case THIRD:
+    				this.framebuffer = stereoProvider.framebufferMR;
+    				break;
+    			case SCOPEL:
+    				this.framebuffer = stereoProvider.telescopeFramebufferL;
+    				break;
+    			case SCOPER:
+					this.framebuffer = stereoProvider.telescopeFramebufferR;
+    				break;
+    			}
+
+    			this.profiler.startSection("Eye:" + currentPass.ordinal());
+    			this.profiler.startSection("setup");
+    			this.framebuffer.bindFramebuffer(true); // draw to main texture for every pass
+    			this.profiler.endSection();
+    			RenderSystem.loadIdentity();
+    			renderSingleView(pass.ordinal(), par1, renderWorldIn);
+    			this.profiler.endSection(); // eye
+
+    			if (grabScreenShot) {
+    				boolean inPass;
+    				if (passes.contains(RenderPass.CENTER)) {
+    					inPass = (pass == RenderPass.CENTER);
+    				} else {
+    					inPass = vrSettings.displayMirrorLeftEye ? (pass == RenderPass.LEFT) : (pass == RenderPass.RIGHT);
+    				}
+
+    				if (inPass) {
+    					this.framebuffer.unbindFramebuffer();
+    					// GLX.fbo = false; // huh?
+    					ScreenShotHelper.saveScreenshot(this.gameDir, this.framebuffer.framebufferWidth,
+    							this.framebuffer.framebufferHeight, this.framebuffer, (text) -> {
+    								// this.addScheduledTask(() -> {
+    								// this.ingameGUI.getChatGUI().printChatMessage(text);
+    								// });
+    							});
+    					// GLX.fbo = true; // what is this?
+    					grabScreenShot = false;
+    				}
+    			}
+    		} // end per eye rendering.
+   		
+    		// VIVECRAFT
+    		vrPlayer.postRender(par1);
+    		//
+
+    		profiler.startSection("Display/Reproject");
+    		try {
+    			this.stereoProvider.endFrame();
+    		} catch (Exception e) {
+    			LOGGER.error(e.toString());
+    		}
+    		profiler.endSection();
+
+    		checkGLError("post submit ");
+
+    		this.profiler.startSection("mirror");
+    		this.framebuffer.unbindFramebuffer(); // draw directly to window
+    		copyToMirror();
+    		drawNotifyMirror();
+    		checkGLError("post-mirror ");
+    		this.profiler.endSection();
+    		    		
+    		//// END MAIN VIVECRAFT RENDERING
+    	}
+
+    	/*
+    	 * /Vivecraft this.framebuffer.unbindFramebuffer(); GlStateManager.popMatrix();
+    	 * GlStateManager.pushMatrix();
+    	 * this.framebuffer.framebufferRender(this.mainWindow.getFramebufferWidth(),
+    	 * this.mainWindow.getFramebufferHeight()); GlStateManager.popMatrix();
+    	 * GlStateManager.pushMatrix();
+    	 * this.entityRenderer.renderStreamIndicator(this.timer.renderPartialTicks);
+    	 * GlStateManager.popMatrix(); this.mainWindow.update(true); Thread.yield();
+    	 * 
+    	 */
+    	
+    	this.getProfiler().endSection(); //render
+    	
+    	this.mainWindow.setRenderPhase("Post render");
+    	this.mainWindow.flipFrame();
+
+    	++this.fpsCounter;
+    	boolean flag = this.isSingleplayer() && (this.currentScreen != null && this.currentScreen.isPauseScreen() || this.loadingGui != null && this.loadingGui.isPauseScreen()) && !this.integratedServer.getPublic();
+
+    	if (this.isGamePaused != flag)
+    	{
+    		if (this.isGamePaused)
+    		{
+    			this.renderPartialTicksPaused = this.timer.renderPartialTicks;
+    		}
+    		else
+    		{
+    			this.timer.renderPartialTicks = this.renderPartialTicksPaused;
+    		}
+
+    		this.isGamePaused = flag;
+    	}
+
+    	long k = Util.nanoTime();
+    	this.frameTimer.addFrame(k - this.startNanoTime);
+    	this.startNanoTime = k;
+
+    	while (Util.milliTime() >= this.debugUpdateTime + 1000L)
+    	{
+    		debugFPS = this.fpsCounter;
+    		this.debug = String.format("%d fps T: %s%s%s%s B: %d", debugFPS, (double)this.gameSettings.framerateLimit == AbstractOption.FRAMERATE_LIMIT.getMaxValue() ? "inf" : this.gameSettings.framerateLimit, this.gameSettings.vsync ? " vsync" : "", this.gameSettings.fancyGraphics ? "" : " fast", this.gameSettings.cloudOption == CloudOption.OFF ? "" : (this.gameSettings.cloudOption == CloudOption.FAST ? " fast-clouds" : " fancy-clouds"), this.gameSettings.biomeBlendRadius);
+    		this.debugUpdateTime += 1000L;
+    		this.fpsCounter = 0;
+    		this.snooper.addMemoryStatsToSnooper();
+
+    		if (!this.snooper.isSnooperRunning())
+    		{
+    			this.snooper.start();
+    		}
+    	}
+
+    	this.profiler.endTick();
+
+    	if (this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI) {
+    		this.profiler.getFixedProfiler().enable();
+    	} else {
+    		this.profiler.getFixedProfiler().disable();
+    	}
     }
 
     public void updateWindowSize()
@@ -1143,14 +1568,14 @@
         int i = this.mainWindow.calcGuiScale(this.gameSettings.guiScale, this.getForceUnicodeFont());
         this.mainWindow.setGuiScale((double)i);
 
+		if (stereoProvider != null)
+			stereoProvider.reinitFrameBuffers("Main Window Changed");
+
         if (this.currentScreen != null)
         {
             this.currentScreen.resize(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
         }
 
-        Framebuffer framebuffer = this.getFramebuffer();
-        framebuffer.resize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
-        this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
         this.mouseHelper.setIgnoreFirstMove();
     }
 
@@ -1228,7 +1653,7 @@
         }
     }
 
-    private void drawProfiler()
+    public void drawProfiler()
     {
         if (this.profiler.getFixedProfiler().isEnabled())
         {
@@ -1247,14 +1672,15 @@
             Tessellator tessellator = Tessellator.getInstance();
             BufferBuilder bufferbuilder = tessellator.getBuffer();
             int i = 160;
-            int j = this.mainWindow.getFramebufferWidth() - 160 - 10;
-            int k = this.mainWindow.getFramebufferHeight() - 320;
+            int j = this.mainWindow.getFramebufferWidth()/3;
+            int k = this.mainWindow.getFramebufferHeight()/9;
             RenderSystem.enableBlend();
+            RenderSystem.scaled(2.2, 2.7, 1);
             bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
             bufferbuilder.pos((double)((float)j - 176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
             bufferbuilder.pos((double)((float)j - 176.0F), (double)(k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
             bufferbuilder.pos((double)((float)j + 176.0F), (double)(k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
-            bufferbuilder.pos((double)((float)j + 176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
+            bufferbuilder.pos((double)((float)j + 4*176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
             tessellator.draw();
             RenderSystem.disableBlend();
             double d0 = 0.0D;
@@ -1388,19 +1814,43 @@
                 BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
                 BlockPos blockpos = blockraytraceresult.getPos();
 
-                if (!this.world.getBlockState(blockpos).isAir())
-                {
+    			Object inputEvent = null;
+    			if (!this.world.isAirBlock(blockpos)) {
+    				//Forge
+    				inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.gameSettings.keyBindAttack, Hand.MAIN_HAND);
+    				if (inputEvent !=null && Reflector.callBoolean(inputEvent,  Reflector.Event_isCanceled)) {
+    					if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) {
+    						this.particles.addBlockHitEffects(blockpos, blockraytraceresult);
+    						this.player.swingArm(Hand.MAIN_HAND);
+    					}
+    					return;
+    				}
+    				//
                     Direction direction = blockraytraceresult.getFace();
 
                     if (this.playerController.onPlayerDamageBlock(blockpos, direction))
                     {
                         this.particles.addBlockHitEffects(blockpos, direction);
-                        this.player.swingArm(Hand.MAIN_HAND);
+                        //Vivecraft this is here to keep the animation going while holding down attack.
+                        this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
                     }
-                }
-            }
-            else
-            {
+    				//Forge
+    				if(inputEvent != null) {
+    					if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) {
+    						this.particles.addBlockHitEffects(blockpos, blockraytraceresult);
+    						this.player.swingArm(Hand.MAIN_HAND);
+                }
+            //Vivecraft seated check
+			} else if (vrSettings.seated) {
+			//
+    				} else {
+    					this.particles.addBlockHitEffects(blockpos, direction);
+    					this.player.swingArm(Hand.MAIN_HAND);
+    				}
+    			}
+    		}
+    		else
+    		{
                 this.playerController.resetBlockRemoving();
             }
         }
@@ -1421,6 +1871,12 @@
             }
             else if (!this.player.isRowingBoat())
             {
+            	Object inputEvent;
+            	//Forge
+				inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.gameSettings.keyBindAttack, Hand.MAIN_HAND);
+
+                if (inputEvent == null || !Reflector.callBoolean(inputEvent,  Reflector.Event_isCanceled))
+                	//
                 switch (this.objectMouseOver.getType())
                 {
                     case ENTITY:
@@ -1431,7 +1887,7 @@
                         BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
                         BlockPos blockpos = blockraytraceresult.getPos();
 
-                        if (!this.world.getBlockState(blockpos).isAir())
+                        if (!this.world.isAirBlock(blockpos))
                         {
                             this.playerController.clickBlock(blockpos, blockraytraceresult.getFace());
                             break;
@@ -1442,103 +1898,139 @@
                         {
                             this.leftClickCounter = 10;
                         }
-
                         this.player.resetCooldown();
-                }
-
-                this.player.swingArm(Hand.MAIN_HAND);
-            }
-        }
-    }
-
-    private void rightClickMouse()
-    {
-        if (!this.playerController.getIsHittingBlock())
-        {
-            this.rightClickDelayTimer = 4;
-
-            if (!this.player.isRowingBoat())
-            {
-                if (this.objectMouseOver == null)
-                {
-                    LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
-                }
-
-                for (Hand hand : Hand.values())
-                {
-                    ItemStack itemstack = this.player.getHeldItem(hand);
-
-                    if (this.objectMouseOver != null)
-                    {
-                        switch (this.objectMouseOver.getType())
-                        {
-                            case ENTITY:
-                                EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult)this.objectMouseOver;
-                                Entity entity = entityraytraceresult.getEntity();
-                                ActionResultType actionresulttype = this.playerController.interactWithEntity(this.player, entity, entityraytraceresult, hand);
-
-                                if (!actionresulttype.isSuccessOrConsume())
-                                {
-                                    actionresulttype = this.playerController.interactWithEntity(this.player, entity, hand);
-                                }
-
-                                if (actionresulttype.isSuccessOrConsume())
-                                {
-                                    if (actionresulttype.isSuccess())
-                                    {
-                                        this.player.swingArm(hand);
-                                    }
-
-                                    return;
-                                }
-
-                                break;
-
-                            case BLOCK:
-                                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
-                                int i = itemstack.getCount();
-                                ActionResultType actionresulttype1 = this.playerController.func_217292_a(this.player, this.world, hand, blockraytraceresult);
-
-                                if (actionresulttype1.isSuccessOrConsume())
-                                {
-                                    if (actionresulttype1.isSuccess())
-                                    {
-                                        this.player.swingArm(hand);
-
-                                        if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode()))
-                                        {
-                                            this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
-                                        }
-                                    }
-
-                                    return;
-                                }
-
-                                if (actionresulttype1 == ActionResultType.FAIL)
-                                {
-                                    return;
-                                }
-                        }
-                    }
-
-                    if (!itemstack.isEmpty())
-                    {
-                        ActionResultType actionresulttype2 = this.playerController.processRightClick(this.player, this.world, hand);
-
-                        if (actionresulttype2.isSuccessOrConsume())
-                        {
-                            if (actionresulttype2.isSuccess())
-                            {
-                                this.player.swingArm(hand);
-                            }
-
-                            this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
-                            return;
-                        }
-                    }
-                }
-            }
-        }
+                        //Forge
+                        Reflector.call(Reflector.ForgeHooks_onEmptyLeftClick, this.player);
+                        //
+                }
+                
+                if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+                	this.player.swingArm(Hand.MAIN_HAND);
+            }
+        }
+    }
+
+    public void rightClickMouse()
+    {
+    	//Vivecraft check seated
+    	if (!this.playerController.getIsHittingBlock() || vrSettings.seated == false) {
+    		//
+    		//Vivecraft delay
+    		this.rightClickDelayTimer = vrSettings.seated ? 4 : vrSettings.rightclickDelay; 
+    		//
+
+    		if (!this.player.isRowingBoat())
+    		{
+    			if (this.objectMouseOver == null)
+    			{
+    				LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
+    			}
+
+    			for (Hand hand : Hand.values())
+    			{
+    				Object inputEvent;
+    				inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 1, this.gameSettings.keyBindUseItem, hand);
+
+    				if (inputEvent !=null && Reflector.callBoolean(inputEvent,  Reflector.Event_isCanceled)) {
+    					if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) 
+    						this.player.swingArm(hand);
+    					return;
+    				}
+
+    				ItemStack itemstack = this.player.getHeldItem(hand);
+    				if(TelescopeTracker.isTelescope(itemstack))
+    					continue;
+    				//Vivecraft
+    				NetworkHelper.sendActiveHand((byte) hand.ordinal());
+    				//
+    				if (this.objectMouseOver != null)
+    				{
+    					switch (this.objectMouseOver.getType())
+    					{
+    					case ENTITY:
+    						//ft where are you
+    						physicalGuiManager.preClickAction();
+    						//
+    						EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult)this.objectMouseOver;
+    						Entity entity = entityraytraceresult.getEntity();
+    						ActionResultType actionresulttype = this.playerController.interactWithEntity(this.player, entity, entityraytraceresult, hand);
+
+    						if (!actionresulttype.isSuccessOrConsume())
+    						{
+    							actionresulttype = this.playerController.interactWithEntity(this.player, entity, hand);
+    						}
+
+    						if (actionresulttype.isSuccessOrConsume())
+    						{
+    							if (actionresulttype.isSuccess())
+    							{
+    								//Vivecraft
+									if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+    								this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+    								//
+    							}
+
+    							return;
+    						}
+
+    						break;
+
+    					case BLOCK:
+    						BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
+    						int i = itemstack.getCount();
+    						ActionResultType actionresulttype1 = this.playerController.func_217292_a(this.player, this.world, hand, blockraytraceresult);
+
+    						if (actionresulttype1.isSuccessOrConsume())
+    						{
+    							if (actionresulttype1.isSuccess())
+    							{
+    								//Vivecraft
+    								    								if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+    								this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+    								//
+    								if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode()))
+    								{
+    									this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
+    								}
+    							}
+
+    							return;
+    						}
+
+    						if (actionresulttype1 == ActionResultType.FAIL)
+    						{
+    							return;
+    						}
+    					}
+    				}
+    				//pi stuff
+    				physicalGuiManager.preClickAction();
+    				//
+    				//Forge
+    				if (itemstack.isEmpty() && (this.objectMouseOver == null || this.objectMouseOver.getType() == RayTraceResult.Type.MISS))
+    					Reflector.call(Reflector.ForgeHooks_onEmptyClick, this.player, hand);
+    				//
+    				if (!itemstack.isEmpty())
+    				{
+    		
+    					ActionResultType actionresulttype2 = this.playerController.processRightClick(this.player, this.world, hand);
+
+    					if (actionresulttype2.isSuccessOrConsume())
+    					{
+    						if (actionresulttype2.isSuccess())
+    						{
+    							//Vivecraft
+    							this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+    							//
+    						}
+
+    						this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
+    						return;
+    					}
+    				}
+    			}
+    		}
+    	}
     }
 
     public MusicTicker getMusicTicker()
@@ -1548,12 +2040,17 @@
 
     public void runTick()
     {
+    	//Vivecraft y do we put this here
+    	this.tickCounter++;
+    	//
         if (this.rightClickDelayTimer > 0)
         {
             --this.rightClickDelayTimer;
         }
-
-        this.profiler.startSection("gui");
+        //Forge
+        Reflector.call(Reflector.BasicEventHooks_onPreClientTick);
+        //
+        this.profiler.startSection("guitick");
 
         if (!this.isGamePaused)
         {
@@ -1561,7 +2058,7 @@
         }
 
         this.profiler.endSection();
-        this.gameRenderer.getMouseOver(1.0F);
+        //this.gameRenderer.getMouseOver(1.0F);
         this.tutorial.onMouseHover(this.world, this.objectMouseOver);
         this.profiler.startSection("gameMode");
 
@@ -1572,10 +2069,11 @@
 
         this.profiler.endStartSection("textures");
 
-        if (this.world != null)
-        {
+		// Vivecraft tick the main menu too
+		// if (this.world != null)
+		// {
             this.textureManager.tick();
-        }
+		// }
 
         if (this.currentScreen == null && this.player != null)
         {
@@ -1593,6 +2091,7 @@
             this.displayGuiScreen((Screen)null);
         }
 
+
         if (this.currentScreen != null)
         {
             this.leftClickCounter = 10000;
@@ -1610,6 +2109,11 @@
         {
             this.ingameGUI.reset();
         }
+		// Vivecraft
+		this.profiler.endStartSection("vrProcessInputs");
+		MCOpenVR.processInputs();
+		MCOpenVR.processBindings();
+		///
 
         if (this.loadingGui == null && (this.currentScreen == null || this.currentScreen.passEvents))
         {
@@ -1622,8 +2126,27 @@
             }
         }
 
-        if (this.world != null)
-        {
+		// Vivecraft
+		this.profiler.endStartSection("vrInputActionsTick");
+		for (VRInputAction action : MCOpenVR.getInputActions()) {
+			action.tick();
+		}
+
+		if (vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY
+				|| vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON)
+			VRHotkeys.handleMRKeys();
+
+		if (this.world != null) {
+			if (this.player != null) {
+				// Vivecraft
+				this.vrPlayer.updateFreeMove();
+				if (this.vrPlayer.teleportWarningTimer >= 0) {
+					if (--this.vrPlayer.teleportWarningTimer == 0) {
+						printChatMessage(
+								"This server does not support teleporting. Restricted movement mode (fallback to free move) has been enabled.");
+					}
+				}
+			}
             this.profiler.endStartSection("gameRenderer");
 
             if (!this.isGamePaused)
@@ -1649,14 +2172,23 @@
 
                 this.world.tickEntities();
             }
+            
         }
         else if (this.gameRenderer.getShaderGroup() != null)
         {
             this.gameRenderer.stopUseShader();
         }
 
-        if (!this.isGamePaused)
-        {
+		// Vivecraft
+		if (this.menuWorldRenderer != null)
+			this.menuWorldRenderer.tick();
+		PlayerModelController.getInstance().tick();
+		//
+		
+        //lol dont pause this while in the menu.
+		AutoCalibration.logHeadPos(MCOpenVR.hmdPivotHistory.latest());
+
+		if (!this.isGamePaused) {
             this.musicTicker.tick();
         }
 
@@ -1717,27 +2249,32 @@
         this.profiler.endStartSection("keyboard");
         this.keyboardListener.tick();
         this.profiler.endSection();
-    }
-
-    private void processKeyBinds()
-    {
-        for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer.setDisplayListEntitiesDirty())
-        {
-            ++this.gameSettings.thirdPersonView;
-
-            if (this.gameSettings.thirdPersonView > 2)
-            {
-                this.gameSettings.thirdPersonView = 0;
-            }
-
-            if (this.gameSettings.thirdPersonView == 0)
-            {
-                this.gameRenderer.loadEntityShader(this.getRenderViewEntity());
-            }
-            else if (this.gameSettings.thirdPersonView == 1)
-            {
-                this.gameRenderer.loadEntityShader((Entity)null);
-            }
+        //Forge
+        Reflector.call(Reflector.BasicEventHooks_onPostClientTick);
+        //
+    }
+
+	private void processKeyBinds() {
+		for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer
+				.setDisplayListEntitiesDirty()) {
+			vrSettings.setOptionValue(VrOptions.MIRROR_DISPLAY);
+			notifyMirror(vrSettings.getButtonDisplayString(VrOptions.MIRROR_DISPLAY), false, 3000);
+
+			// VIVECRAFT: Credits debug
+			// this.displayScreen(new GuiWinGame(true,
+			// com.google.common.util.concurrent.Runnables.doNothing()));
+
+			/*
+			 * Vivecraft override F5 ++this.gameSettings.thirdPersonView;
+			 * 
+			 * if (this.gameSettings.thirdPersonView > 2) {
+			 * this.gameSettings.thirdPersonView = 0; }
+			 * 
+			 * if (this.gameSettings.thirdPersonView == 0) {
+			 * this.gameRenderer.loadEntityShader(this.getRenderViewEntity()); } else if
+			 * (this.gameSettings.thirdPersonView == 1) {
+			 * this.gameRenderer.loadEntityShader((Entity)null); }
+			 */
         }
 
         while (this.gameSettings.keyBindSmoothCamera.isPressed())
@@ -1797,7 +2334,9 @@
         {
             if (!this.player.isSpectator() && this.player.func_225609_n_(Screen.hasControlDown()))
             {
-                this.player.swingArm(Hand.MAIN_HAND);
+            	//Vivecraft - thow anim?
+                this.player.swingArm(Hand.MAIN_HAND,VRFirstPersonArmSwing.Attack);
+                //
             }
         }
 
@@ -1805,7 +2344,7 @@
 
         if (flag2)
         {
-            while (this.gameSettings.keyBindChat.isPressed())
+   			if (this.currentScreen == null && this.gameSettings.keyBindChat.isPressed())
             {
                 this.displayGuiScreen(new ChatScreen(""));
             }
@@ -1816,11 +2355,13 @@
             }
         }
 
-        if (this.player.isHandActive())
-        {
-            if (!this.gameSettings.keyBindUseItem.isKeyDown())
-            {
-                this.playerController.onStoppedUsingItem(this.player);
+		if (this.player.isHandActive()) {
+			if (!this.gameSettings.keyBindUseItem.isKeyDown()
+					&& (bowTracker.isActive(player) == false || vrSettings.seated)) {
+				if (!autoFood.isEating()) {
+					NetworkHelper.sendActiveHand((byte) player.getActiveHand().ordinal());
+					this.playerController.onStoppedUsingItem(this.player);
+				}
             }
 
             while (this.gameSettings.keyBindAttack.isPressed())
@@ -1840,10 +2381,18 @@
         }
         else
         {
-            while (this.gameSettings.keyBindAttack.isPressed())
-            {
+			// VIVE SUPPORT HAND SWINGING
+			if (this.gameSettings.keyBindAttack.isPressed() && currentScreen == null) {
                 this.clickMouse();
-            }
+				lastClick = true;
+			} else if (!this.gameSettings.keyBindAttack.isKeyDown()) {
+				this.leftClickCounter = 0;
+				if (lastClick) {
+					this.playerController.resetBlockRemoving();
+            }
+				lastClick = false;
+			}
+			/// END VIVE
 
             while (this.gameSettings.keyBindUseItem.isPressed())
             {
@@ -1861,7 +2410,7 @@
             this.rightClickMouse();
         }
 
-        this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown() && this.mouseHelper.isMouseGrabbed());
+		this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown());
     }
 
     public void launchIntegratedServer(String folderName, String worldName, @Nullable WorldSettings worldSettingsIn)
@@ -1921,6 +2470,14 @@
 
         while (!this.integratedServer.serverIsInRunLoop())
         {
+        	//Forge
+            if ((Reflector.fml_StartupQuery_check.exists() && !Reflector.callBoolean(Reflector.fml_StartupQuery_check)) || this.integratedServer.isServerStopped()) {
+                this.displayGuiScreen(null);
+                return;
+             } else if (this.currentScreen == null) // if we're showing nothing, put the working screen back again
+               this.displayGuiScreen(worldloadprogressscreen);
+            //
+            
             worldloadprogressscreen.tick();
             this.runGameLoop(false);
 
@@ -1946,12 +2503,26 @@
         {
         }));
         networkmanager.sendPacket(new CHandshakePacket(socketaddress.toString(), 0, ProtocolType.LOGIN));
-        networkmanager.sendPacket(new CLoginStartPacket(this.getSession().getProfile()));
+        //Forge
+        com.mojang.authlib.GameProfile gameProfile = this.getSession().getProfile();
+        if((Reflector.ForgeSession_hasCachedProperties.exists() && !Reflector.callBoolean(this.getSession(),Reflector.ForgeSession_hasCachedProperties))) {
+           gameProfile = sessionService.fillProfileProperties(gameProfile, true); //Forge: Fill profile properties upon game load. Fixes MC-52974.
+           Reflector.call(this.getSession(), Reflector.ForgeSession_setProperties, gameProfile.getProperties());
+        }
+        //
+        networkmanager.sendPacket(new CLoginStartPacket(gameProfile));
         this.networkManager = networkmanager;
     }
 
     public void loadWorld(ClientWorld worldClientIn)
     {
+		// VIVE START - reset room origin
+		vrPlayer.setRoomOrigin(0, 0, 0, true);
+		// VIVE END - reset room origin
+		    	//Forge
+        if (world != null) 
+        	Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, world));
+        //
         WorkingScreen workingscreen = new WorkingScreen();
         workingscreen.displaySavingString(new TranslationTextComponent("connect.joining"));
         this.updateScreenTick(workingscreen);
@@ -1988,12 +2559,18 @@
         IntegratedServer integratedserver = this.integratedServer;
         this.integratedServer = null;
         this.gameRenderer.resetData();
+        //Forge
+        Reflector.call(Reflector.ClientHooks_firePlayerLogout, this.playerController, this.player);
+        //
         this.playerController = null;
         NarratorChatListener.INSTANCE.clear();
         this.updateScreenTick(screenIn);
 
         if (this.world != null)
         {
+        	//forge
+        	Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, world));
+            //
             if (integratedserver != null)
             {
                 while (!integratedserver.isThreadAlive())
@@ -2006,6 +2583,9 @@
             this.ingameGUI.resetPlayersOverlayFooterHeader();
             this.currentServerData = null;
             this.integratedServerIsRunning = false;
+            //forge
+            Reflector.call(Reflector.ClientHooks_handleClientWorldClosing, world);
+            //
             this.game.leaveGameSession();
         }
 
@@ -2030,6 +2610,9 @@
         this.particles.clearEffects(worldIn);
         TileEntityRendererDispatcher.instance.setWorld(worldIn);
         this.func_230150_b_();
+        //Forge
+        Reflector.call(Reflector.MinecraftForgeClient_clearRenderCache);
+        //
     }
 
     public final boolean isDemo()
@@ -2062,6 +2645,16 @@
     {
         if (this.objectMouseOver != null && this.objectMouseOver.getType() != RayTraceResult.Type.MISS)
         {
+        	
+			Object inputEvent;
+			inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 2, this.gameSettings.keyBindPickBlock, Hand.MAIN_HAND);
+       	
+        	//Forge
+            if (inputEvent != null && !Reflector.callBoolean(inputEvent, Reflector.Event_isCanceled))
+            	Reflector.call(Reflector.ForgeHooks_onPickBlock, this.objectMouseOver, this.player, this.world);
+            if(inputEvent != null) return;
+            //
+            
             boolean flag = this.player.abilities.isCreativeMode;
             TileEntity tileentity = null;
             RayTraceResult.Type raytraceresult$type = this.objectMouseOver.getType();
@@ -2223,6 +2816,8 @@
                 }
             }
         }
+
+		physicalGuiManager.init(player);
     }
 
     private ItemStack storeTEInStack(ItemStack stack, TileEntity te)
@@ -2488,6 +3083,10 @@
 
     public MusicTicker.MusicType getAmbientMusicType()
     {
+    	//Forge
+        MusicTicker.MusicType type = this.world == null || this.world.dimension == null ? null : (MusicTicker.MusicType)Reflector.call(this.world.dimension, Reflector.Dimension_getMusicType);
+        if (type != null) return type;
+        //
         if (this.currentScreen instanceof WinGameScreen)
         {
             return MusicTicker.MusicType.CREDITS;
@@ -2716,8 +3315,12 @@
         {
             supplier = wrapV4(supplier);
         }
-
+    	//Forge
+    	if(Reflector.IForgeIResourcePack_isHidden.exists())
+    		return (ClientResourcePackInfo) Reflector.newInstance(Reflector.ClientResourcePackInfo_Constructor, name, isAlwaysEnabled, supplier, p_228011_3_, p_228011_4_, priority, Reflector.callBoolean(p_228011_3_,Reflector.IForgeIResourcePack_isHidden));   				
+    	else 
         return new ClientResourcePackInfo(name, isAlwaysEnabled, supplier, p_228011_3_, p_228011_4_, priority);
+    	//
     }
 
     private static Supplier<IResourcePack> wrapV3(Supplier<IResourcePack> p_228021_0_)
@@ -2740,4 +3343,501 @@
     {
         this.modelManager.setMaxMipmapLevel(p_228020_1_);
     }
+
+	// VIVECRAFT ADDITIONS
+	// **************************************************************************
+
+	public void printChatMessage(String msg) {
+		if (this.world != null) {
+			ITextComponent chatText = new StringTextComponent(msg);
+			this.ingameGUI.getChatGUI().printChatMessage(chatText);
+		}
+	}
+
+
+	public void printGLMatrix(String derp) {
+		GL11.glGetFloatv(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		matrixBuffer.rewind();
+		Matrix4f temp = new Matrix4f();
+		temp.load(matrixBuffer);
+		System.out.println(derp + "\r\n" + temp.toString());
+		matrixBuffer.rewind();
+	}
+
+	public void clearGLError() // bad bad bad
+	{
+		int var2 = GL11.glGetError();
+	}
+
+
+	private void copyToMirror() {
+		// VIVE start - render eye buffers to the desktop window
+
+		if (this.vrSettings.displayMirrorMode < VRSettings.MIRROR_OFF) // new values
+			this.vrSettings.displayMirrorMode = VRSettings.MIRROR_ON_CROPPED;
+
+		if (this.vrSettings.displayMirrorMode > VRSettings.MIRROR_ON_CROPPED) // new values
+			this.vrSettings.displayMirrorMode = VRSettings.MIRROR_ON_CROPPED;
+
+		if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF && MCOpenVR.isHMDTracking()) {
+			notifyMirror("Mirror is OFF", true, 1000);
+		} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY)  {
+			if (VRShaders._DepthMask_shaderProgramId != 0) {
+				doMixedRealityMirror();
+			} else {
+				notifyMirror("Shader compile failed, see log", true, 10000);
+			}
+		} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_DUAL){
+			Framebuffer source = stereoProvider.framebufferEye0;
+			Framebuffer source2 = stereoProvider.framebufferEye1;	
+
+			if (source != null)
+				source.framebufferRenderExt(0,
+						mainWindow.getWidth() / 2, mainWindow.getHeight(), 0, true,0,0, false);	
+
+			if (source2 != null)
+				source2.framebufferRenderExt((mainWindow.getWidth() / 2),
+						mainWindow.getWidth() / 2, mainWindow.getHeight(), 0, true,0,0, false);
+
+		}  
+		else {
+			float xcrop = 0;
+			float ycrop = 0;
+			boolean ar = false;
+			Framebuffer source = stereoProvider.framebufferEye0;
+			if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_FIRST_PERSON) {
+				source = stereoProvider.framebufferUndistorted;
+			} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON) {
+				source = stereoProvider.framebufferMR;
+			} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_SINGLE || this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF) {
+				if (!this.vrSettings.displayMirrorLeftEye)
+					source = stereoProvider.framebufferEye1;
+			} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_CROPPED) {
+				if (!this.vrSettings.displayMirrorLeftEye)
+					source = stereoProvider.framebufferEye1;
+				xcrop = 0.15f;
+				ycrop = 0.15f;
+				ar = true;
+			}
+			//debug
+			//	source = GuiHandler.guiFramebuffer;
+			//	source = stereoProvider.framebufferEye0;
+			//	source = stereoProvider.framebufferEye1;
+			//	source = GuiHandler.guiFramebuffer;
+
+			if (source != null)
+				source.framebufferRenderExt(0,mainWindow.getWidth(), mainWindow.getHeight(), 0, true, xcrop, ycrop, ar);
+		}
+	}
+
+	private void doMixedRealityMirror() {
+		boolean hasShaders = Config.isShaders();
+		boolean alphaMask = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+
+		if (!alphaMask)
+			GlStateManager.clearColor(vrSettings.mixedRealityKeyColor.getRed() / 255F,
+					vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F,
+					1);
+		else
+			GlStateManager.clearColor(0, 0, 0, 1);
+		
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+		Vec3d camplayer = vrPlayer.vrdata_room_pre.getHeadPivot().subtract(vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getPosition());	
+
+		net.minecraft.client.renderer.Matrix4f viewMatrix = vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transposed().toMCMatrix();
+		Vector3 CameraLook = vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transform(Vector3.forward());
+		
+		GlStateManager.useProgram(VRShaders._DepthMask_shaderProgramId);
+		
+		// set projection matrix
+		gameRenderer.thirdPassProjectionMatrix.write(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_projectionMatrix, false, matrixBuffer);
+
+		// set view matrix
+		viewMatrix.write(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_viewMatrix, false, matrixBuffer);
+
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float) camplayer.x, (float) camplayer.y,
+				(float) camplayer.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, (float) -CameraLook.getX(), 0,
+				(float) -CameraLook.getZ());
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform,
+				vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F,
+				vrSettings.mixedRealityKeyColor.getBlue() / 255F);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, alphaMask ? 1 : 0);
+
+		// bind color and depth textures
+		GlStateManager.activeTexture(GL13.GL_TEXTURE1);
+		stereoProvider.framebufferMR.bindFramebufferTexture();
+		
+		GlStateManager.activeTexture(GL13.GL_TEXTURE2);
+		if (hasShaders)
+			GlStateManager.bindTexture(Shaders.dfbDepthTextures.get(0)); // shadersmod has it's own depth buffer
+		else
+			GlStateManager.bindTexture(stereoProvider.framebufferMR.depthBuffer);
+		
+		GlStateManager.activeTexture(GL13.GL_TEXTURE0);
+		
+		for (int i = 0; i < (alphaMask ? 3 : 2); i++) {
+
+			int resW = mainWindow.getWidth() / 2;
+			int resH = mainWindow.getHeight();
+			int posW = (mainWindow.getWidth() / 2) * i;
+			int posH = 0;
+
+			if (this.vrSettings.mixedRealityUnityLike) {
+				resW = mainWindow.getWidth() / 2;
+				resH = mainWindow.getHeight() / 2;
+				if (this.vrSettings.mixedRealityAlphaMask && i == 2) {
+					posW = mainWindow.getWidth() / 2;
+					posH = mainWindow.getHeight() / 2;
+				} else {
+					posW = 0;
+					posH = (mainWindow.getHeight() / 2) * (1 - i);
+				}
+			}
+
+			// set other uniforms
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, resW, resH);
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, posW, posH);
+			ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+
+			// draw framebuffer
+			stereoProvider.framebufferMR.framebufferRenderExt(posW, resW, resH, posH, true,0,0, false);
+		}
+		
+		GlStateManager.useProgram(0);
+
+		if (this.vrSettings.mixedRealityUnityLike) {
+			if (this.vrSettings.mixedRealityMRPlusUndistorted)
+				stereoProvider.framebufferUndistorted.framebufferRenderExt(mainWindow.getWidth() / 2,
+						mainWindow.getWidth() / 2, mainWindow.getHeight() / 2, 0, true,0,0, false);
+			else
+				stereoProvider.framebufferEye0.framebufferRenderExt(mainWindow.getWidth() / 2,
+						mainWindow.getWidth() / 2, mainWindow.getHeight() / 2, 0, true,0,0, false);
+		}
+
+	}
+
+	private float fov = 1.0f;
+
+	private void checkGLError(String message) {
+		Config.checkGlError(message);
+	}
+
+	public void initMinecrift() throws Exception {
+		new MCOpenVR();
+		MCOpenVR.init();
+		this.stereoProvider = new OpenVRStereoRenderer();
+
+		this.vrPlayer = new OpenVRPlayer();
+		this.vrSettings.vrAllowCrawling = false;
+
+		stereoProvider.lastGuiScale = this.gameSettings.guiScale;
+
+		// register Trackers
+		vrPlayer.registerTracker(backpackTracker);
+		vrPlayer.registerTracker(bowTracker);
+		vrPlayer.registerTracker(climbTracker);
+		vrPlayer.registerTracker(autoFood);
+		vrPlayer.registerTracker(jumpTracker);
+		vrPlayer.registerTracker(rowTracker);
+		vrPlayer.registerTracker(runTracker);
+		vrPlayer.registerTracker(sneakTracker);
+		vrPlayer.registerTracker(swimTracker);
+		vrPlayer.registerTracker(swingTracker);
+		vrPlayer.registerTracker(interactTracker);
+		vrPlayer.registerTracker(teleportTracker);
+		vrPlayer.registerTracker(horseTracker);
+		vrPlayer.registerTracker(vehicleTracker);
+		vrPlayer.registerTracker(physicalGuiManager);
+	}
+
+	private static void sleepNanos(long nanoDelay) {
+		final long end = System.nanoTime() + nanoDelay;
+		do {
+			Thread.yield(); // This is a busy wait sadly...
+		} while (System.nanoTime() < end);
+	}
+
+	private void addRunTickTimeNanos(long runTickTime) {
+		int i = 0;
+		medianRunTickTimeNanos = runTickTime;
+
+		if (this.vrSettings.smoothRunTickCount < 1)
+			this.vrSettings.smoothRunTickCount = 1;
+
+		if (this.vrSettings.smoothRunTickCount % 2 == 0) {
+			// Need an odd number for this
+			this.vrSettings.smoothRunTickCount++;
+		}
+
+		runTickTimeNanos.addFirst(runTickTime);
+		while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+			runTickTimeNanos.removeLast();
+
+		if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount) {
+			Long[] array = new Long[runTickTimeNanos.size()];
+			for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++) {
+				array[i] = (Long) itr.next();
+			}
+			Arrays.sort(array);
+			medianRunTickTimeNanos = array[array.length / 2];
+		}
+	}
+
+	private long getMedianRunTickTimeNanos() {
+		return medianRunTickTimeNanos;
+	}
+
+	public void triggerYawTransition(boolean isPositive) {
+		// this.lookaimController.triggerYawTransition(isPositive);
+	}
+
+	public void print(String s) {
+		s = s.replace("\n", "\n[Minecrift] ");
+		System.out.println("[Minecrift] " + s);
+	}
+
+	public float watereffect, portaleffect, pumpkineffect;
+
+	private void renderSingleView(int eye, float nano, boolean renderworld) {
+
+		GlStateManager.clearColor(0, 0, 0, 1f);
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+		GlStateManager.enableTexture();
+		GlStateManager.enableDepthTest();
+
+		this.profiler.startSection("updateCameraAndRender");
+		if (!this.skipRenderWorld) {
+			// Forge calls onRenderTickStart > move to ER.drawFrameBuffer
+
+			/// THIS IS WHERE EVERYTHING IS RENDERED
+			this.gameRenderer.updateCameraAndRender(nano, System.nanoTime(), renderworld);
+
+			// Forge calls onRenderTickEnd > move to ER.drawFrameBuffer
+		}
+		this.profiler.endSection();
+		checkGLError("post game render " + eye);
+
+		gameRenderer.renderFaceOverlay(nano);
+		
+		if (currentPass == RenderPass.LEFT || currentPass == RenderPass.RIGHT) {
+			// copies the rendered scen-e to eye tex with fsaa and other postprocessing
+			// effects.
+			this.profiler.startSection("postprocesseye");
+
+			Framebuffer source = this.framebuffer;
+
+			if (this.vrSettings.useFsaa) {
+				this.profiler.startSection("fsaa");
+				stereoProvider.doFSAA(Config.isShaders());
+				source = stereoProvider.fsaaLastPassResultFBO;
+				checkGLError("fsaa " + eye);
+				this.profiler.endSection();
+			}
+
+			if (currentPass == RenderPass.LEFT)
+				stereoProvider.framebufferEye0.bindFramebuffer(true); // draw to L eye tex
+			else
+				stereoProvider.framebufferEye1.bindFramebuffer(true); // draw to R eye tex
+
+			if (vrSettings.useFOVReduction && vrPlayer.getFreeMove()) {
+				if (player != null && (Math.abs(player.moveForward) > 0 || Math.abs(player.moveStrafing) > 0)) {
+					fov -= 0.05;
+					if (fov < vrSettings.fovReductionMin)
+						fov = vrSettings.fovReductionMin;
+				} else {
+					fov += 0.01;
+					if (fov > 0.8)
+						fov = 0.8f;
+				}
+			} else {
+				fov = 1f;
+			}
+
+			ARBShaderObjects.glUseProgramObjectARB(VRShaders._FOVReduction_shaderProgramId);
+			ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+			ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_OffsetUniform, vrSettings.fovRedutioncOffset);
+
+			if (pumpkineffect > 0) {
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.3f);
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0f);
+			} else {
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, fov);
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06f);
+			}
+
+			// VIVE start - screen flash when hurt instead of view tilt
+			float r = 0, k = 0;
+			// VIVE start - screen flash when hurt instead of view tilt
+			float time = (float) Util.milliTime() / 1000;
+			if (player != null && world != null) {
+
+				if (gameRenderer.wasinwater != gameRenderer.inwater) {
+					watereffect = 2.3f;
+				} else {
+					if (gameRenderer.inwater) {
+						watereffect -= (1f / 120f);
+					} else {
+						watereffect -= (1f / 60f);
+					}
+					if (watereffect < 0)
+						watereffect = 0;
+				}
+
+				gameRenderer.wasinwater = gameRenderer.inwater;
+
+				if (Config.isShaders())
+					watereffect = 0; // dont stack.
+
+				if (gameRenderer.inportal) {
+					portaleffect = 1f;
+				} else {
+					portaleffect -= (1f / 60f);
+					if (portaleffect < 0)
+						portaleffect = 0;
+				}
+
+				float var3 = (float) player.hurtTime - nano;
+
+				float percent = 1 - player.getHealth() / player.getMaxHealth();
+				percent = (percent - 0.5f) * 0.75f;
+
+				if (var3 > 0.0f) {
+					var3 /= (float) player.maxHurtTime;
+					var3 = percent + MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+					r = var3;
+				} else {
+					r = (float) (percent * Math.abs(Math.sin(2.5f * time / (1 - percent + .1))));
+					if (player.isCreative())
+						r = 0;
+				}
+
+				if (gameRenderer.inblock && player.isAlive()) {
+					// k = (float) gameRenderer.itemRenderer.inBlock;
+				}
+
+				if (player.isSleeping()) {
+					if (k < 0.8)
+						k = .8f;
+				}
+
+				if (MCOpenVR.isWalkingAbout) {
+					if (k < 0.8)
+						k = .5f;
+				}
+
+			} else {
+				watereffect = 0;
+				portaleffect = 0;
+			}
+
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, r);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, k);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time, time);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, watereffect);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, portaleffect);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, pumpkineffect);
+			ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, currentPass == currentPass.LEFT ? 1 : -1);
+
+			source.framebufferRender(stereoProvider.framebufferEye0.framebufferWidth,
+					stereoProvider.framebufferEye0.framebufferHeight);
+
+			ARBShaderObjects.glUseProgramObjectARB(0);
+
+			checkGLError("post overlay" + eye);
+
+			this.profiler.endSection();
+
+			// this.mcProfiler.startSection("OpenGL Finish");
+			// GL11.glFinish();//DO NOT LEAVE THIS UNCOMMENTED
+			// this.mcProfiler.endSection();
+
+		}
+	}
+
+	private float frameDelta, prevFrameTime;
+
+	public float getFrameDelta() {
+		return frameDelta;
+	}
+
+	// FORGE
+	public ItemColors getItemColors() {
+		return this.itemColors;
+	}
+
+	public SearchTreeManager getSearchTreeManager() {
+		return this.searchTreeManager;
+	}
+	//
+
+	public void loadClassPath() {
+		File resourceRoot = new File("../src/resources");
+		if (!resourceRoot.exists() || !resourceRoot.isDirectory())
+			return;
+		Method method = null;
+		try {
+			method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+			method.setAccessible(true);
+			method.invoke(ClassLoader.getSystemClassLoader(), resourceRoot.toURI().toURL());
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+
+	}
+
+	long mirroNotifyStart;
+	String mirrorNotifyText;
+	boolean mirrorNotifyClear;
+	long mirroNotifyLen;
+	
+	public void notifyMirror( String text, boolean clear, int lengthMs) {
+		mirroNotifyStart = System.currentTimeMillis();
+		mirroNotifyLen = lengthMs;
+		mirrorNotifyText = text;
+		mirrorNotifyClear = clear;
+	}
+
+	private void drawNotifyMirror() {
+		if (System.currentTimeMillis() < mirroNotifyStart + mirroNotifyLen) {
+			
+			RenderSystem.viewport(0, 0, mainWindow.getWidth(), mainWindow.getHeight());
+			RenderSystem.matrixMode(5889);
+			RenderSystem.loadIdentity();
+			RenderSystem.ortho(0.0D, (double)mainWindow.getWidth() /4, (double)mainWindow.getHeight()/4, 0.0D, -10, 10);
+			RenderSystem.matrixMode(5888);
+			RenderSystem.loadIdentity();
+			RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+	
+			RenderSystem.fogMode(FogMode.EXP2); //dont ask
+			RenderSystem.fogDensity(0); //dont ask
+			RenderSystem.disableFog(); //ask why this does nothing
+			
+			if(mirrorNotifyClear) {
+				RenderSystem.clearColor(0, 0, 0, 0);
+				RenderSystem.clear(GL11.GL_COLOR_BUFFER_BIT, Minecraft.IS_RUNNING_ON_MAC);
+			}
+			
+			final int TEXT_WORDWRAP_LEN = mainWindow.getWidth()/22;
+	    	ArrayList<String> wrapped = new ArrayList<String>();
+	    	if (mirrorNotifyText != null)
+	    		org.vivecraft.utils.Utils.wordWrap(mirrorNotifyText, TEXT_WORDWRAP_LEN, wrapped);
+	    	int column = 1;
+	    	final int COLUMN_GAP = 12;    	
+	    	for (String line : wrapped)
+        	{
+        		fontRenderer.drawStringWithShadow(line, 1, column, /*white*/16777215);
+        		column += COLUMN_GAP;
+        	}
+	    	
+		}
+	}
+	
 }

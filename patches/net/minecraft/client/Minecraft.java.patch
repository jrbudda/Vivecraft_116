--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -10,6 +10,9 @@
 import com.mojang.authlib.properties.PropertyMap;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import com.mojang.blaze3d.matrix.MatrixStack;
+import com.mojang.blaze3d.platform.GLX;
+import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.GlStateManager.FogMode;
 import com.mojang.blaze3d.platform.PlatformDescriptors;
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.datafixers.DataFixer;
@@ -20,14 +23,25 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Queue;
@@ -37,14 +51,58 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 import java.util.function.Supplier;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import net.minecraft.block.Blocks;
+import net.minecraft.state.EnumProperty;
+import net.minecraft.state.StateContainer;
+import net.minecraft.util.*;
+import net.minecraft.util.Timer;
+import net.optifine.Config;
+import net.optifine.CustomItems;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.TextureUtils;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
+import org.lwjgl.opengl.GL30;
+import org.vivecraft.api.ErrorHelper;
+import org.vivecraft.api.NetworkHelper;
+import org.vivecraft.control.VRInputAction;
+import org.vivecraft.gameplay.OpenVRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.KeyboardHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.*;
+import org.vivecraft.gui.physical.PhysicalGuiManager;
+import org.vivecraft.menuworlds.MenuWorldRenderer;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.provider.OpenVRStereoRenderer;
+import org.vivecraft.render.PlayerModelController;
+import org.vivecraft.render.RenderConfigException;
+import org.vivecraft.render.VRShaders;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.VRFirstPersonArmSwing;
+import org.vivecraft.settings.AutoCalibration;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.settings.VRSettings.VrOptions;
+import org.vivecraft.utils.*;
+import org.vivecraft.utils.lwjgl.Matrix4f;
+import org.vivecraft.utils.math.Vector3;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockRenderType;
 import net.minecraft.block.BlockState;
 import net.minecraft.client.audio.BackgroundMusicSelector;
 import net.minecraft.client.audio.BackgroundMusicTracks;
 import net.minecraft.client.audio.MusicTicker;
+import net.minecraft.client.audio.SoundEngine;
 import net.minecraft.client.audio.SoundHandler;
 import net.minecraft.client.entity.player.ClientPlayerEntity;
 import net.minecraft.client.gui.DialogTexts;
@@ -88,10 +146,12 @@
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.FirstPersonRenderer;
 import net.minecraft.client.renderer.FogRenderer;
+import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GPUWarning;
 import net.minecraft.client.renderer.GameRenderer;
 import net.minecraft.client.renderer.IWindowEventListener;
 import net.minecraft.client.renderer.ItemRenderer;
+import net.minecraft.client.renderer.RenderHelper;
 import net.minecraft.client.renderer.RenderTypeBuffers;
 import net.minecraft.client.renderer.ScreenSize;
 import net.minecraft.client.renderer.Tessellator;
@@ -124,6 +184,7 @@
 import net.minecraft.client.settings.KeyBinding;
 import net.minecraft.client.settings.PointOfView;
 import net.minecraft.client.shader.Framebuffer;
+import net.minecraft.client.shader.FramebufferConstants;
 import net.minecraft.client.tutorial.Tutorial;
 import net.minecraft.client.util.IMutableSearchTree;
 import net.minecraft.client.util.ITooltipFlag;
@@ -209,6 +270,7 @@
 import net.minecraft.util.math.EntityRayTraceResult;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.vector.Vector3d;
 import net.minecraft.util.registry.Bootstrap;
 import net.minecraft.util.registry.DynamicRegistries;
 import net.minecraft.util.registry.Registry;
@@ -229,12 +291,83 @@
 import net.minecraft.world.storage.IServerConfiguration;
 import net.minecraft.world.storage.SaveFormat;
 import net.minecraft.world.storage.ServerWorldInfo;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorConstructor;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class Minecraft extends RecursiveEventLoop<Runnable> implements ISnooperInfo, IWindowEventListener
 {
     private static Minecraft instance;
+	// VIVE START - teleport movement
+	public OpenVRPlayer vrPlayer;
+	public BackpackTracker backpackTracker = new BackpackTracker(this);
+	public BowTracker bowTracker = new BowTracker(this);
+	public SwimTracker swimTracker = new SwimTracker(this);
+	public EatingTracker autoFood = new EatingTracker(this);
+	public JumpTracker jumpTracker = new JumpTracker(this);
+	public SneakTracker sneakTracker = new SneakTracker(this);
+	public ClimbTracker climbTracker = new ClimbTracker(this);
+	public RunTracker runTracker = new RunTracker(this);
+	public RowTracker rowTracker = new RowTracker(this);
+	public TeleportTracker teleportTracker = new TeleportTracker(this);
+	public SwingTracker swingTracker = new SwingTracker(this);
+	public HorseTracker horseTracker = new HorseTracker(this);
+	public VehicleTracker vehicleTracker = new VehicleTracker(this);
+	public PhysicalGuiManager physicalGuiManager = new PhysicalGuiManager(this);
+	public InteractTracker interactTracker = new InteractTracker(this);
+	public CrawlTracker crawlTracker = new CrawlTracker(this);
+
+	public ThreadGroup backgroundThreadGroup = new ThreadGroup("background");
+	// VIVE END - teleport movement
+
+	/** MINECRIFT */
+
+	public boolean minecriftDebug = false;
+	public final float PIOVER180 = (float) (Math.PI / 180);
+
+	public int lastShaderIndex = -1;
+	public Field fieldHwnd = null;
+	public Field fieldDisplay = null;
+	public Field fieldWindow = null;
+	public Field fieldResized = null;
+	public Method fieldResizedMethod = null;
+	public OpenVRStereoRenderer stereoProvider;
+	public VRSettings vrSettings;
+	public long lastIntegratedServerLaunchCheck = 0;
+	public boolean integratedServerLaunchInProgress = false;
+
+	public boolean grabScreenShot = false;
+	public boolean lastShowMouseNative = true;
+	public boolean enableWorldExport = false;
+	public SoundEngine sndManager = null;
+	public MenuWorldRenderer menuWorldRenderer;
+
+	private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+	private FloatBuffer matrixBuffer2 = GLAllocation.createDirectFloatBuffer(16);
+
+	private boolean firstInit = true;
+	public boolean showSplashScreen = true;
+	public long splashTimer1 = 0;
+	public long splashTimer2 = 0;
+	private Framebuffer splash;
+	private float splashFadeAlpha = 0;
+	public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+	public long medianRunTickTimeNanos = 0;
+	public long frameIndex = 0;
+	public ErrorHelper errorHelper;
+	public RenderPass currentPass;
+	private boolean lastClick;
+	public boolean resourcePacksChanged;
+
+	public int tickCounter;
+	/*
+	 * The minecriftVerString will be automatically updated by the build scripts, do
+	 * not modify here. Modify minecriftversion.py in root minecrift dir.
+	 */
+    public final String minecriftVerString = "Vivecraft 1.16.2 jrbudda-4-r1b5";
+	/* end version */
+	/** END MINECRIFT */
     private static final Logger LOGGER = LogManager.getLogger();
     public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.OS.OSX;
     public static final ResourceLocation DEFAULT_FONT_RENDERER_NAME = new ResourceLocation("default");
@@ -262,7 +395,7 @@
     public final DebugRenderer debugRenderer;
     private final AtomicReference<TrackingChunkStatusListener> refChunkStatusListener = new AtomicReference<>();
     public final IngameGui ingameGUI;
-    public final GameSettings gameSettings;
+    public GameSettings gameSettings;
     private final CreativeSettings creativeSettings;
     public final MouseHelper mouseHelper;
     public final KeyboardListener keyboardListener;
@@ -282,7 +415,7 @@
     private final LanguageManager languageManager;
     private final BlockColors blockColors;
     private final ItemColors itemColors;
-    private final Framebuffer framebuffer;
+    public Framebuffer framebuffer;
     private final SoundHandler soundHandler;
     private final MusicTicker musicTicker;
     private final FontResourceManager fontResourceMananger;
@@ -355,9 +488,12 @@
 
     public Minecraft(GameConfiguration gameConfig)
     {
-        super("Client");
-        instance = this;
-        this.gameDir = gameConfig.folderInfo.gameDir;
+    	super("Client");
+    	instance = this;
+    	//Forge
+    	Reflector.call(Reflector.ForgeHooksClient_invalidateLog4jThreadCache);
+    	//
+    	this.gameDir = gameConfig.folderInfo.gameDir;
         File file1 = gameConfig.folderInfo.assetsDir;
         this.fileResourcepacks = gameConfig.folderInfo.resourcePacksDir;
         this.launchedVersion = gameConfig.gameInfo.version;
@@ -368,8 +504,9 @@
         this.proxy = gameConfig.userInfo.proxy;
         this.sessionService = (new YggdrasilAuthenticationService(this.proxy, UUID.randomUUID().toString())).createMinecraftSessionService();
         this.session = gameConfig.userInfo.session;
-        LOGGER.info("Setting user: {}", (Object)this.session.getUsername());
-        LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
+        //Forge
+        //LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
+        //
         this.isDemo = gameConfig.gameInfo.isDemo;
         this.enableMultiplayer = !gameConfig.gameInfo.disableMultiplayer;
         this.enableChat = !gameConfig.gameInfo.disableChat;
@@ -393,6 +530,14 @@
         this.dataFixer = DataFixesManager.getDataFixer();
         this.toastGui = new ToastGui(this);
         this.tutorial = new Tutorial(this);
+    	/** MINECRIFT **/
+    	VRSettings.initSettings(this, gameDir);
+    	if (!vrSettings.badStereoProviderPluginID.isEmpty()) {
+    		vrSettings.stereoProviderPluginID = vrSettings.badStereoProviderPluginID;
+    		vrSettings.badStereoProviderPluginID = "";
+    		vrSettings.saveOptions();
+    	}
+    	/** END MINECRIFT **/
         this.thread = Thread.currentThread();
         this.gameSettings = new GameSettings(this, this.gameDir);
         this.creativeSettings = new CreativeSettings(this.gameDir, this.dataFixer);
@@ -426,14 +571,23 @@
 
         this.mainWindow.setFramerateLimit(this.gameSettings.framerateLimit);
         this.mouseHelper = new MouseHelper(this);
-        this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
+ //       this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
         this.keyboardListener = new KeyboardListener(this);
         this.keyboardListener.setupCallbacks(this.mainWindow.getHandle());
         RenderSystem.initRenderer(this.gameSettings.glDebugVerbosity, false);
-        this.framebuffer = new Framebuffer(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), true, IS_RUNNING_ON_MAC);
+    	//I would prefer to comment this out to ensure it isnt used, but Forge needs it or whatever.
+    	this.framebuffer = new Framebuffer(this.mainWindow.getWidth(), this.mainWindow.getHeight(), true, IS_RUNNING_ON_MAC);
         this.framebuffer.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
         this.resourceManager = new SimpleReloadableResourceManager(ResourcePackType.CLIENT_RESOURCES);
+    	//Forge
+    	Reflector.call(Reflector.ClientModLoader_begin, this, this.resourcePackRepository, this.resourceManager, this.packFinder);
+    	//
         this.resourcePackRepository.reloadPacksFromFinders();
+        //Forge
+        Object o = Reflector.call(Reflector.ForgeHooks_getModPacks);
+        if(o != null)
+        	Reflector.call(DatapackCodec.field_234880_a_, Reflector.DatapackCodec_addModPacks, o);
+        //
         this.gameSettings.fillResourcePackList(this.resourcePackRepository);
         this.languageManager = new LanguageManager(this.gameSettings.language);
         this.resourceManager.addReloadListener(this.languageManager);
@@ -450,10 +604,17 @@
         this.fontRenderer = this.fontResourceMananger.func_238548_a_();
         this.resourceManager.addReloadListener(this.fontResourceMananger.getReloadListener());
         this.func_238209_b_(this.getForceUnicodeFont());
+        /** MINECRIFT */
+        try {
+        	initMinecrift();
+        } catch (Exception e) {
+        	e.printStackTrace();
+        }
+        /** END MINECRIFT */
         this.resourceManager.addReloadListener(new GrassColorReloadListener());
         this.resourceManager.addReloadListener(new FoliageColorReloadListener());
         this.mainWindow.setRenderPhase("Startup");
-        RenderSystem.setupDefaultState(0, 0, this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
+    		RenderSystem.setupDefaultState(0, 0, this.mainWindow.getWidth(), this.mainWindow.getHeight());
         this.mainWindow.setRenderPhase("Post startup");
         this.blockColors = BlockColors.init();
         this.itemColors = ItemColors.init(this.blockColors);
@@ -473,6 +634,9 @@
         this.populateSearchTreeManager();
         this.resourceManager.addReloadListener(this.searchTreeManager);
         this.particles = new ParticleManager(this.world, this.textureManager);
+        //Forge
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.ParticleFactoryRegisterEvent_Constructor));
+        //
         this.resourceManager.addReloadListener(this.particles);
         this.paintingSprites = new PaintingSpriteUploader(this.textureManager);
         this.resourceManager.addReloadListener(this.paintingSprites);
@@ -480,7 +644,16 @@
         this.resourceManager.addReloadListener(this.potionSprites);
         this.field_241557_ar_ = new GPUWarning();
         this.resourceManager.addReloadListener(this.field_241557_ar_);
-        this.ingameGUI = new IngameGui(this);
+        //Forge
+        if(Reflector.ForgeIngameGui_Constructor.exists())
+        	this.ingameGUI = (IngameGui) Reflector.newInstance(Reflector.ForgeIngameGui_Constructor, this);
+        else
+        	this.ingameGUI = new IngameGui(this);
+        //Forge
+
+        //Forge
+        this.mouseHelper.registerCallbacks(this.mainWindow.getHandle()); //Forge: Moved below ingameGUI setting to prevent NPEs in handeler.
+        //
         this.debugRenderer = new DebugRenderer(this);
         RenderSystem.setErrorCallback(this::disableVSyncAfterGlError);
 
@@ -495,42 +668,72 @@
         this.mainWindow.setLogOnGlError();
         this.updateWindowSize();
 
-        if (s != null)
-        {
-            this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, s, i));
-        }
-        else
-        {
-            this.displayGuiScreen(new MainMenuScreen(true));
-        }
+    		//forge - fix vanilla bug
+    		//            if (s != null)
+    		//            {
+    		//                this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, s, i));
+    		//            }
+    		//            else
+    		//            {
+    		//                this.displayGuiScreen(new MainMenuScreen(true));
+        
+    	final String autoServerName = s;
+    	final int autoServerPort = i;
+    	//
+    	// VIVE
+    	menuWorldRenderer = new MenuWorldRenderer();
+    	vrSettings.firstRun = false;
+    	vrSettings.saveOptions();
+    	// END VIVE
+        
 
         ResourceLoadProgressGui.loadLogoTexture(this);
         List<IResourcePack> list = this.resourcePackRepository.func_232623_f_();
         this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (p_238197_1_) ->
         {
+    		// Vivecraft - post load
+    		if (stereoProvider.isInitialized())
+    			menuWorldRenderer.init();
+    		
+    		MCOpenVR.initInputAndApplication();
+    		//
             Util.acceptOrElse(p_238197_1_, this::restoreResourcePacks, () -> {
                 if (SharedConstants.developmentMode)
                 {
                     this.checkMissingData();
                 }
+    			//Forge
+
+    			if (Reflector.callBoolean(Reflector.ClientModLoader_completeModLoading)) return; // Do not overwrite the error screen
+    			// FORGE: Move opening initial screen to after startup and events are enabled.
+    			// Also Fixes MC-145102
+    			if (autoServerName != null) {
+    				this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, autoServerName, autoServerPort));
+    			} else {
+    				this.displayGuiScreen(new MainMenuScreen(true));
+    			}
+    			//
             });
         }, false));
     }
 
+    //updatewindowtitle
     public void func_230150_b_()
     {
         this.mainWindow.func_230148_b_(this.func_230149_ax_());
     }
 
+    //getwindowtitle
     private String func_230149_ax_()
     {
-        StringBuilder stringbuilder = new StringBuilder("Minecraft");
-
-        if (this.func_230151_c_())
-        {
-            stringbuilder.append("*");
-        }
-
+//Vivecraft
+        StringBuilder stringbuilder = new StringBuilder(minecriftVerString);
+//
+//        if (this.func_230151_c_())
+//        {
+//            stringbuilder.append("*");
+//        }
+//
         stringbuilder.append(" ");
         stringbuilder.append(SharedConstants.getVersion().getName());
         ClientPlayNetHandler clientplaynethandler = this.getConnection();
@@ -560,6 +763,7 @@
         return stringbuilder.toString();
     }
 
+    //is modded
     public boolean func_230151_c_()
     {
         return !"vanilla".equals(ClientBrandRetriever.getClientModName()) || Minecraft.class.getSigners() == null;
@@ -679,7 +883,12 @@
         });
         SearchTreeReloadable<ItemStack> searchtreereloadable = new SearchTreeReloadable<>((p_213235_0_) ->
         {
+        	//Forge
+        	if(Reflector.ForgeItem_getTags.exists())
+        		return ((java.util.Set) Reflector.call(p_213235_0_.getItem(),Reflector.ForgeItem_getTags)).stream();
+        	else
             return ItemTags.getCollection().getOwningTags(p_213235_0_.getItem()).stream();
+        	//
         });
         NonNullList<ItemStack> nonnulllist = NonNullList.create();
 
@@ -765,16 +974,25 @@
         if (report.getFile() != null)
         {
             Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + report.getFile());
+        	if(Reflector.ServerLifecycleHooks_handleExit.exists())
+        		Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+        	else
             System.exit(-1);
         }
         else if (report.saveToFile(file2))
         {
             Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
+        	if(Reflector.ServerLifecycleHooks_handleExit.exists())
+        		Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+        	else
             System.exit(-1);
         }
         else
         {
             Bootstrap.printToSYSOUT("#@?@# Game crashed! Crash report could not be saved. #@?@#");
+        	if(Reflector.ServerLifecycleHooks_handleExit.exists())
+        		Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -2);
+        	else
             System.exit(-2);
         }
     }
@@ -805,6 +1023,17 @@
                 List<IResourcePack> list = this.resourcePackRepository.func_232623_f_();
                 this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (p_238200_2_) ->
                 {
+                	//VIVECRAFT
+        			if (menuWorldRenderer.isReady() && resourcePacksChanged) {
+        				try {
+							menuWorldRenderer.destroy();
+							menuWorldRenderer.prepare();
+						} catch (Exception e) {
+        					e.printStackTrace();
+						}
+					}
+					resourcePacksChanged = false;
+					//
                     Util.acceptOrElse(p_238200_2_, this::restoreResourcePacks, () -> {
                         this.worldRenderer.loadRenderers();
                         completablefuture.complete((Void)null);
@@ -903,10 +1132,11 @@
 
     public void displayGuiScreen(@Nullable Screen guiScreenIn)
     {
-        if (this.currentScreen != null)
-        {
-            this.currentScreen.onClose();
-        }
+        //Forge
+    	//if (this.currentScreen != null)
+        //{
+        //    this.currentScreen.onClose();
+        //}
 
         if (guiScreenIn == null && this.world == null)
         {
@@ -923,13 +1153,26 @@
                 this.player.respawnPlayer();
             }
         }
-
+        //Forge
+        Screen old = this.currentScreen;
+        Object event = Reflector.newInstance(Reflector.GuiOpenEvent_Constructor, guiScreenIn);
+        if(event != null) {
+        	if (Reflector.postForgeBusEvent(event)) return;
+        	guiScreenIn = (Screen) Reflector.call(event,Reflector.GuiOpenEvent_getGui);
+        }
+        if (old != null && guiScreenIn != old)
+           old.onClose();
+        //
         if (guiScreenIn instanceof MainMenuScreen || guiScreenIn instanceof MultiplayerScreen)
         {
             this.gameSettings.showDebugInfo = false;
             this.ingameGUI.getChatGUI().clearChatMessages(true);
         }
 
+		// VIVECRAFT
+		GuiHandler.onScreenChanged(this.currentScreen, guiScreenIn, true);
+		// VIVECRAFT
+
         this.currentScreen = guiScreenIn;
 
         if (guiScreenIn != null)
@@ -991,6 +1234,12 @@
         finally
         {
             Util.nanoTimeSupplier = System::nanoTime;
+			// Vivecraft
+			try {
+				MCOpenVR.destroy();
+			} catch (Exception e) {
+			}
+			//
 
             if (this.crashReporter == null)
             {
@@ -1030,135 +1279,318 @@
 
     private void runGameLoop(boolean renderWorldIn)
     {
-        this.mainWindow.setRenderPhase("Pre render");
-        long i = Util.nanoTime();
-
-        if (this.mainWindow.shouldClose())
-        {
-            this.shutdown();
-        }
-
-        if (this.futureRefreshResources != null && !(this.loadingGui instanceof ResourceLoadProgressGui))
-        {
-            CompletableFuture<Void> completablefuture = this.futureRefreshResources;
-            this.futureRefreshResources = null;
-            this.reloadResources().thenRun(() ->
-            {
-                completablefuture.complete((Void)null);
-            });
-        }
+    	this.mainWindow.setRenderPhase("Pre render");
+    	long i = Util.nanoTime();
 
-        Runnable runnable;
+    	if (this.mainWindow.shouldClose())
+    	{
+    		this.shutdown();
+    	}
+
+    	if (this.futureRefreshResources != null && !(this.loadingGui instanceof ResourceLoadProgressGui))
+    	{
+    		CompletableFuture<Void> completablefuture = this.futureRefreshResources;
+    		this.futureRefreshResources = null;
+    		this.reloadResources().thenRun(() ->
+    		{
+    			completablefuture.complete((Void)null);
+    		});
+    	}
+
+    	Runnable runnable;
+
+    	while ((runnable = this.queueChunkTracking.poll()) != null)
+    	{
+    		runnable.run();
+    	}
+    	
+    	if (renderWorldIn)
+    	{
+	    	// VIVECRAFT
+			this.frameDelta = (i - this.prevFrameTime) / 1000000000F;
+			this.prevFrameTime = i;
+			// avoid having to change GLX
+			gameSettings.ofFastRender = false;
+	    	this.frameIndex++;
+	    	
+    		int j = this.timer.func_238400_a_(Util.milliTime());
+    		this.profiler.startSection("scheduledExecutables");
+    		this.drainTasks();
+    		this.profiler.endSection();
+    		
+	    	/** MINECRIFT setup the display, render buffers, shaders etc. */
+	    	try {
+	    		stereoProvider.setupRenderConfiguration();
+	    	} catch (RenderConfigException e) {
+	    		this.currentScreen = null;		
+	    		GlStateManager.viewport(0, 0, mainWindow.getWidth(), mainWindow.getHeight());
+	    		if (loadingGui != null) {
+	    			RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+	    			RenderSystem.matrixMode(5889);
+	    			RenderSystem.loadIdentity();
+	    			RenderSystem.ortho(0.0D, (double)mainWindow.getWidth() / mainWindow.getGuiScaleFactor(), (double)mainWindow.getHeight() / mainWindow.getGuiScaleFactor(), 0.0D, 1000.0D, 3000.0D);
+	    			RenderSystem.matrixMode(5888);
+	    			RenderSystem.loadIdentity();
+	    			RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
+	    			RenderHelper.setupGui3DDiffuseLighting();
+	    			loadingGui.render(new MatrixStack(), 0, 0, 0);
+	    		} else {
+	    			notifyMirror(LangHelper.get("vivecraft.messages.rendersetupfailed", e.error), true, 10000);
+	    			drawNotifyMirror();
+	    			if (this.frameIndex % 300 == 0)
+	    				System.out.println(e.title + " " + e.error);
+	    			try {
+	    				Thread.sleep(10);
+	    			} catch (InterruptedException e1) {
+	    			}
+	    		}		
+	    		mainWindow.flipFrame();
+	    		return;
+	    	} catch (Exception e) {
+	    		e.printStackTrace();
+	    	}
+	    	/** END MINECRIFT */
+	    	
+	    	// Poll sensors
+	    	this.profiler.startSection("VR Poll/VSync");
+	    		MCOpenVR.poll(frameIndex);
+	    	this.profiler.endSection();
+	    	vrPlayer.postPoll();
+	    	//    			
+
+    		this.profiler.startSection("tick");	
+
+    		for (int k = 0; k < Math.min(10, j); ++k)
+    		{
+    			this.profiler.func_230035_c_("clientTick");
+    			// VIVECRAFT
+    			vrPlayer.preTick();
+    			//
+    			this.runTick();
+    			// VIVECRAFT
+    			vrPlayer.postTick();
+    			//
+    			this.profiler.endSection();
+    		}
+    	}
+
+    	// avoid having to change GLX
+    	gameSettings.ofFastRender = false;
+
+    	this.profiler.endStartSection("setupRenderConfiguration");
+    	this.mouseHelper.updatePlayerLook();
+    	this.mainWindow.setRenderPhase("Render");
+
+    	// VIVECRAFT - Check again in case something changed during Tick.
+    	try {
+    		checkGLError("pre render setup ");
+    		stereoProvider.setupRenderConfiguration();
+    		checkGLError("post render setup ");
+    	} catch (Exception e) {
+    		e.printStackTrace();
+    	}
+    	// 1
 
-        while ((runnable = this.queueChunkTracking.poll()) != null)
-        {
-            runnable.run();
-        }
-
-        if (renderWorldIn)
-        {
-            int j = this.timer.func_238400_a_(Util.milliTime());
-            this.profiler.startSection("scheduledExecutables");
-            this.drainTasks();
-            this.profiler.endSection();
-            this.profiler.startSection("tick");
-
-            for (int k = 0; k < Math.min(10, j); ++k)
-            {
-                this.profiler.func_230035_c_("clientTick");
-                this.runTick();
-            }
+    	// Vivecraft
+    	float par1 = this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks;
 
-            this.profiler.endSection();
-        }
+    	this.profiler.endStartSection("preRender"); 	
+    	vrPlayer.preRender(par1);
 
-        this.mouseHelper.updatePlayerLook();
-        this.mainWindow.setRenderPhase("Render");
-        this.profiler.startSection("sound");
-        this.soundHandler.updateListener(this.gameRenderer.getActiveRenderInfo());
-        this.profiler.endSection();
-        this.profiler.startSection("render");
+    	/* Vivecraft
         RenderSystem.pushMatrix();
         RenderSystem.clear(16640, IS_RUNNING_ON_MAC);
         this.framebuffer.bindFramebuffer(true);
-        FogRenderer.resetFog();
-        this.profiler.startSection("display");
-        RenderSystem.enableTexture();
-        RenderSystem.enableCull();
-        this.profiler.endSection();
+	        this.profiler.startSection("display");
+	        this.profiler.endSection();
+    	 */   	
+    	FogRenderer.resetFog();
+    	RenderSystem.enableTexture();
+    	this.profiler.endSection();
+
+    	this.profiler.startSection("Gui");
+    	this.currentPass = RenderPass.GUI;
+
+    	//in case something needs it.
+    	this.gameRenderer.getActiveRenderInfo().update(this.world, this.getRenderViewEntity(), false, false, par1);
+
+    	//Forge - sure why not here?  	
+    	if (!this.skipRenderWorld)
+    	{    
+    		Reflector.call(Reflector.BasicEventHooks_onRenderTickStart, par1);
+    	}
+    	//     	
+
+    	GlStateManager.depthMask(true);
+    	GlStateManager.colorMask(true, true, true, true);
+
+    	// Render GUI to FBO if necessary
+    	this.framebuffer = GuiHandler.guiFramebuffer; // draw to 2d gui.
+    	this.framebuffer.bindFramebuffer(true);
+
+    	this.gameRenderer.drawFramebufferNEW(par1, renderWorldIn, new MatrixStack());
+
+    	if (KeyboardHandler.Showing && !this.vrSettings.physicalKeyboard) {
+    		this.framebuffer = KeyboardHandler.Framebuffer;
+    		this.framebuffer.bindFramebuffer(true);
+    		this.gameRenderer.drawScreen(par1, KeyboardHandler.UI,new MatrixStack());
+    	}
+
+    	if (RadialHandler.isShowing()) {
+    		this.framebuffer = RadialHandler.Framebuffer;
+    		this.framebuffer.bindFramebuffer(true);
+    		this.gameRenderer.drawScreen(par1, RadialHandler.UI,new MatrixStack());
+    	}
+
+    	checkGLError("post 2d ");
+    	VRHotkeys.updateMovingThirdPersonCam();
+    	//
+    	this.profiler.endStartSection("sound");
+    	this.currentPass = RenderPass.CENTER;
+    	this.soundHandler.updateListener(gameRenderer.getActiveRenderInfo());
+    	this.profiler.endSection();
+
+    	this.profiler.startSection("render");
+
+    	if (!this.skipRenderWorld)
+    	{
+    		// VIVECRAFT RENDERING MAIN
+    		if (minecriftDebug)
+    			print("FrameIndex: " + frameIndex);
+
+    		List<RenderPass> passes = this.stereoProvider.getRenderPasses();
+
+    		/** Minecrift - main stereo render loop **/
+    		for (RenderPass pass : passes) {
+    			this.currentPass = pass;
+    			switch (pass) {
+    			case LEFT:
+    			case RIGHT:
+    				this.framebuffer = stereoProvider.framebufferVrRender;
+    				break;
+    			case CENTER:
+    				this.framebuffer = stereoProvider.framebufferUndistorted;
+    				break;
+    			case THIRD:
+    				this.framebuffer = stereoProvider.framebufferMR;
+    				break;
+    			case SCOPEL:
+    				this.framebuffer = stereoProvider.telescopeFramebufferL;
+    				break;
+    			case SCOPER:
+    				this.framebuffer = stereoProvider.telescopeFramebufferR;
+    				break;
+    			}
+
+    			this.profiler.startSection("Eye:" + currentPass.ordinal());
+    			this.profiler.startSection("setup");
+    			this.framebuffer.bindFramebuffer(true); // draw to main texture for every pass
+    			this.profiler.endSection();
+    			RenderSystem.loadIdentity();
+    			renderSingleView(pass.ordinal(), par1, renderWorldIn);
+    			this.profiler.endSection(); // eye
+
+    			if (grabScreenShot) {
+    				boolean inPass;
+    				if (passes.contains(RenderPass.CENTER)) {
+    					inPass = (pass == RenderPass.CENTER);
+    				} else {
+    					inPass = vrSettings.displayMirrorLeftEye ? (pass == RenderPass.LEFT) : (pass == RenderPass.RIGHT);
+    				}
+
+    				if (inPass) {
+    					this.framebuffer.unbindFramebuffer();
+    					// GLX.fbo = false; // huh?
+    					ScreenShotHelper.saveScreenshot(this.gameDir, this.framebuffer.framebufferWidth,
+    							this.framebuffer.framebufferHeight, this.framebuffer, (text) -> {
+    								// this.addScheduledTask(() -> {
+    								// this.ingameGUI.getChatGUI().printChatMessage(text);
+    								// });
+    							});
+    					// GLX.fbo = true; // what is this?
+    					grabScreenShot = false;
+    				}
+    			}
+    		} // end per eye rendering.
+
+    		
+    		//VIVECRAFT
+    		if(renderWorldIn) {
+    			//
+    			vrPlayer.postRender(par1);
+	    		//
+	
+	    		profiler.startSection("Display/Reproject");
+	    		try {
+	    			this.stereoProvider.endFrame();
+	    		} catch (Exception e) {
+	    			LOGGER.error(e.toString());
+	    		}
+	    		profiler.endSection();
+	
+	    		checkGLError("post submit ");	   			
+    		}
+    		//
+    		
+    		//Forge - sure why not here?  	
+    		if (!this.skipRenderWorld)
+    		{    
+    			Reflector.call(Reflector.BasicEventHooks_onRenderTickEnd, par1);
+    		}
+    		//    
+
+    		this.profiler.startSection("mirror");
+    		this.framebuffer.unbindFramebuffer(); // draw directly to window
+    		copyToMirror();
+    		drawNotifyMirror();
+    		checkGLError("post-mirror ");
+    		this.profiler.endSection();
+
+    		//// END MAIN VIVECRAFT RENDERING
+    	}
+
+    	this.getProfiler().endSection(); //render
+
+    	this.mainWindow.setRenderPhase("Post render");
+    	this.mainWindow.flipFrame();
+
+    	++this.fpsCounter;
+    	boolean flag = this.isSingleplayer() && (this.currentScreen != null && this.currentScreen.isPauseScreen() || this.loadingGui != null && this.loadingGui.isPauseScreen()) && !this.integratedServer.getPublic();
+
+    	if (this.isGamePaused != flag)
+    	{
+    		if (this.isGamePaused)
+    		{
+    			this.renderPartialTicksPaused = this.timer.renderPartialTicks;
+    		}
+    		else
+    		{
+    			this.timer.renderPartialTicks = this.renderPartialTicksPaused;
+    		}
+
+    		this.isGamePaused = flag;
+    	}
+
+    	long l = Util.nanoTime();
+    	this.frameTimer.addFrame(l - this.startNanoTime);
+    	this.startNanoTime = l;
+    	this.profiler.startSection("fpsUpdate");
+
+    	while (Util.milliTime() >= this.debugUpdateTime + 1000L)
+    	{
+    		debugFPS = this.fpsCounter;
+    		this.debug = String.format("%d fps T: %s%s%s%s B: %d", debugFPS, (double)this.gameSettings.framerateLimit == AbstractOption.FRAMERATE_LIMIT.getMaxValue() ? "inf" : this.gameSettings.framerateLimit, this.gameSettings.vsync ? " vsync" : "", this.gameSettings.graphicFanciness.toString(), this.gameSettings.cloudOption == CloudOption.OFF ? "" : (this.gameSettings.cloudOption == CloudOption.FAST ? " fast-clouds" : " fancy-clouds"), this.gameSettings.biomeBlendRadius);
+    		this.debugUpdateTime += 1000L;
+    		this.fpsCounter = 0;
+    		this.snooper.addMemoryStatsToSnooper();
+
+    		if (!this.snooper.isSnooperRunning())
+    		{
+    			this.snooper.start();
+    		}
+    	}
 
-        if (!this.skipRenderWorld)
-        {
-            this.profiler.endStartSection("gameRenderer");
-            this.gameRenderer.updateCameraAndRender(this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks, i, renderWorldIn);
-            this.profiler.endStartSection("toasts");
-            this.toastGui.func_238541_a_(new MatrixStack());
-            this.profiler.endSection();
-        }
-
-        if (this.field_238174_aV_ != null)
-        {
-            this.profiler.startSection("fpsPie");
-            this.func_238183_a_(new MatrixStack(), this.field_238174_aV_);
-            this.profiler.endSection();
-        }
-
-        this.profiler.startSection("blit");
-        this.framebuffer.unbindFramebuffer();
-        RenderSystem.popMatrix();
-        RenderSystem.pushMatrix();
-        this.framebuffer.framebufferRender(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
-        RenderSystem.popMatrix();
-        this.profiler.endStartSection("updateDisplay");
-        this.mainWindow.flipFrame();
-        int i1 = this.getFramerateLimit();
-
-        if ((double)i1 < AbstractOption.FRAMERATE_LIMIT.getMaxValue())
-        {
-            RenderSystem.limitDisplayFPS(i1);
-        }
-
-        this.profiler.endStartSection("yield");
-        Thread.yield();
-        this.profiler.endSection();
-        this.mainWindow.setRenderPhase("Post render");
-        ++this.fpsCounter;
-        boolean flag = this.isSingleplayer() && (this.currentScreen != null && this.currentScreen.isPauseScreen() || this.loadingGui != null && this.loadingGui.isPauseScreen()) && !this.integratedServer.getPublic();
-
-        if (this.isGamePaused != flag)
-        {
-            if (this.isGamePaused)
-            {
-                this.renderPartialTicksPaused = this.timer.renderPartialTicks;
-            }
-            else
-            {
-                this.timer.renderPartialTicks = this.renderPartialTicksPaused;
-            }
-
-            this.isGamePaused = flag;
-        }
-
-        long l = Util.nanoTime();
-        this.frameTimer.addFrame(l - this.startNanoTime);
-        this.startNanoTime = l;
-        this.profiler.startSection("fpsUpdate");
-
-        while (Util.milliTime() >= this.debugUpdateTime + 1000L)
-        {
-            debugFPS = this.fpsCounter;
-            this.debug = String.format("%d fps T: %s%s%s%s B: %d", debugFPS, (double)this.gameSettings.framerateLimit == AbstractOption.FRAMERATE_LIMIT.getMaxValue() ? "inf" : this.gameSettings.framerateLimit, this.gameSettings.vsync ? " vsync" : "", this.gameSettings.graphicFanciness.toString(), this.gameSettings.cloudOption == CloudOption.OFF ? "" : (this.gameSettings.cloudOption == CloudOption.FAST ? " fast-clouds" : " fancy-clouds"), this.gameSettings.biomeBlendRadius);
-            this.debugUpdateTime += 1000L;
-            this.fpsCounter = 0;
-            this.snooper.addMemoryStatsToSnooper();
-
-            if (!this.snooper.isSnooperRunning())
-            {
-                this.snooper.start();
-            }
-        }
-
-        this.profiler.endSection();
+    	this.profiler.endSection();
     }
 
     private boolean func_238202_aF_()
@@ -1210,14 +1642,14 @@
         int i = this.mainWindow.calcGuiScale(this.gameSettings.guiScale, this.getForceUnicodeFont());
         this.mainWindow.setGuiScale((double)i);
 
+		if (stereoProvider != null)
+			stereoProvider.reinitFrameBuffers("Main Window Changed");
+
         if (this.currentScreen != null)
         {
             this.currentScreen.resize(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
         }
 
-        Framebuffer framebuffer = this.getFramebuffer();
-        framebuffer.resize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
-        this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
         this.mouseHelper.setIgnoreFirstMove();
     }
 
@@ -1299,8 +1731,17 @@
             }
         }
     }
+    
+    public void drawProfiler(){
+      if (this.field_238174_aV_ != null)
+        {
+            this.profiler.startSection("fpsPie");
+            this.drawProfiler(new MatrixStack(), this.field_238174_aV_);
+            this.profiler.endSection();
+        }
+    }
 
-    private void func_238183_a_(MatrixStack p_238183_1_, IProfileResult p_238183_2_)
+    public void drawProfiler(MatrixStack p_238183_1_, IProfileResult p_238183_2_)
     {
         List<DataPoint> list = p_238183_2_.getDataPoints(this.debugProfilerName);
         DataPoint datapoint = list.remove(0);
@@ -1316,14 +1757,15 @@
         Tessellator tessellator = Tessellator.getInstance();
         BufferBuilder bufferbuilder = tessellator.getBuffer();
         int i = 160;
-        int j = this.mainWindow.getFramebufferWidth() - 160 - 10;
-        int k = this.mainWindow.getFramebufferHeight() - 320;
+            int j = this.mainWindow.getFramebufferWidth()/3;
+            int k = this.mainWindow.getFramebufferHeight()/9;
         RenderSystem.enableBlend();
+            RenderSystem.scaled(2.2, 2.7, 1);
         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
         bufferbuilder.pos((double)((float)j - 176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
         bufferbuilder.pos((double)((float)j - 176.0F), (double)(k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
         bufferbuilder.pos((double)((float)j + 176.0F), (double)(k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
-        bufferbuilder.pos((double)((float)j + 176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
+            bufferbuilder.pos((double)((float)j + 4*176.0F), (double)((float)k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
         tessellator.draw();
         RenderSystem.disableBlend();
         double d0 = 0.0D;
@@ -1387,9 +1829,9 @@
         }
 
         int k2 = 16777215;
-        this.fontRenderer.drawStringWithShadow(p_238183_1_, s1, (float)(j - 160), (float)(k - 80 - 16), 16777215);
+            this.fontRenderer.drawStringWithShadow(p_238183_1_, s1, (float)(j - 160), (float)(k - 80 - 16), 16777215);
         s1 = decimalformat.format(datapoint.rootRelTime) + "%";
-        this.fontRenderer.drawStringWithShadow(p_238183_1_, s1, (float)(j + 160 - this.fontRenderer.getStringWidth(s1)), (float)(k - 80 - 16), 16777215);
+            this.fontRenderer.drawStringWithShadow(p_238183_1_, s1, (float)(j + 160 - this.fontRenderer.getStringWidth(s1)), (float)(k - 80 - 16), 16777215);
 
         for (int j2 = 0; j2 < list.size(); ++j2)
         {
@@ -1444,34 +1886,54 @@
 
     private void sendClickBlockToController(boolean leftClick)
     {
-        if (!leftClick)
-        {
-            this.leftClickCounter = 0;
-        }
-
-        if (this.leftClickCounter <= 0 && !this.player.isHandActive())
-        {
-            if (leftClick && this.objectMouseOver != null && this.objectMouseOver.getType() == RayTraceResult.Type.BLOCK)
-            {
-                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
-                BlockPos blockpos = blockraytraceresult.getPos();
-
-                if (!this.world.getBlockState(blockpos).isAir())
-                {
-                    Direction direction = blockraytraceresult.getFace();
-
-                    if (this.playerController.onPlayerDamageBlock(blockpos, direction))
-                    {
-                        this.particles.addBlockHitEffects(blockpos, direction);
-                        this.player.swingArm(Hand.MAIN_HAND);
-                    }
-                }
-            }
-            else
-            {
-                this.playerController.resetBlockRemoving();
-            }
-        }
+    	if (!leftClick)
+    	{
+    		this.leftClickCounter = 0;
+    	}
+
+    	if (this.leftClickCounter <= 0 && !this.player.isHandActive())
+    	{
+    		if (leftClick && this.objectMouseOver != null && this.objectMouseOver.getType() == RayTraceResult.Type.BLOCK)
+    		{
+    			BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
+    			BlockPos blockpos = blockraytraceresult.getPos();
+
+    			Object inputEvent = null;
+    			if (!this.world.isAirBlock(blockpos)) {
+    				//Forge
+    				inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.gameSettings.keyBindAttack, Hand.MAIN_HAND);
+    				if (inputEvent !=null && Reflector.callBoolean(inputEvent,  Reflector.Event_isCanceled)) {
+    					if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) {
+    						this.particles.addBlockHitEffects(blockpos, blockraytraceresult);
+    						this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);        			
+    					}
+    					return;
+    				}
+    				//
+    				Direction direction = blockraytraceresult.getFace();
+
+    				if (this.playerController.onPlayerDamageBlock(blockpos, direction))
+    				{
+    					//Forge
+    					if(inputEvent != null) {
+    						if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) {
+    							this.particles.addBlockHitEffects(blockpos, blockraytraceresult);
+    							this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+    						}
+    					} else {
+    						this.particles.addBlockHitEffects(blockpos, direction);
+    						this.player.swingArm(Hand.MAIN_HAND, VRFirstPersonArmSwing.Attack);        			
+    					}
+    				}
+    			}
+    		}
+    		//Vivecraft only if seated
+    		else if (vrSettings.seated)
+   			//
+    		{
+    			this.playerController.resetBlockRemoving();
+    		}
+    	}
     }
 
     private void clickMouse()
@@ -1489,6 +1951,12 @@
             }
             else if (!this.player.isRowingBoat())
             {
+            	Object inputEvent;
+            	//Forge
+				inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.gameSettings.keyBindAttack, Hand.MAIN_HAND);
+
+                if (inputEvent == null || !Reflector.callBoolean(inputEvent,  Reflector.Event_isCanceled))
+                	//
                 switch (this.objectMouseOver.getType())
                 {
                     case ENTITY:
@@ -1499,7 +1967,7 @@
                         BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
                         BlockPos blockpos = blockraytraceresult.getPos();
 
-                        if (!this.world.getBlockState(blockpos).isAir())
+                        if (!this.world.isAirBlock(blockpos))
                         {
                             this.playerController.clickBlock(blockpos, blockraytraceresult.getFace());
                             break;
@@ -1510,103 +1978,139 @@
                         {
                             this.leftClickCounter = 10;
                         }
-
                         this.player.resetCooldown();
-                }
-
-                this.player.swingArm(Hand.MAIN_HAND);
-            }
-        }
-    }
-
-    private void rightClickMouse()
-    {
-        if (!this.playerController.getIsHittingBlock())
-        {
-            this.rightClickDelayTimer = 4;
-
-            if (!this.player.isRowingBoat())
-            {
-                if (this.objectMouseOver == null)
-                {
-                    LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
-                }
-
-                for (Hand hand : Hand.values())
-                {
-                    ItemStack itemstack = this.player.getHeldItem(hand);
-
-                    if (this.objectMouseOver != null)
-                    {
-                        switch (this.objectMouseOver.getType())
-                        {
-                            case ENTITY:
-                                EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult)this.objectMouseOver;
-                                Entity entity = entityraytraceresult.getEntity();
-                                ActionResultType actionresulttype = this.playerController.interactWithEntity(this.player, entity, entityraytraceresult, hand);
-
-                                if (!actionresulttype.isSuccessOrConsume())
-                                {
-                                    actionresulttype = this.playerController.interactWithEntity(this.player, entity, hand);
-                                }
-
-                                if (actionresulttype.isSuccessOrConsume())
-                                {
-                                    if (actionresulttype.isSuccess())
-                                    {
-                                        this.player.swingArm(hand);
-                                    }
-
-                                    return;
-                                }
-
-                                break;
-
-                            case BLOCK:
-                                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
-                                int i = itemstack.getCount();
-                                ActionResultType actionresulttype1 = this.playerController.func_217292_a(this.player, this.world, hand, blockraytraceresult);
-
-                                if (actionresulttype1.isSuccessOrConsume())
-                                {
-                                    if (actionresulttype1.isSuccess())
-                                    {
-                                        this.player.swingArm(hand);
-
-                                        if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode()))
-                                        {
-                                            this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
-                                        }
-                                    }
-
-                                    return;
-                                }
-
-                                if (actionresulttype1 == ActionResultType.FAIL)
-                                {
-                                    return;
-                                }
-                        }
-                    }
-
-                    if (!itemstack.isEmpty())
-                    {
-                        ActionResultType actionresulttype2 = this.playerController.processRightClick(this.player, this.world, hand);
-
-                        if (actionresulttype2.isSuccessOrConsume())
-                        {
-                            if (actionresulttype2.isSuccess())
-                            {
-                                this.player.swingArm(hand);
-                            }
-
-                            this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
-                            return;
-                        }
-                    }
-                }
-            }
-        }
+                        //Forge
+                        Reflector.call(Reflector.ForgeHooks_onEmptyLeftClick, this.player);
+                        //
+                }
+                
+                if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+                	this.player.swingArm(Hand.MAIN_HAND);
+            }
+        }
+    }
+
+    public void rightClickMouse()
+    {
+    	//Vivecraft check seated
+    	if (!this.playerController.getIsHittingBlock() || vrSettings.seated == false) {
+    		//
+    		//Vivecraft delay
+    		this.rightClickDelayTimer = vrSettings.seated ? 4 : vrSettings.rightclickDelay; 
+    		//
+
+    		if (!this.player.isRowingBoat())
+    		{
+    			if (this.objectMouseOver == null)
+    			{
+    				LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
+    			}
+
+    			for (Hand hand : Hand.values())
+    			{
+    				Object inputEvent;
+    				inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 1, this.gameSettings.keyBindUseItem, hand);
+
+    				if (inputEvent !=null && Reflector.callBoolean(inputEvent,  Reflector.Event_isCanceled)) {
+    					if (Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand)) 
+    						this.player.swingArm(hand);
+    					return;
+    				}
+
+    				ItemStack itemstack = this.player.getHeldItem(hand);
+    				if(TelescopeTracker.isTelescope(itemstack))
+    					continue;
+    				//Vivecraft
+    				NetworkHelper.sendActiveHand((byte) hand.ordinal());
+    				//
+    				if (this.objectMouseOver != null)
+    				{
+    					switch (this.objectMouseOver.getType())
+    					{
+    					case ENTITY:
+    						//ft where are you
+    						physicalGuiManager.preClickAction();
+    						//
+    						EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult)this.objectMouseOver;
+    						Entity entity = entityraytraceresult.getEntity();
+    						ActionResultType actionresulttype = this.playerController.interactWithEntity(this.player, entity, entityraytraceresult, hand);
+
+    						if (!actionresulttype.isSuccessOrConsume())
+    						{
+    							actionresulttype = this.playerController.interactWithEntity(this.player, entity, hand);
+    						}
+
+    						if (actionresulttype.isSuccessOrConsume())
+    						{
+    							if (actionresulttype.isSuccess())
+    							{
+    								//Vivecraft
+									if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+    								this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+    								//
+    							}
+
+    							return;
+    						}
+
+    						break;
+
+    					case BLOCK:
+    						BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult)this.objectMouseOver;
+    						int i = itemstack.getCount();
+    						ActionResultType actionresulttype1 = this.playerController.func_217292_a(this.player, this.world, hand, blockraytraceresult);
+
+    						if (actionresulttype1.isSuccessOrConsume())
+    						{
+    							if (actionresulttype1.isSuccess())
+    							{
+    								//Vivecraft
+    								if (inputEvent == null || Reflector.callBoolean(inputEvent, Reflector.ClickInputEvent_shouldSwingHand))
+    									this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+    								//
+    								if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode()))
+    								{
+    									this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
+    								}
+    							}
+
+    							return;
+    						}
+
+    						if (actionresulttype1 == ActionResultType.FAIL)
+    						{
+    							return;
+    						}
+    					}
+    				}
+    				//pi stuff
+    				physicalGuiManager.preClickAction();
+    				//
+    				//Forge
+    				if (itemstack.isEmpty() && (this.objectMouseOver == null || this.objectMouseOver.getType() == RayTraceResult.Type.MISS))
+    					Reflector.call(Reflector.ForgeHooks_onEmptyClick, this.player, hand);
+    				//
+    				if (!itemstack.isEmpty())
+    				{
+    		
+    					ActionResultType actionresulttype2 = this.playerController.processRightClick(this.player, this.world, hand);
+
+    					if (actionresulttype2.isSuccessOrConsume())
+    					{
+    						if (actionresulttype2.isSuccess())
+    						{
+    							//Vivecraft
+    							this.player.swingArm(hand, VRFirstPersonArmSwing.Use);
+    							//
+    						}
+
+    						this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
+    						return;
+    					}
+    				}
+    			}
+    		}
+    	}
     }
 
     public MusicTicker getMusicTicker()
@@ -1616,187 +2120,230 @@
 
     public void runTick()
     {
-        if (this.rightClickDelayTimer > 0)
-        {
-            --this.rightClickDelayTimer;
-        }
-
-        this.profiler.startSection("gui");
-
-        if (!this.isGamePaused)
-        {
-            this.ingameGUI.tick();
-        }
-
-        this.profiler.endSection();
-        this.gameRenderer.getMouseOver(1.0F);
-        this.tutorial.onMouseHover(this.world, this.objectMouseOver);
-        this.profiler.startSection("gameMode");
-
-        if (!this.isGamePaused && this.world != null)
-        {
-            this.playerController.tick();
-        }
-
-        this.profiler.endStartSection("textures");
-
-        if (this.world != null)
-        {
-            this.textureManager.tick();
-        }
-
-        if (this.currentScreen == null && this.player != null)
-        {
-            if (this.player.getShouldBeDead() && !(this.currentScreen instanceof DeathScreen))
-            {
-                this.displayGuiScreen((Screen)null);
-            }
-            else if (this.player.isSleeping() && this.world != null)
-            {
-                this.displayGuiScreen(new SleepInMultiplayerScreen());
-            }
-        }
-        else if (this.currentScreen != null && this.currentScreen instanceof SleepInMultiplayerScreen && !this.player.isSleeping())
-        {
-            this.displayGuiScreen((Screen)null);
-        }
-
-        if (this.currentScreen != null)
-        {
-            this.leftClickCounter = 10000;
-        }
-
-        if (this.currentScreen != null)
-        {
-            Screen.wrapScreenError(() ->
-            {
-                this.currentScreen.tick();
-            }, "Ticking screen", this.currentScreen.getClass().getCanonicalName());
-        }
-
-        if (!this.gameSettings.showDebugInfo)
-        {
-            this.ingameGUI.reset();
-        }
-
-        if (this.loadingGui == null && (this.currentScreen == null || this.currentScreen.passEvents))
-        {
-            this.profiler.endStartSection("Keybindings");
-            this.processKeyBinds();
-
-            if (this.leftClickCounter > 0)
-            {
-                --this.leftClickCounter;
-            }
-        }
-
-        if (this.world != null)
-        {
-            this.profiler.endStartSection("gameRenderer");
-
-            if (!this.isGamePaused)
-            {
-                this.gameRenderer.tick();
-            }
-
-            this.profiler.endStartSection("levelRenderer");
-
-            if (!this.isGamePaused)
-            {
-                this.worldRenderer.tick();
-            }
-
-            this.profiler.endStartSection("level");
-
-            if (!this.isGamePaused)
-            {
-                if (this.world.getTimeLightningFlash() > 0)
-                {
-                    this.world.setTimeLightningFlash(this.world.getTimeLightningFlash() - 1);
-                }
-
-                this.world.tickEntities();
-            }
-        }
-        else if (this.gameRenderer.getShaderGroup() != null)
-        {
-            this.gameRenderer.stopUseShader();
-        }
-
-        if (!this.isGamePaused)
-        {
-            this.musicTicker.tick();
-        }
-
-        this.soundHandler.tick(this.isGamePaused);
-
-        if (this.world != null)
-        {
-            if (!this.isGamePaused)
-            {
-                this.tutorial.tick();
-
-                try
-                {
-                    this.world.tick(() ->
-                    {
-                        return true;
-                    });
-                }
-                catch (Throwable throwable)
-                {
-                    CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception in world tick");
-
-                    if (this.world == null)
-                    {
-                        CrashReportCategory crashreportcategory = crashreport.makeCategory("Affected level");
-                        crashreportcategory.addDetail("Problem", "Level is null!");
-                    }
-                    else
-                    {
-                        this.world.fillCrashReport(crashreport);
-                    }
-
-                    throw new ReportedException(crashreport);
-                }
-            }
-
-            this.profiler.endStartSection("animateTick");
-
-            if (!this.isGamePaused && this.world != null)
-            {
-                this.world.animateTick(MathHelper.floor(this.player.getPosX()), MathHelper.floor(this.player.getPosY()), MathHelper.floor(this.player.getPosZ()));
-            }
-
-            this.profiler.endStartSection("particles");
-
-            if (!this.isGamePaused)
-            {
-                this.particles.tick();
-            }
-        }
-        else if (this.networkManager != null)
-        {
-            this.profiler.endStartSection("pendingConnection");
-            this.networkManager.tick();
-        }
-
-        this.profiler.endStartSection("keyboard");
-        this.keyboardListener.tick();
-        this.profiler.endSection();
+    	//Vivecraft y do we put this here
+    	this.tickCounter++;
+    	//
+    	if (this.rightClickDelayTimer > 0)
+    	{
+    		--this.rightClickDelayTimer;
+    	}
+    	//Forge
+    	Reflector.call(Reflector.BasicEventHooks_onPreClientTick);
+    	//
+    	this.profiler.startSection("guitick");
+
+    	if (!this.isGamePaused)
+    	{
+    		this.ingameGUI.tick();
+    	}
+
+    	this.profiler.endSection();
+    	//this.gameRenderer.getMouseOver(1.0F);
+    	this.tutorial.onMouseHover(this.world, this.objectMouseOver);
+    	this.profiler.startSection("gameMode");
+
+    	if (!this.isGamePaused && this.world != null)
+    	{
+    		this.playerController.tick();
+    	}
+
+    	this.profiler.endStartSection("textures");
+
+    	// Vivecraft tick the main menu too
+    	// if (this.world != null)
+    	// {
+    	this.textureManager.tick();
+    	// }
+
+    	if (this.currentScreen == null && this.player != null)
+    	{
+    		if (this.player.getShouldBeDead() && !(this.currentScreen instanceof DeathScreen))
+    		{
+    			this.displayGuiScreen((Screen)null);
+    		}
+    		else if (this.player.isSleeping() && this.world != null)
+    		{
+    			this.displayGuiScreen(new SleepInMultiplayerScreen());
+    		}
+    	}
+    	else if (this.currentScreen != null && this.currentScreen instanceof SleepInMultiplayerScreen && !this.player.isSleeping())
+    	{
+    		this.displayGuiScreen((Screen)null);
+    	}
+
+
+    	if (this.currentScreen != null)
+    	{
+    		this.leftClickCounter = 10000;
+    	}
+
+    	if (this.currentScreen != null)
+    	{
+    		Screen.wrapScreenError(() ->
+    		{
+    			this.currentScreen.tick();
+    		}, "Ticking screen", this.currentScreen.getClass().getCanonicalName());
+    	}
+
+    	if (!this.gameSettings.showDebugInfo)
+    	{
+    		this.ingameGUI.reset();
+    	}
+    	// Vivecraft
+    	this.profiler.endStartSection("vrProcessInputs");
+    	MCOpenVR.processInputs();
+    	MCOpenVR.processBindings();
+    	///
+
+    	if (this.loadingGui == null && (this.currentScreen == null || this.currentScreen.passEvents))
+    	{
+    		this.profiler.endStartSection("Keybindings");
+    		this.processKeyBinds();
+
+    		if (this.leftClickCounter > 0)
+    		{
+    			--this.leftClickCounter;
+    		}
+    	}
+
+    	// Vivecraft
+    	this.profiler.endStartSection("vrInputActionsTick");
+    	for (VRInputAction action : MCOpenVR.getInputActions()) {
+    		action.tick();
+    	}
+
+    	if (vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY
+    			|| vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON)
+    		VRHotkeys.handleMRKeys();
+
+    	if (this.world != null) {
+    		if (this.player != null) {
+    			// Vivecraft
+    			this.vrPlayer.updateFreeMove();
+    			if (this.vrPlayer.teleportWarningTimer >= 0) {
+    				if (--this.vrPlayer.teleportWarningTimer == 0) {
+    					this.ingameGUI.getChatGUI().printChatMessage(new TranslationTextComponent("vivecraft.messages.noserverplugin"));
+    				}
+    			}
+    		}
+    		this.profiler.endStartSection("gameRenderer");
+
+    		if (!this.isGamePaused)
+    		{
+    			this.gameRenderer.tick();
+    		}
+
+    		this.profiler.endStartSection("levelRenderer");
+
+    		if (!this.isGamePaused)
+    		{
+    			this.worldRenderer.tick();
+    		}
+
+    		this.profiler.endStartSection("level");
+
+    		if (!this.isGamePaused)
+    		{
+    			if (this.world.getTimeLightningFlash() > 0)
+    			{
+    				this.world.setTimeLightningFlash(this.world.getTimeLightningFlash() - 1);
+    			}
+
+    			this.world.tickEntities();
+    		}
+
+    	}
+    	else if (this.gameRenderer.getShaderGroup() != null)
+    	{
+    		this.gameRenderer.stopUseShader();
+    	}
+
+    	// Vivecraft
+    	if (this.menuWorldRenderer != null)
+    		this.menuWorldRenderer.tick();
+    	PlayerModelController.getInstance().tick();
+    	//
+
+    	if (!this.isGamePaused) {
+    		this.musicTicker.tick();
+    	}
+
+    	this.soundHandler.tick(this.isGamePaused);
+
+    	if (this.world != null)
+    	{
+    		if (!this.isGamePaused)
+    		{
+    			this.tutorial.tick();
+
+    			try
+    			{
+    				this.world.tick(() ->
+    				{
+    					return true;
+    				});
+    			}
+    			catch (Throwable throwable)
+    			{
+    				CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception in world tick");
+
+    				if (this.world == null)
+    				{
+    					CrashReportCategory crashreportcategory = crashreport.makeCategory("Affected level");
+    					crashreportcategory.addDetail("Problem", "Level is null!");
+    				}
+    				else
+    				{
+    					this.world.fillCrashReport(crashreport);
+    				}
+
+    				throw new ReportedException(crashreport);
+    			}
+    		}
+
+    		this.profiler.endStartSection("animateTick");
+
+    		if (!this.isGamePaused && this.world != null)
+    		{
+    			this.world.animateTick(MathHelper.floor(this.player.getPosX()), MathHelper.floor(this.player.getPosY()), MathHelper.floor(this.player.getPosZ()));
+    		}
+
+    		this.profiler.endStartSection("particles");
+
+    		if (!this.isGamePaused)
+    		{
+    			this.particles.tick();
+    		}
+    	}
+    	else if (this.networkManager != null)
+    	{
+    		this.profiler.endStartSection("pendingConnection");
+    		this.networkManager.tick();
+    	}
+
+    	this.profiler.endStartSection("keyboard");
+    	this.keyboardListener.tick();
+    	this.profiler.endSection();
+    	//Forge
+    	Reflector.call(Reflector.BasicEventHooks_onPostClientTick);
+    	//
     }
 
     private void processKeyBinds()
     {
         for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer.setDisplayListEntitiesDirty())
         {
-            PointOfView pointofview = this.gameSettings.func_243230_g();
-            this.gameSettings.func_243229_a(this.gameSettings.func_243230_g().func_243194_c());
-
-            if (pointofview.func_243192_a() != this.gameSettings.func_243230_g().func_243192_a())
-            {
-                this.gameRenderer.loadEntityShader(this.gameSettings.func_243230_g().func_243192_a() ? this.getRenderViewEntity() : null);
-            }
+        	//Vivecraft cycle mirror mode
+        	vrSettings.setOptionValue(VrOptions.MIRROR_DISPLAY);
+        	notifyMirror(vrSettings.getButtonDisplayString(VrOptions.MIRROR_DISPLAY), false, 3000);
+        	//
+        	//            PointOfView pointofview = this.gameSettings.func_243230_g();
+        	//            this.gameSettings.func_243229_a(this.gameSettings.func_243230_g().func_243194_c());
+        	//
+        	//            if (pointofview.func_243192_a() != this.gameSettings.func_243230_g().func_243192_a())
+        	//            {
+        	//                this.gameRenderer.loadEntityShader(this.gameSettings.func_243230_g().func_243192_a() ? this.getRenderViewEntity() : null);
+        	//            }
         }
 
         while (this.gameSettings.keyBindSmoothCamera.isPressed())
@@ -1856,7 +2403,9 @@
         {
             if (!this.player.isSpectator() && this.player.drop(Screen.hasControlDown()))
             {
-                this.player.swingArm(Hand.MAIN_HAND);
+            	//Vivecraft - thow anim?
+                this.player.swingArm(Hand.MAIN_HAND,VRFirstPersonArmSwing.Attack);
+                //
             }
         }
 
@@ -1864,7 +2413,7 @@
 
         if (flag2)
         {
-            while (this.gameSettings.keyBindChat.isPressed())
+   			if (this.currentScreen == null && this.gameSettings.keyBindChat.isPressed())
             {
                 this.func_238207_b_("");
             }
@@ -1875,11 +2424,13 @@
             }
         }
 
-        if (this.player.isHandActive())
-        {
-            if (!this.gameSettings.keyBindUseItem.isKeyDown())
-            {
-                this.playerController.onStoppedUsingItem(this.player);
+		if (this.player.isHandActive()) {
+			if (!this.gameSettings.keyBindUseItem.isKeyDown()
+					&& (bowTracker.isActive(player) == false || vrSettings.seated)) {
+				if (!autoFood.isEating()) {
+					NetworkHelper.sendActiveHand((byte) player.getActiveHand().ordinal());
+					this.playerController.onStoppedUsingItem(this.player);
+				}
             }
 
             while (this.gameSettings.keyBindAttack.isPressed())
@@ -1896,10 +2447,18 @@
         }
         else
         {
-            while (this.gameSettings.keyBindAttack.isPressed())
-            {
-                this.clickMouse();
-            }
+			// VIVE SUPPORT HAND SWINGING
+        	if (this.gameSettings.keyBindAttack.isPressed() && currentScreen == null) {
+        		this.clickMouse();
+        		lastClick = true;
+        	} else if (!this.gameSettings.keyBindAttack.isKeyDown()) {
+        		this.leftClickCounter = 0;
+        		if (lastClick) {
+        			this.playerController.resetBlockRemoving();
+        		}
+        		lastClick = false;
+        	}
+			/// END VIVE
 
             while (this.gameSettings.keyBindUseItem.isPressed())
             {
@@ -1917,7 +2476,7 @@
             this.rightClickMouse();
         }
 
-        this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown() && this.mouseHelper.isMouseGrabbed());
+		this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown());
     }
 
     public static DatapackCodec func_238180_a_(SaveFormat.LevelSave p_238180_0_)
@@ -2065,7 +2624,7 @@
 
             while (!this.integratedServer.serverIsInRunLoop())
             {
-                worldloadprogressscreen.tick();
+            	worldloadprogressscreen.tick();
                 this.runGameLoop(false);
 
                 try
@@ -2090,6 +2649,13 @@
             {
             }));
             networkmanager.sendPacket(new CHandshakePacket(socketaddress.toString(), 0, ProtocolType.LOGIN));
+        //Forge
+        com.mojang.authlib.GameProfile gameProfile = this.getSession().getProfile();
+        if((Reflector.ForgeSession_hasCachedProperties.exists() && !Reflector.callBoolean(this.getSession(),Reflector.ForgeSession_hasCachedProperties))) {
+           gameProfile = sessionService.fillProfileProperties(gameProfile, true); //Forge: Fill profile properties upon game load. Fixes MC-52974.
+           Reflector.call(this.getSession(), Reflector.ForgeSession_setProperties, gameProfile.getProperties());
+        }
+        //
             networkmanager.sendPacket(new CLoginStartPacket(this.getSession().getProfile()));
             this.networkManager = networkmanager;
         }
@@ -2188,6 +2754,13 @@
 
     public void loadWorld(ClientWorld worldClientIn)
     {
+		// VIVE START - reset room origin
+		vrPlayer.setRoomOrigin(0, 0, 0, true);
+		// VIVE END - reset room origin
+		    	//Forge
+        if (world != null) 
+        	Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, world));
+        //
         WorkingScreen workingscreen = new WorkingScreen();
         workingscreen.displaySavingString(new TranslationTextComponent("connect.joining"));
         this.updateScreenTick(workingscreen);
@@ -2224,12 +2797,18 @@
         IntegratedServer integratedserver = this.integratedServer;
         this.integratedServer = null;
         this.gameRenderer.resetData();
+        //Forge
+        Reflector.call(Reflector.ClientHooks_firePlayerLogout, this.playerController, this.player);
+        //
         this.playerController = null;
         NarratorChatListener.INSTANCE.clear();
         this.updateScreenTick(screenIn);
 
         if (this.world != null)
         {
+        	//forge
+        	Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, world));
+            //
             if (integratedserver != null)
             {
                 this.profiler.startSection("waitForServer");
@@ -2246,6 +2825,9 @@
             this.ingameGUI.resetPlayersOverlayFooterHeader();
             this.currentServerData = null;
             this.integratedServerIsRunning = false;
+            //forge
+            Reflector.call(Reflector.ClientHooks_handleClientWorldClosing, world);
+            //
             this.game.leaveGameSession();
         }
 
@@ -2279,6 +2861,9 @@
         this.particles.clearEffects(worldIn);
         TileEntityRendererDispatcher.instance.setWorld(worldIn);
         this.func_230150_b_();
+        //Forge
+        Reflector.call(Reflector.MinecraftForgeClient_clearRenderCache);
+        //
     }
 
     public boolean func_238216_r_()
@@ -2338,6 +2923,16 @@
     {
         if (this.objectMouseOver != null && this.objectMouseOver.getType() != RayTraceResult.Type.MISS)
         {
+        	
+			Object inputEvent;
+			inputEvent = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 2, this.gameSettings.keyBindPickBlock, Hand.MAIN_HAND);
+       	
+        	//Forge
+            if (inputEvent != null && !Reflector.callBoolean(inputEvent, Reflector.Event_isCanceled))
+            	Reflector.call(Reflector.ForgeHooks_onPickBlock, this.objectMouseOver, this.player, this.world);
+            if(inputEvent != null) return;
+            //
+            
             boolean flag = this.player.abilities.isCreativeMode;
             TileEntity tileentity = null;
             RayTraceResult.Type raytraceresult$type = this.objectMouseOver.getType();
@@ -2499,6 +3094,8 @@
                 }
             }
         }
+
+		physicalGuiManager.init(player);
     }
 
     private ItemStack storeTEInStack(ItemStack stack, TileEntity te)
@@ -3007,8 +3604,12 @@
         {
             supplier = wrapV4(supplier);
         }
-
-        return new ResourcePackInfo(name, isAlwaysEnabled, supplier, p_228011_3_, p_228011_4_, priority, p_228011_6_);
+        //Forge
+        if(Reflector.IForgeIResourcePack_isHidden.exists())
+        	return (ResourcePackInfo) Reflector.newInstance(Reflector.ClientResourcePackInfo_Constructor, name, isAlwaysEnabled, supplier, p_228011_3_, p_228011_4_, priority, p_228011_6_, Reflector.callBoolean(p_228011_3_,Reflector.IForgeIResourcePack_isHidden));
+        else 
+            return new ResourcePackInfo(name, isAlwaysEnabled, supplier, p_228011_3_, p_228011_4_, priority, p_228011_6_);
+        //
     }
 
     private static Supplier<IResourcePack> wrapV3(Supplier<IResourcePack> p_228021_0_)
@@ -3073,4 +3674,511 @@
         CREATE,
         BACKUP;
     }
+
+	// VIVECRAFT ADDITIONS
+	// **************************************************************************
+
+	public void printChatMessage(String msg) {
+		if (this.world != null) {
+			ITextComponent chatText = new StringTextComponent(msg);
+			this.ingameGUI.getChatGUI().printChatMessage(chatText);
+		}
+	}
+
+
+	public void printGLMatrix(String derp) {
+		GL11.glGetFloatv(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		matrixBuffer.rewind();
+		Matrix4f temp = new Matrix4f();
+		temp.load(matrixBuffer);
+		System.out.println(derp + "\r\n" + temp.toString());
+		matrixBuffer.rewind();
+	}
+
+	public void clearGLError() // bad bad bad
+	{
+		int var2 = GL11.glGetError();
+	}
+
+
+	private void copyToMirror() {
+		// VIVE start - render eye buffers to the desktop window
+
+		if (this.vrSettings.displayMirrorMode < VRSettings.MIRROR_OFF) // new values
+			this.vrSettings.displayMirrorMode = VRSettings.MIRROR_ON_CROPPED;
+
+		if (this.vrSettings.displayMirrorMode > VRSettings.MIRROR_ON_CROPPED) // new values
+			this.vrSettings.displayMirrorMode = VRSettings.MIRROR_ON_CROPPED;
+
+		if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF && MCOpenVR.isHMDTracking()) {
+			notifyMirror("Mirror is OFF", true, 1000);
+		} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY)  {
+			if (VRShaders._DepthMask_shaderProgramId != 0) {
+				doMixedRealityMirror();
+			} else {
+				notifyMirror("Shader compile failed, see log", true, 10000);
+			}
+		} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_DUAL){
+			Framebuffer source = stereoProvider.framebufferEye0;
+			Framebuffer source2 = stereoProvider.framebufferEye1;	
+
+			//debug
+			//source2 = worldRenderer.func_239229_r_(); //Particles
+			//source2 = stereoProvider.telescopeFramebufferR;
+			
+			if (source != null)
+				source.framebufferRenderExt(0,
+						mainWindow.getWidth() / 2, mainWindow.getHeight(), 0, true,0,0, false);	
+
+			if (source2 != null)
+				source2.framebufferRenderExt((mainWindow.getWidth() / 2),
+						mainWindow.getWidth() / 2, mainWindow.getHeight(), 0, true,0,0, false);
+
+		}  
+		else {
+			float xcrop = 0;
+			float ycrop = 0;
+			boolean ar = false;
+			Framebuffer source = stereoProvider.framebufferEye0;
+			if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_FIRST_PERSON) {
+				source = stereoProvider.framebufferUndistorted;
+			} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON) {
+				source = stereoProvider.framebufferMR;
+			} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_SINGLE || this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF) {
+				if (!this.vrSettings.displayMirrorLeftEye)
+					source = stereoProvider.framebufferEye1;
+			} else if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_CROPPED) {
+				if (!this.vrSettings.displayMirrorLeftEye)
+					source = stereoProvider.framebufferEye1;
+				xcrop = 0.15f;
+				ycrop = 0.15f;
+				ar = true;
+			}
+			//debug
+			//	source = GuiHandler.guiFramebuffer;
+			//	source = stereoProvider.framebufferEye0;
+			//	source = stereoProvider.framebufferEye1;
+			//	source = GuiHandler.guiFramebuffer;
+			//source = worldRenderer.func_239228_q_(); //water
+			//source = worldRenderer.func_239229_r_(); //entity glint
+			//source = worldRenderer.func_239232_u_(); //Clouds
+	     	//source = worldRenderer.func_239230_s_(); //Particles
+	     	//source = stereoProvider.telescopeFramebufferR;
+			
+			if (source != null)
+				source.framebufferRenderExt(0,mainWindow.getWidth(), mainWindow.getHeight(), 0, true, xcrop, ycrop, ar);
+		}
+	}
+
+	private void doMixedRealityMirror() {
+		boolean hasShaders = Config.isShaders();
+		boolean alphaMask = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+
+		if (!alphaMask)
+			GlStateManager.clearColor(vrSettings.mixedRealityKeyColor.getRed() / 255F,
+					vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F,
+					1);
+		else
+			GlStateManager.clearColor(0, 0, 0, 1);
+		
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+		Vector3d camplayer = vrPlayer.vrdata_room_pre.getHeadPivot().subtract(vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getPosition());	
+
+		net.minecraft.util.math.vector.Matrix4f viewMatrix = vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transposed().toMCMatrix();
+		Vector3 CameraLook = vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transform(Vector3.forward());
+		
+		GlStateManager.useProgram(VRShaders._DepthMask_shaderProgramId);
+		
+		// set projection matrix
+		gameRenderer.thirdPassProjectionMatrix.write(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_projectionMatrix, false, matrixBuffer);
+
+		// set view matrix
+		viewMatrix.write(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_viewMatrix, false, matrixBuffer);
+
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float) camplayer.x, (float) camplayer.y,
+				(float) camplayer.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, (float) -CameraLook.getX(), 0,
+				(float) -CameraLook.getZ());
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform,
+				vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F,
+				vrSettings.mixedRealityKeyColor.getBlue() / 255F);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, alphaMask ? 1 : 0);
+
+		// bind color and depth textures
+		GlStateManager.activeTexture(GL13.GL_TEXTURE1);
+		stereoProvider.framebufferMR.bindFramebufferTexture();
+		
+		GlStateManager.activeTexture(GL13.GL_TEXTURE2);
+		if (hasShaders)
+			GlStateManager.bindTexture(Shaders.dfbDepthTextures.get(0)); // shadersmod has it's own depth buffer
+		else
+			GlStateManager.bindTexture(stereoProvider.framebufferMR.depthBuffer);
+		
+		GlStateManager.activeTexture(GL13.GL_TEXTURE0);
+		
+		for (int i = 0; i < (alphaMask ? 3 : 2); i++) {
+
+			int resW = mainWindow.getWidth() / 2;
+			int resH = mainWindow.getHeight();
+			int posW = (mainWindow.getWidth() / 2) * i;
+			int posH = 0;
+
+			if (this.vrSettings.mixedRealityUnityLike) {
+				resW = mainWindow.getWidth() / 2;
+				resH = mainWindow.getHeight() / 2;
+				if (this.vrSettings.mixedRealityAlphaMask && i == 2) {
+					posW = mainWindow.getWidth() / 2;
+					posH = mainWindow.getHeight() / 2;
+				} else {
+					posW = 0;
+					posH = (mainWindow.getHeight() / 2) * (1 - i);
+				}
+			}
+
+			// set other uniforms
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, resW, resH);
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, posW, posH);
+			ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+
+			// draw framebuffer
+			stereoProvider.framebufferMR.framebufferRenderExt(posW, resW, resH, posH, true,0,0, false);
+		}
+		
+		GlStateManager.useProgram(0);
+
+		if (this.vrSettings.mixedRealityUnityLike) {
+			if (this.vrSettings.mixedRealityMRPlusUndistorted)
+				stereoProvider.framebufferUndistorted.framebufferRenderExt(mainWindow.getWidth() / 2,
+						mainWindow.getWidth() / 2, mainWindow.getHeight() / 2, 0, true,0,0, false);
+			else
+				stereoProvider.framebufferEye0.framebufferRenderExt(mainWindow.getWidth() / 2,
+						mainWindow.getWidth() / 2, mainWindow.getHeight() / 2, 0, true,0,0, false);
+		}
+
+	}
+
+	private float fov = 1.0f;
+
+	private void checkGLError(String message) {
+		Config.checkGlError(message);
+	}
+
+	public void initMinecrift() throws Exception {
+		new MCOpenVR();
+		MCOpenVR.init();
+		this.stereoProvider = new OpenVRStereoRenderer();
+
+		this.vrPlayer = new OpenVRPlayer();
+
+		stereoProvider.lastGuiScale = this.gameSettings.guiScale;
+
+		// register Trackers
+		vrPlayer.registerTracker(backpackTracker);
+		vrPlayer.registerTracker(bowTracker);
+		vrPlayer.registerTracker(climbTracker);
+		vrPlayer.registerTracker(autoFood);
+		vrPlayer.registerTracker(jumpTracker);
+		vrPlayer.registerTracker(rowTracker);
+		vrPlayer.registerTracker(runTracker);
+		vrPlayer.registerTracker(sneakTracker);
+		vrPlayer.registerTracker(swimTracker);
+		vrPlayer.registerTracker(swingTracker);
+		vrPlayer.registerTracker(interactTracker);
+		vrPlayer.registerTracker(teleportTracker);
+		vrPlayer.registerTracker(horseTracker);
+		vrPlayer.registerTracker(vehicleTracker);
+		vrPlayer.registerTracker(physicalGuiManager);
+		vrPlayer.registerTracker(crawlTracker);
+	}
+
+	private static void sleepNanos(long nanoDelay) {
+		final long end = System.nanoTime() + nanoDelay;
+		do {
+			Thread.yield(); // This is a busy wait sadly...
+		} while (System.nanoTime() < end);
+	}
+
+	private void addRunTickTimeNanos(long runTickTime) {
+		int i = 0;
+		medianRunTickTimeNanos = runTickTime;
+
+		if (this.vrSettings.smoothRunTickCount < 1)
+			this.vrSettings.smoothRunTickCount = 1;
+
+		if (this.vrSettings.smoothRunTickCount % 2 == 0) {
+			// Need an odd number for this
+			this.vrSettings.smoothRunTickCount++;
+		}
+
+		runTickTimeNanos.addFirst(runTickTime);
+		while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+			runTickTimeNanos.removeLast();
+
+		if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount) {
+			Long[] array = new Long[runTickTimeNanos.size()];
+			for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++) {
+				array[i] = (Long) itr.next();
+			}
+			Arrays.sort(array);
+			medianRunTickTimeNanos = array[array.length / 2];
+		}
+	}
+
+	private long getMedianRunTickTimeNanos() {
+		return medianRunTickTimeNanos;
+	}
+
+	public void triggerYawTransition(boolean isPositive) {
+		// this.lookaimController.triggerYawTransition(isPositive);
+	}
+
+	public void print(String s) {
+		s = s.replace("\n", "\n[Minecrift] ");
+		System.out.println("[Minecrift] " + s);
+	}
+
+	public float watereffect, portaleffect, pumpkineffect;
+
+	private void renderSingleView(int eye, float nano, boolean renderworld) {
+
+		GlStateManager.clearColor(0, 0, 0, 1f);
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+		GlStateManager.enableTexture();
+		GlStateManager.enableDepthTest();
+
+		this.profiler.startSection("updateCameraAndRender");
+		// Forge calls onRenderTickStart > move to rungameloop
+
+		/// THIS IS WHERE EVERYTHING IS RENDERED
+		this.gameRenderer.updateCameraAndRender(nano, System.nanoTime(), renderworld);
+
+		// Forge calls onRenderTickEnd > move to rungameloop
+		this.profiler.endSection();
+		checkGLError("post game render " + eye);
+		
+		if (currentPass == RenderPass.LEFT || currentPass == RenderPass.RIGHT) {
+			// copies the rendered scene to eye tex with fsaa and other postprocessing
+			// effects.
+			this.profiler.startSection("postprocesseye");
+
+			Framebuffer source = this.framebuffer;
+
+			if (this.vrSettings.useFsaa) {
+				this.profiler.startSection("fsaa");
+				stereoProvider.doFSAA(Config.isShaders());
+				source = stereoProvider.fsaaLastPassResultFBO;
+				checkGLError("fsaa " + eye);
+				this.profiler.endSection();
+			}
+
+			if (currentPass == RenderPass.LEFT)
+				stereoProvider.framebufferEye0.bindFramebuffer(true); // draw to L eye tex
+			else
+				stereoProvider.framebufferEye1.bindFramebuffer(true); // draw to R eye tex
+
+			if (vrSettings.useFOVReduction && vrPlayer.getFreeMove()) {
+				if (player != null && (Math.abs(player.moveForward) > 0 || Math.abs(player.moveStrafing) > 0)) {
+					fov -= 0.05;
+					if (fov < vrSettings.fovReductionMin)
+						fov = vrSettings.fovReductionMin;
+				} else {
+					fov += 0.01;
+					if (fov > 0.8)
+						fov = 0.8f;
+				}
+			} else {
+				fov = 1f;
+			}
+
+			ARBShaderObjects.glUseProgramObjectARB(VRShaders._FOVReduction_shaderProgramId);
+			ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+			ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_OffsetUniform, vrSettings.fovRedutioncOffset);
+
+			// VIVE start - screen flash when hurt instead of view tilt
+			float r = 0, k = 0;
+			// VIVE start - screen flash when hurt instead of view tilt
+			float time = (float) Util.milliTime() / 1000;
+			if (player != null && world != null) {
+
+				if (gameRenderer.wasinwater != gameRenderer.inwater) {
+					watereffect = 2.3f;
+				} else {
+					if (gameRenderer.inwater) {
+						watereffect -= (1f / 120f);
+					} else {
+						watereffect -= (1f / 60f);
+					}
+					if (watereffect < 0)
+						watereffect = 0;
+				}
+
+				gameRenderer.wasinwater = gameRenderer.inwater;
+
+				if (Config.isShaders())
+					watereffect = 0; // dont stack.
+
+				if (gameRenderer.inportal) {
+					portaleffect = 1f;
+				} else {
+					portaleffect -= (1f / 60f);
+					if (portaleffect < 0)
+						portaleffect = 0;
+				}
+
+				if (player.inventory.armorItemInSlot(3).getItem() == Blocks.CARVED_PUMPKIN.asItem()) {
+					pumpkineffect = 1f;
+				}
+
+				float var3 = (float) player.hurtTime - nano;
+
+				float percent = 1 - player.getHealth() / player.getMaxHealth();
+				percent = (percent - 0.5f) * 0.75f;
+
+				if (var3 > 0.0f) {
+					var3 /= (float) player.maxHurtTime;
+					var3 = percent + MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+					r = var3;
+				} else {
+					r = (float) (percent * Math.abs(Math.sin(2.5f * time / (1 - percent + .1))));
+					if (player.isCreative())
+						r = 0;
+				}
+
+//				if (gameRenderer.inblock && player.isAlive()) {
+//					// k = (float) gameRenderer.itemRenderer.inBlock;
+//				}
+
+				if (player.isSleeping()) {
+					if (k < 0.8)
+						k = .8f;
+				}
+
+				if (MCOpenVR.isWalkingAbout) {
+					if (k < 0.8)
+						k = .5f;
+				}
+
+			} else {
+				watereffect = 0;
+				portaleffect = 0;
+				pumpkineffect = 0;
+			}
+			
+			if (pumpkineffect > 0) {
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.3f);
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0f);
+			} else {
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, fov);
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06f);
+			}
+			
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, r);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, k);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time, time);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, watereffect);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, portaleffect);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, pumpkineffect);
+			ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, currentPass == currentPass.LEFT ? 1 : -1);
+
+			source.framebufferRender(stereoProvider.framebufferEye0.framebufferWidth,
+					stereoProvider.framebufferEye0.framebufferHeight);
+
+			ARBShaderObjects.glUseProgramObjectARB(0);
+
+			checkGLError("post overlay" + eye);
+
+			this.profiler.endSection();
+
+			// this.mcProfiler.startSection("OpenGL Finish");
+			// GL11.glFinish();//DO NOT LEAVE THIS UNCOMMENTED
+			// this.mcProfiler.endSection();
+
+		}
+	}
+
+	private float frameDelta, prevFrameTime;
+
+	public float getFrameDelta() {
+		return frameDelta;
+	}
+
+	// FORGE
+	public ItemColors getItemColors() {
+		return this.itemColors;
+	}
+
+	public SearchTreeManager getSearchTreeManager() {
+		return this.searchTreeManager;
+	}
+	//
+
+	public void loadClassPath() {
+		File resourceRoot = new File("../src/resources");
+		if (!resourceRoot.exists() || !resourceRoot.isDirectory())
+			return;
+		Method method = null;
+		try {
+			method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+			method.setAccessible(true);
+			method.invoke(ClassLoader.getSystemClassLoader(), resourceRoot.toURI().toURL());
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+
+	}
+
+	long mirroNotifyStart;
+	String mirrorNotifyText;
+	boolean mirrorNotifyClear;
+	long mirroNotifyLen;
+	
+	public void notifyMirror( String text, boolean clear, int lengthMs) {
+		mirroNotifyStart = System.currentTimeMillis();
+		mirroNotifyLen = lengthMs;
+		mirrorNotifyText = text;
+		mirrorNotifyClear = clear;
+	}
+
+	private void drawNotifyMirror() {
+		if (System.currentTimeMillis() < mirroNotifyStart + mirroNotifyLen) {
+			
+			RenderSystem.viewport(0, 0, mainWindow.getWidth(), mainWindow.getHeight());
+			RenderSystem.matrixMode(5889);
+			RenderSystem.loadIdentity();
+			RenderSystem.ortho(0.0D, (double)mainWindow.getWidth() /4, (double)mainWindow.getHeight()/4, 0.0D, -10, 10);
+			RenderSystem.matrixMode(5888);
+			RenderSystem.loadIdentity();
+			RenderSystem.clear(256, Minecraft.IS_RUNNING_ON_MAC);
+	
+			RenderSystem.fogMode(FogMode.EXP2); //dont ask
+			RenderSystem.fogDensity(0); //dont ask
+			RenderSystem.disableFog(); //ask why this does nothing
+			
+			if(mirrorNotifyClear) {
+				RenderSystem.clearColor(0, 0, 0, 0);
+				RenderSystem.clear(GL11.GL_COLOR_BUFFER_BIT, Minecraft.IS_RUNNING_ON_MAC);
+			}
+			
+			final int TEXT_WORDWRAP_LEN = mainWindow.getWidth()/22;
+	    	ArrayList<String> wrapped = new ArrayList<String>();
+	    	if (mirrorNotifyText != null)
+	    		org.vivecraft.utils.Utils.wordWrap(mirrorNotifyText, TEXT_WORDWRAP_LEN, wrapped);
+	    	int column = 1;
+	    	final int COLUMN_GAP = 12;    	
+	    	for (String line : wrapped)
+        	{
+        		fontRenderer.drawString(new MatrixStack(), line, 1, column, /*white*/16777215);
+        		column += COLUMN_GAP;
+        	}
+	    	
+		}
+	}
+	
 }
